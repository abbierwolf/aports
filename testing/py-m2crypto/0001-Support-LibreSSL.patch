diff --git a/SWIG/_aes.i b/SWIG/_aes.i
index ea36167..d14e541 100644
--- a/SWIG/_aes.i
+++ b/SWIG/_aes.i
@@ -41,34 +41,34 @@ void AES_free(AES_KEY *key) {
 }
 
 /* 
-// op == 0: encrypt
-// otherwise: decrypt (Python code will supply the value 1.)
+// op == 0: decrypt
+// otherwise: encrypt (Python code will supply the value 1.)
 */
 PyObject *AES_set_key(AES_KEY *key, PyObject *value, int bits, int op) { 
-    char *vbuf; 
+    const void *vbuf; 
     Py_ssize_t vlen;
 
-    if (PyBytes_AsStringAndSize(value, &vbuf, &vlen) == -1)
+    if (PyObject_AsReadBuffer(value, &vbuf, &vlen) == -1)
         return NULL;
 
     if (op == 0) 
-        AES_set_encrypt_key((const unsigned char *)vbuf, bits, key);
+        AES_set_encrypt_key(vbuf, bits, key);
     else
-        AES_set_decrypt_key((const unsigned char *)vbuf, bits, key);
+        AES_set_decrypt_key(vbuf, bits, key);
     Py_RETURN_NONE;
 }
 
 /* 
-// op == 0: encrypt
-// otherwise: decrypt (Python code will supply the value 1.)
+// op == 0: decrypt
+// otherwise: encrypt (Python code will supply the value 1.)
 */
 PyObject *AES_crypt(const AES_KEY *key, PyObject *in, int outlen, int op) {
-    char *buf;
+    const void *buf;
     Py_ssize_t len;
     unsigned char *out;
     PyObject *res;
 
-    if (PyBytes_AsStringAndSize(in, &buf, &len) == -1)
+    if (PyObject_AsReadBuffer(in, &buf, &len) == -1)
         return NULL;
 
     if (!(out=(unsigned char *)PyMem_Malloc(outlen))) {
@@ -76,10 +76,14 @@ PyObject *AES_crypt(const AES_KEY *key, PyObject *in, int outlen, int op) {
         return NULL;
     }
     if (op == 0)
-        AES_encrypt((const unsigned char *)buf, out, key);
+        AES_encrypt((const unsigned char *)in, out, key);
     else
-        AES_decrypt((const unsigned char *)buf, out, key);
-    res = PyBytes_FromStringAndSize((char*)out, outlen);
+        AES_decrypt((const unsigned char *)in, out, key);
+#if PY_MAJOR_VERSION >= 3
+    return PyBytes_FromStringAndSize((char*)out, outlen);
+#else
+    return PyString_FromStringAndSize((char*)out, outlen);
+#endif // PY_MAJOR_VERSION >= 3
     PyMem_Free(out);
     return res;
 }
diff --git a/SWIG/_asn1.i b/SWIG/_asn1.i
index 0c36519..35be9a0 100644
--- a/SWIG/_asn1.i
+++ b/SWIG/_asn1.i
@@ -36,11 +36,20 @@ extern ASN1_STRING *ASN1_STRING_new( void );
 extern void ASN1_STRING_free( ASN1_STRING *);
 
 %typemap(in) (const void *, int) {
+#if PY_MAJOR_VERSION >= 3
     if (PyBytes_Check($input)) {
         Py_ssize_t len;
 
         $1 = PyBytes_AsString($input);
         len = PyBytes_Size($input);
+#else
+    if (PyString_Check($input)) {
+        Py_ssize_t len;
+
+        $1 = PyString_AsString($input);
+        len = PyString_Size($input);
+
+#endif // PY_MAJOR_VERSION >= 3
 
         if (len > INT_MAX) {
             PyErr_SetString(PyExc_ValueError, "object too large");
@@ -144,10 +153,6 @@ int asn1_integer_set(ASN1_INTEGER *asn1, PyObject *value) {
     BIGNUM *bn = NULL;
     PyObject *fmt, *args, *hex;
 
-/* Despite all hopes to the contrary, we cannot survive here with
- * PyLong_AsLong shims as provided in
- * /usr/include/python2.7/longobject.h.
- */
 #if PY_MAJOR_VERSION >= 3
     if (PyLong_Check(value))
         return ASN1_INTEGER_set(asn1, PyLong_AsLong(value));
diff --git a/SWIG/_bio.i b/SWIG/_bio.i
index e85a275..cd7fe53 100644
--- a/SWIG/_bio.i
+++ b/SWIG/_bio.i
@@ -4,8 +4,7 @@
  * Portions created by Open Source Applications Foundation (OSAF) are
  * Copyright (C) 2004-2005 OSAF. All Rights Reserved.
  * Author: Heikki Toivonen
- *
- * Copyright 2018 Daniel Wozniak. All Rights Reserved.*/
+*/
 /* $Id$ */
 
 %{
@@ -34,6 +33,11 @@ extern BIO *BIO_new(BIO_METHOD *);
 extern BIO *BIO_new_socket(int, int);
 %rename(bio_new_fd) BIO_new_pyfd;
 %rename(bio_new_pyfd) BIO_new_pyfd;
+%rename(bio_new_file) BIO_new_file;
+extern BIO *BIO_new_file(const char *, const char *);
+%rename(bio_free) BIO_free;
+%threadallow BIO_free;
+extern int BIO_free(BIO *);
 %rename(bio_free_all) BIO_free_all;
 %threadallow BIO_free_all;
 extern void BIO_free_all(BIO *);
@@ -45,9 +49,6 @@ extern BIO *BIO_push(BIO *, BIO *);
 %rename(bio_pop) BIO_pop;
 extern BIO *BIO_pop(BIO *);
 
-%rename(bio_eof) BIO_eof;
-extern int BIO_eof(BIO *);
-
 %constant int bio_noclose             = BIO_NOCLOSE;
 %constant int bio_close               = BIO_CLOSE;
 %constant int BIO_FLAGS_READ          = 0x01;
@@ -62,64 +63,62 @@ extern int BIO_eof(BIO *);
 static PyObject *_bio_err;
 
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER)
 void pyfd_init(void);
+#endif
 
 void bio_init(PyObject *bio_err) {
     Py_INCREF(bio_err);
     _bio_err = bio_err;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER)
     pyfd_init();
-}
-
-int bio_free(BIO *bio) {
-    int ret;
-
-    Py_BEGIN_ALLOW_THREADS
-    ret = BIO_free(bio);
-    Py_END_ALLOW_THREADS
-    if (ret == 0) {
-        m2_PyErr_Msg(_bio_err);
-    }
-    return ret;
-}
-
-BIO * bio_new_file(const char *filename, const char *mode) {
-    BIO *ret;
-
-    Py_BEGIN_ALLOW_THREADS
-    ret = BIO_new_file(filename, mode);
-    Py_END_ALLOW_THREADS
-
-    if (ret == NULL) {
-        m2_PyErr_Msg(_bio_err);
-    }
-
-    return ret;
+#endif
 }
 
 BIO *bio_new_pyfile(PyObject *pyfile, int bio_close) {
     FILE *fp = NULL;
-    BIO *bio = NULL;
+#if PY_MAJOR_VERSION >= 3
+    if (PyObject_HasAttrString(pyfile, "fileno")) {
+        int fd = (int)PyLong_AsLong(PyObject_CallMethod(pyfile, "fileno", NULL));
+        if (PyObject_HasAttrString(pyfile, "mode")) {
+            char *mode = PyUnicode_AsUTF8AndSize(
+                    PyObject_CallMethod(pyfile, "mode", NULL), NULL);
+            fp = fdopen(fd, mode);
+        }
+        else {
+            PyErr_Format(PyExc_ValueError,
+                         "File doesn’t have mode attribute!");
+            return NULL;
+        }
+    }
+    else {
+        PyErr_Format(PyExc_ValueError, "File doesn’t have fileno method!");
+        return NULL;
+    }
 
+#else
     fp = PyFile_AsFile(pyfile);
+#endif
+    BIO *bio = BIO_new_fp(fp, bio_close); /* returns NULL if error occurred */
 
-    bio = BIO_new_fp(fp, bio_close);
-
-    /* returns NULL if error occurred */
     if (bio == NULL) {
-        /* Find out the name of the file so we can have good error
-         * message. */
-        PyObject *pyname = m2_PyFile_Name(pyfile);
-        char *name = PyBytes_AsString(pyname);
-
-        if (name == NULL) {
-            PyErr_Format(_bio_err,
-                         "Opening of the new BIO on file failed!");
+        char *name = "";
+#if PY_MAJOR_VERSION >= 3
+        if (PyObject_HasAttrString(pyfile, "name")) {
+            char *name = PyUnicode_AsUTF8AndSize(
+                    PyObject_CallMethod(pyfile, "name", NULL), NULL);
         }
         else {
-            PyErr_Format(_bio_err,
-                         "Opening of the new BIO on file %s failed!", name);
+            PyErr_Format(PyExc_ValueError,
+                         "File doesn’t have name attribute!");
+            return NULL;
         }
-        Py_DECREF(pyname);
+#else
+        name = PyString_AsString(PyFile_Name(pyfile));
+#endif
+        PyErr_Format(PyExc_MemoryError,
+                     "Opening of the new BIO on file %s failed!", name);
+        return NULL;
     }
     return bio;
 }
@@ -145,7 +144,11 @@ PyObject *bio_read(BIO *bio, int num) {
         Py_RETURN_NONE;
     }
 
+#if PY_MAJOR_VERSION >= 3
     blob = PyBytes_FromStringAndSize(buf, r);
+#else
+    blob = PyString_FromStringAndSize(buf, r);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(buf);
     return blob;
@@ -172,7 +175,11 @@ PyObject *bio_gets(BIO *bio, int num) {
         Py_RETURN_NONE;
     }
 
+#if PY_MAJOR_VERSION >= 3
     blob = PyBytes_FromStringAndSize(buf, r);
+#else
+    blob = PyString_FromStringAndSize(buf, r);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(buf);
     return blob;
@@ -180,7 +187,7 @@ PyObject *bio_gets(BIO *bio, int num) {
 
 int bio_write(BIO *bio, PyObject *from) {
     const void *fbuf;
-    int flen = 0, ret;
+    int flen, ret;
 
     if (m2_PyObject_AsReadBufferInt(from, &fbuf, &flen) == -1)
         return -1;
@@ -292,48 +299,10 @@ int bio_should_write(BIO* a) {
     return BIO_should_write(a);
 }
 
-/* Macros for things not defined before 1.1.0 */
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
-static BIO_METHOD *
-BIO_meth_new( int type, const char *name )
-{
-    BIO_METHOD *method = malloc( sizeof(BIO_METHOD) );
-    memset( method, 0, sizeof(BIO_METHOD) );
-
-    method->type = type;
-    method->name = name;
-
-    return method;
-}
-
-static void
-BIO_meth_free( BIO_METHOD *meth )
-{
-    if ( meth == NULL ) {
-        return;
-    }
-
-    free(meth);
-}
-#define BIO_meth_set_write(m, f) (m)->bwrite = (f)
-#define BIO_meth_set_read(m, f) (m)->bread = (f)
-#define BIO_meth_set_puts(m, f) (m)->bputs = (f)
-#define BIO_meth_set_gets(m, f) (m)->bgets = (f)
-#define BIO_meth_set_ctrl(m, f) (m)->ctrl = (f)
-#define BIO_meth_set_create(m, f) (m)->create = (f)
-#define BIO_meth_set_destroy(m, f) (m)->destroy = (f)
-#define BIO_set_shutdown(b, x) (b)->shutdown = x
-#define BIO_get_shutdown(b) (b)->shutdown
-#define BIO_set_init(b, x)    b->init = x
-#define BIO_get_init(b) (b)->init
-#define BIO_set_data(b, x)    b->ptr = x
-#define BIO_clear_flags(b, x)    b->flags &= ~(x)
-#define BIO_get_data(b)    b->ptr
-#endif
-
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER)
 /* implment custom BIO_s_pyfd */
 
-#ifdef _WIN32
+#ifdef WIN32
 #  define clear_sys_error()       SetLastError(0)
 /* Linux doesn't use underscored calls yet */
 #  define open(p, f, m) _open(p, f, m)
@@ -342,7 +311,7 @@ BIO_meth_free( BIO_METHOD *meth )
 #  define close(f) _close(f)
 #  define lseek(fd, o, w) _lseek(fd, o, w)
 #else
-# define clear_sys_error()       errno=0
+#  define clear_sys_error()       errno=0
 #endif
 
 typedef struct pyfd_struct {
@@ -515,15 +484,9 @@ static long pyfd_ctrl(BIO *b, int cmd, long num, void *ptr) {
 }
 
 void pyfd_init(void) {
-#if OPENSSL_VERSION_NUMBER >= 0x10100000L
     methods_fdp = BIO_meth_new(
         BIO_get_new_index()|BIO_TYPE_DESCRIPTOR|BIO_TYPE_SOURCE_SINK,
         "python file descriptor");
-#else
-    methods_fdp = BIO_meth_new(
-        100 |BIO_TYPE_DESCRIPTOR|BIO_TYPE_SOURCE_SINK,
-        "python file descriptor");
-#endif
 
     BIO_meth_set_write(methods_fdp, pyfd_write);
     BIO_meth_set_read(methods_fdp, pyfd_read);
@@ -541,5 +504,6 @@ BIO* BIO_new_pyfd(int fd, int close_flag) {
     BIO_set_fd(ret, fd, close_flag);
     return ret;
     }
+#endif
 %}
 
diff --git a/SWIG/_bn.i b/SWIG/_bn.i
old mode 100644
new mode 100755
index 18dc154..cb0cd33
--- a/SWIG/_bn.i
+++ b/SWIG/_bn.i
@@ -55,11 +55,14 @@ PyObject *bn_rand_range(PyObject *range)
     BIGNUM *rng = NULL;
     PyObject *ret, *tuple;
     PyObject *format, *rangePyString;
-    char *randhex; /* PyLong_FromString is unhappy with const */
-    const char *rangehex;
+    char *randhex, *rangehex;
 
     /* Wow, it's a lot of work to convert into a hex string in C! */
+#if PY_MAJOR_VERSION >= 3
     format = PyUnicode_FromString("%x");
+#else
+    format = PyString_FromString("%x");
+#endif // PY_MAJOR_VERSION >= 3
 
     if (!format) {
         PyErr_SetString(PyExc_RuntimeError, "Cannot create Python string '%x'");
@@ -74,7 +77,11 @@ PyObject *bn_rand_range(PyObject *range)
     Py_INCREF(range);
     PyTuple_SET_ITEM(tuple, 0, range);
 
+#if PY_MAJOR_VERSION >= 3
     rangePyString = PyUnicode_Format(format, tuple);
+#else
+    rangePyString = PyString_Format(format, tuple);
+#endif // PY_MAJOR_VERSION >= 3
 
     if (!rangePyString) {
         PyErr_SetString(PyExc_Exception, "String Format failed");
@@ -85,7 +92,11 @@ PyObject *bn_rand_range(PyObject *range)
     Py_DECREF(format);
     Py_DECREF(tuple);
 
-    rangehex = (const char*)PyUnicode_AsUTF8(rangePyString);
+#if PY_MAJOR_VERSION >= 3
+    rangehex = PyUnicode_AsUTF8(rangePyString);
+#else
+    rangehex = PyString_AsString(rangePyString);
+#endif // PY_MAJOR_VERSION >= 3
 
     if (!BN_hex2bn(&rng, rangehex)) {
         /*Custom errors?*/
diff --git a/SWIG/_dh.i b/SWIG/_dh.i
index 398f418..330c226 100644
--- a/SWIG/_dh.i
+++ b/SWIG/_dh.i
@@ -94,7 +94,7 @@ int dh_check(DH *dh) {
 
 PyObject *dh_compute_key(DH *dh, PyObject *pubkey) {
     const void *pkbuf;
-    int pklen = 0, klen;
+    int pklen, klen;
     void *key;
     BIGNUM *pk;
     PyObject *ret;
@@ -118,7 +118,11 @@ PyObject *dh_compute_key(DH *dh, PyObject *pubkey) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((const char *)key, klen);
+#else
+	ret = PyString_FromStringAndSize((const char *)key, klen);
+#endif // PY_MAJOR_VERSION >= 3
 
     BN_free(pk);
     PyMem_Free(key);
diff --git a/SWIG/_dsa.i b/SWIG/_dsa.i
index 2c15c4f..2d88c96 100644
--- a/SWIG/_dsa.i
+++ b/SWIG/_dsa.i
@@ -39,18 +39,7 @@ void dsa_init(PyObject *dsa_err) {
     Py_INCREF(dsa_err);
     _dsa_err = dsa_err;
 }
-%}
-
-%typemap(out) DSA * {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
 
-    if ($1 != NULL)
-        $result = SWIG_NewPointerObj($1, $1_descriptor, 0);
-    else {
-        $result = NULL;
-    }
-}
-%inline %{
 DSA *dsa_generate_parameters(int bits, PyObject *pyfunc) {
     DSA *dsa;
     BN_GENCB *gencb;
@@ -83,57 +72,6 @@ DSA *dsa_generate_parameters(int bits, PyObject *pyfunc) {
     return NULL;
 }
 
-DSA *dsa_read_params(BIO *f, PyObject *pyfunc) {
-    DSA *ret;
-
-    Py_INCREF(pyfunc);
-    Py_BEGIN_ALLOW_THREADS
-    ret = PEM_read_bio_DSAparams(f, NULL, passphrase_callback, (void *)pyfunc);
-    Py_END_ALLOW_THREADS
-    Py_DECREF(pyfunc);
-
-    if (ret == NULL) {
-        m2_PyErr_Msg(_dsa_err);
-    }
-
-    return ret;
-}
-
-DSA *dsa_read_key(BIO *f, PyObject *pyfunc) {
-    DSA *ret;
-
-    Py_INCREF(pyfunc);
-    Py_BEGIN_ALLOW_THREADS
-    ret = PEM_read_bio_DSAPrivateKey(f, NULL, passphrase_callback, (void *)pyfunc);
-    Py_END_ALLOW_THREADS
-    Py_DECREF(pyfunc);
-
-    if (ret == NULL) {
-        m2_PyErr_Msg(_dsa_err);
-    }
-
-    return ret;
-}
-
-DSA *dsa_read_pub_key(BIO *f, PyObject *pyfunc) {
-    DSA *ret;
-
-    Py_INCREF(pyfunc);
-    Py_BEGIN_ALLOW_THREADS
-    ret = PEM_read_bio_DSA_PUBKEY(f, NULL, passphrase_callback, (void *)pyfunc);
-    Py_END_ALLOW_THREADS
-    Py_DECREF(pyfunc);
-
-    if (ret == NULL) {
-        m2_PyErr_Msg(_dsa_err);
-    }
-
-    return ret;
-}
-%}
-%typemap(out) DSA * ;
-
-%inline %{
 PyObject *dsa_get_p(DSA *dsa) {
     const BIGNUM* p = NULL;
     DSA_get0_pqg(dsa, &p, NULL, NULL);
@@ -208,7 +146,7 @@ PyObject *dsa_set_pqg(DSA *dsa, PyObject *pval, PyObject* qval, PyObject* gval)
 PyObject *dsa_set_pub(DSA *dsa, PyObject *value) {
     BIGNUM *bn;
     const void *vbuf;
-    int vlen = 0;
+    int vlen;
 
     if (m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         return NULL;
@@ -225,6 +163,19 @@ PyObject *dsa_set_pub(DSA *dsa, PyObject *value) {
 }
 %}
 
+%inline %{
+DSA *dsa_read_params(BIO *f, PyObject *pyfunc) {
+    DSA *ret;
+
+    Py_INCREF(pyfunc);
+    Py_BEGIN_ALLOW_THREADS
+    ret = PEM_read_bio_DSAparams(f, NULL, passphrase_callback, (void *)pyfunc);
+    Py_END_ALLOW_THREADS
+    Py_DECREF(pyfunc);
+    return ret;
+}
+%}
+
 %threadallow dsa_write_params_bio;
 %inline %{
 int dsa_write_params_bio(DSA* dsa, BIO* f) {
@@ -268,9 +219,33 @@ int dsa_write_pub_key_bio(DSA* dsa, BIO* f) {
 %}
 
 %inline %{
+DSA *dsa_read_key(BIO *f, PyObject *pyfunc) {
+    DSA *ret;
+
+    Py_INCREF(pyfunc);
+    Py_BEGIN_ALLOW_THREADS
+    ret = PEM_read_bio_DSAPrivateKey(f, NULL, passphrase_callback, (void *)pyfunc);
+    Py_END_ALLOW_THREADS
+    Py_DECREF(pyfunc);
+    return ret;
+}
+%}
+
+%inline %{
+DSA *dsa_read_pub_key(BIO *f, PyObject *pyfunc) {
+    DSA *ret;
+
+    Py_INCREF(pyfunc);
+    Py_BEGIN_ALLOW_THREADS
+    ret = PEM_read_bio_DSA_PUBKEY(f, NULL, passphrase_callback, (void *)pyfunc);
+    Py_END_ALLOW_THREADS
+    Py_DECREF(pyfunc);
+    return ret;
+}
+
 PyObject *dsa_sign(DSA *dsa, PyObject *value) {
     const void *vbuf;
-    int vlen = 0;
+    int vlen;
     PyObject *tuple;
     DSA_SIG *sig;
 
@@ -294,7 +269,7 @@ PyObject *dsa_sign(DSA *dsa, PyObject *value) {
 
 int dsa_verify(DSA *dsa, PyObject *value, PyObject *r, PyObject *s) {
     const void *vbuf, *rbuf, *sbuf;
-    int vlen = 0, rlen = 0, slen = 0;
+    int vlen, rlen, slen;
     DSA_SIG *sig;
     BIGNUM* pr, *ps;
     int ret;
@@ -336,7 +311,7 @@ int dsa_verify(DSA *dsa, PyObject *value, PyObject *r, PyObject *s) {
 
 PyObject *dsa_sign_asn1(DSA *dsa, PyObject *value) {
     const void *vbuf;
-    int vlen = 0;
+    int vlen;
     void *sigbuf;
     unsigned int siglen;
     PyObject *ret;
@@ -354,7 +329,11 @@ PyObject *dsa_sign_asn1(DSA *dsa, PyObject *value) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(sigbuf, siglen);
+#else
+    ret = PyString_FromStringAndSize(sigbuf, siglen);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(sigbuf);
     return ret;
@@ -363,7 +342,7 @@ PyObject *dsa_sign_asn1(DSA *dsa, PyObject *value) {
 int dsa_verify_asn1(DSA *dsa, PyObject *value, PyObject *sig) {
     const void *vbuf;
     void *sbuf;
-    int vlen = 0, slen = 0, ret = 0;
+    int vlen, slen, ret;
 
     if ((m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         || (m2_PyObject_AsReadBufferInt(sig, (const void **)&sbuf, &slen)
diff --git a/SWIG/_ec.i b/SWIG/_ec.i
index f47d593..15af5b8 100644
--- a/SWIG/_ec.i
+++ b/SWIG/_ec.i
@@ -208,12 +208,16 @@ EC_KEY* ec_key_new_by_curve_name(int nid)
 }
 
 PyObject *ec_key_get_public_der(EC_KEY *key) {
-    char *src=NULL;
+
+    unsigned char *src=NULL;
+    void *dst=NULL;
     int src_len=0;
+    Py_ssize_t dst_len=0;
     PyObject *pyo=NULL;
+    int ret=0;
 
     /* Convert to binary */
-    src_len = i2d_EC_PUBKEY( key, (unsigned char**)&src );
+    src_len = i2d_EC_PUBKEY( key, &src );
     if (src_len < 0)
     {
         m2_PyErr_Msg(_ec_err);
@@ -222,7 +226,22 @@ PyObject *ec_key_get_public_der(EC_KEY *key) {
     /* Create a PyBuffer containing a copy of the binary,
      * to simplify memory deallocation
      */
+#if PY_MAJOR_VERSION >= 3
     pyo = PyBytes_FromStringAndSize( src, src_len );
+#else
+    pyo = PyBuffer_New( src_len );
+    ret = PyObject_AsWriteBuffer( pyo, &dst, &dst_len );
+    assert( src_len == dst_len );
+    if (ret < 0)
+    {
+        Py_DECREF(pyo);
+        OPENSSL_free(src);
+        PyErr_SetString(_ec_err, "cannot get write buffer");
+        return NULL;
+    }
+    memcpy( dst, src, src_len );
+
+#endif // PY_MAJOR_VERSION == 2
 
     OPENSSL_free(src);
 
@@ -230,19 +249,41 @@ PyObject *ec_key_get_public_der(EC_KEY *key) {
 }
 
 PyObject *ec_key_get_public_key(EC_KEY *key) {
-    char *src=NULL;
+
+    unsigned char *src=NULL;
+    void *dst=NULL;
     int src_len=0;
+    Py_ssize_t dst_len=0;
     PyObject *pyo=NULL;
+    int ret=0;
 
     /* Convert to binary */
-    src_len = i2o_ECPublicKey(key, (unsigned char**)&src);
+    src_len = i2o_ECPublicKey(key, &src);
     if (src_len < 0)
     {
         m2_PyErr_Msg(_ec_err);
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     pyo = PyBytes_FromStringAndSize( src, src_len );
+#else
+    /* Create a PyBuffer containing a copy of the binary,
+     * to simplify memory deallocation
+     */
+    pyo = PyBuffer_New( src_len );
+    ret = PyObject_AsWriteBuffer( pyo, &dst, &dst_len );
+    assert( src_len == dst_len );
+    if (ret < 0)
+    {
+        Py_DECREF(pyo);
+        OPENSSL_free(src);
+        PyErr_SetString(_ec_err, "cannot get write buffer");
+        return NULL;
+    }
+    memcpy( dst, src, src_len );
+
+#endif // PY_MAJOR_VERSION == 2
 
     OPENSSL_free(src);
 
@@ -320,7 +361,7 @@ PyObject *ecdsa_sig_get_s(ECDSA_SIG *ecdsa_sig) {
 
 PyObject *ecdsa_sign(EC_KEY *key, PyObject *value) {
     const void *vbuf;
-    int vlen = 0;
+    int vlen;
     PyObject *tuple;
     ECDSA_SIG *sig;
 
@@ -344,7 +385,7 @@ PyObject *ecdsa_sign(EC_KEY *key, PyObject *value) {
 
 int ecdsa_verify(EC_KEY *key, PyObject *value, PyObject *r, PyObject *s) {
     const void *vbuf, *rbuf, *sbuf;
-    int vlen = 0, rlen = 0, slen = 0;
+    int vlen, rlen, slen;
     ECDSA_SIG *sig;
     int ret;
     BIGNUM* pr, *ps;
@@ -387,7 +428,7 @@ int ecdsa_verify(EC_KEY *key, PyObject *value, PyObject *r, PyObject *s) {
 
 PyObject *ecdsa_sign_asn1(EC_KEY *key, PyObject *value) {
     const void *vbuf;
-    int vlen = 0;
+    int vlen;
     void *sigbuf;
     unsigned int siglen;
     PyObject *ret;
@@ -404,7 +445,11 @@ PyObject *ecdsa_sign_asn1(EC_KEY *key, PyObject *value) {
         PyMem_Free(sigbuf);
         return NULL;
     }
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(sigbuf, siglen);
+#else
+    ret = PyString_FromStringAndSize(sigbuf, siglen);
+#endif // PY_MAJOR_VERSION == 2
 
     PyMem_Free(sigbuf);
     return ret;
@@ -414,7 +459,7 @@ PyObject *ecdsa_sign_asn1(EC_KEY *key, PyObject *value) {
 int ecdsa_verify_asn1(EC_KEY *key, PyObject *value, PyObject *sig) {
     const void *vbuf;
     void *sbuf;
-    int vlen = 0, slen = 0, ret;
+    int vlen, slen, ret;
 
     if ((m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         || (m2_PyObject_AsReadBufferInt(sig, (const void **)&sbuf, &slen)
@@ -452,7 +497,11 @@ PyObject *ecdh_compute_key(EC_KEY *keypairA, EC_KEY *pubkeyB) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((const char *)sharedkey, sharedkeylen);
+#else
+    ret = PyString_FromStringAndSize((const char *)sharedkey, sharedkeylen);
+#endif // PY_MAJOR_VERSION == 2
 
     PyMem_Free(sharedkey);
 
diff --git a/SWIG/_evp.i b/SWIG/_evp.i
index d04e806..786d474 100644
--- a/SWIG/_evp.i
+++ b/SWIG/_evp.i
@@ -19,7 +19,7 @@ Copyright (c) 2009-2010 Heikki Toivonen. All rights reserved.
 #include <openssl/rsa.h>
 #include <openssl/opensslv.h>
 
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#if OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER)
 
 HMAC_CTX *HMAC_CTX_new(void) {
     HMAC_CTX *ret = PyMem_Malloc(sizeof(HMAC_CTX));
@@ -73,6 +73,9 @@ extern const EVP_MD *EVP_sha512(void);
 %rename(digest_init) EVP_DigestInit;
 extern int EVP_DigestInit(EVP_MD_CTX *, const EVP_MD *);
 
+%rename(get_digestbyname) EVP_get_digestbyname;
+extern EVP_MD *EVP_get_digestbyname(const char * name);
+
 %rename(des_ecb) EVP_des_ecb;
 extern const EVP_CIPHER *EVP_des_ecb(void);
 %rename(des_ede_ecb) EVP_des_ede;
@@ -170,6 +173,9 @@ extern int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *, int);
 
 %rename(cipher_set_padding) EVP_CIPHER_CTX_set_padding;
 extern int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);
+%rename(pkey_new) EVP_PKEY_new;
+
+extern EVP_PKEY *EVP_PKEY_new(void);
 %rename(pkey_free) EVP_PKEY_free;
 extern void EVP_PKEY_free(EVP_PKEY *);
 %rename(pkey_assign) EVP_PKEY_assign;
@@ -180,6 +186,8 @@ extern int EVP_PKEY_assign_EC_KEY(EVP_PKEY *, EC_KEY *);
 #endif
 %rename(pkey_set1_rsa) EVP_PKEY_set1_RSA;
 extern int EVP_PKEY_set1_RSA(EVP_PKEY *, RSA *);
+%rename(pkey_get1_rsa) EVP_PKEY_get1_RSA;
+extern RSA* EVP_PKEY_get1_RSA(EVP_PKEY *);
 %rename(sign_init) EVP_SignInit;
 extern int EVP_SignInit(EVP_MD_CTX *, const EVP_MD *);
 %rename(verify_init) EVP_VerifyInit;
@@ -197,34 +205,7 @@ void evp_init(PyObject *evp_err) {
     Py_INCREF(evp_err);
     _evp_err = evp_err;
 }
-%}
-
-%typemap(out) RSA * {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-
-    if ($1 != NULL)
-        $result = SWIG_NewPointerObj($1, $1_descriptor, 0);
-    else {
-        $result = NULL;
-    }
-}
-%inline %{
-RSA *pkey_get1_rsa(EVP_PKEY *pkey) {
-    RSA *ret = NULL;
-
-    if ((ret = EVP_PKEY_get1_RSA(pkey)) == NULL) {
-        /* _evp_err now inherits from PyExc_ValueError, so we should
-         * keep API intact.
-         */
-        PyErr_Format(_evp_err, "Invalid key in function %s.", __FUNCTION__);
-    }
 
-    return ret;
-}
-%}
-%typemap(out) RSA * ;
-
-%inline %{
 PyObject *pkcs5_pbkdf2_hmac_sha1(PyObject *pass,
                                  PyObject *salt,
                                  int iter,
@@ -233,7 +214,7 @@ PyObject *pkcs5_pbkdf2_hmac_sha1(PyObject *pass,
     unsigned char *saltbuf;
     char *passbuf;
     PyObject *ret;
-    int passlen = 0, saltlen = 0;
+    int passlen, saltlen;
 
     if (m2_PyObject_AsReadBufferInt(pass, (const void **)&passbuf,
                                     &passlen) == -1)
@@ -247,7 +228,11 @@ PyObject *pkcs5_pbkdf2_hmac_sha1(PyObject *pass,
 	return PyErr_NoMemory();
     PKCS5_PBKDF2_HMAC_SHA1(passbuf, passlen, saltbuf, saltlen, iter,
                            keylen, key);
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((char*)key, keylen);
+#else
+    ret = PyString_FromStringAndSize((char*)key, keylen);
+#endif
     OPENSSL_cleanse(key, keylen);
     PyMem_Free(key);
     return ret;
@@ -292,7 +277,11 @@ PyObject *digest_final(EVP_MD_CTX *ctx) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(blob, blen);
+#else
+    ret = PyString_FromStringAndSize(blob, blen);
+#endif
 
     PyMem_Free(blob);
     return ret;
@@ -314,7 +303,7 @@ void hmac_ctx_free(HMAC_CTX *ctx) {
 
 PyObject *hmac_init(HMAC_CTX *ctx, PyObject *key, const EVP_MD *md) {
     const void *kbuf;
-    int klen = 0;
+    int klen;
 
     if (m2_PyObject_AsReadBufferInt(key, &kbuf, &klen) == -1)
         return NULL;
@@ -355,7 +344,11 @@ PyObject *hmac_final(HMAC_CTX *ctx) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(blob, blen);
+#else
+    ret = PyString_FromStringAndSize(blob, blen);
+#endif
 
     PyMem_Free(blob);
     return ret;
@@ -364,7 +357,7 @@ PyObject *hmac_final(HMAC_CTX *ctx) {
 PyObject *hmac(PyObject *key, PyObject *data, const EVP_MD *md) {
     const void *kbuf, *dbuf;
     void *blob;
-    int klen = 0;
+    int klen;
     unsigned int blen;
     Py_ssize_t dlen;
     PyObject *ret;
@@ -380,7 +373,11 @@ PyObject *hmac(PyObject *key, PyObject *data, const EVP_MD *md) {
     HMAC(md, kbuf, klen, dbuf, dlen, blob, &blen);
     blob = PyMem_Realloc(blob, blen);
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(blob, blen);
+#else
+    ret = PyString_FromStringAndSize(blob, blen);
+#endif
 
     PyMem_Free(blob);
     return ret;
@@ -407,7 +404,7 @@ PyObject *bytes_to_key(const EVP_CIPHER *cipher, EVP_MD *md,
                         int iter) {
     unsigned char key[EVP_MAX_KEY_LENGTH];
     const void *dbuf, *sbuf;
-    int dlen = 0, klen;
+    int dlen, klen;
     Py_ssize_t slen;
     PyObject *ret;
 
@@ -420,7 +417,11 @@ PyObject *bytes_to_key(const EVP_CIPHER *cipher, EVP_MD *md,
         (unsigned char *)dbuf, dlen, iter,
         key, NULL); /* Since we are not returning IV no need to derive it */
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((char*)key, klen);
+#else
+    ret = PyString_FromStringAndSize((char*)key, klen);
+#endif
 
     return ret;
 }
@@ -444,7 +445,7 @@ PyObject *cipher_init(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
 
 PyObject *cipher_update(EVP_CIPHER_CTX *ctx, PyObject *blob) {
     const void *buf;
-    int len = 0, olen;
+    int len, olen;
     void *obuf;
     PyObject *ret;
 
@@ -461,7 +462,11 @@ PyObject *cipher_update(EVP_CIPHER_CTX *ctx, PyObject *blob) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(obuf, olen);
+#else
+    ret = PyString_FromStringAndSize(obuf, olen);
+#endif
 
     PyMem_Free(obuf);
     return ret;
@@ -482,7 +487,11 @@ PyObject *cipher_final(EVP_CIPHER_CTX *ctx) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(obuf, olen);
+#else
+    ret = PyString_FromStringAndSize(obuf, olen);
+#endif
 
     PyMem_Free(obuf);
     return ret;
@@ -520,7 +529,11 @@ PyObject *sign_final(EVP_MD_CTX *ctx, EVP_PKEY *pkey) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((char*)sigbuf, siglen);
+#else
+    ret = PyString_FromStringAndSize((char*)sigbuf, siglen);
+#endif
 
     OPENSSL_cleanse(sigbuf, siglen);
     OPENSSL_free(sigbuf);
@@ -540,7 +553,7 @@ int verify_update(EVP_MD_CTX *ctx, PyObject *blob) {
 
 int verify_final(EVP_MD_CTX *ctx, PyObject *blob, EVP_PKEY *pkey) {
     unsigned char *kbuf;
-    int len = 0;
+    int len;
 
     if (m2_PyObject_AsReadBufferInt(blob, (const void **)&kbuf, &len) == -1)
         return -1;
@@ -549,28 +562,6 @@ int verify_final(EVP_MD_CTX *ctx, PyObject *blob, EVP_PKEY *pkey) {
 }
 %}
 
-%typemap(out) EVP_MD * {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-
-    if ($1 != NULL)
-        $result = SWIG_NewPointerObj($1, $1_descriptor, 0);
-    else {
-        $result = NULL;
-    }
-}
-%inline %{
-const EVP_MD *get_digestbyname(const char* name) {
-    const EVP_MD *ret = NULL;
-
-    if ((ret = EVP_get_digestbyname(name)) == NULL) {
-        m2_PyErr_Msg(_evp_err);
-    }
-
-    return ret;
-}
-%}
-%typemap(out) EVP_MD *;
-
 %inline %{
 int pkey_write_pem_no_cipher(EVP_PKEY *pkey, BIO *f, PyObject *pyfunc) {
     int ret;
@@ -599,27 +590,7 @@ int pkey_write_pem(EVP_PKEY *pkey, BIO *f, EVP_CIPHER *cipher, PyObject *pyfunc)
 }
 %}
 
-%typemap(out) EVP_PKEY * {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-
-    if ($1 != NULL)
-        $result = SWIG_NewPointerObj($1, $1_descriptor, 0);
-    else {
-        $result = NULL;
-    }
-}
 %inline %{
-EVP_PKEY *pkey_new(void) {
-    EVP_PKEY *ret;
-
-    if ((ret = EVP_PKEY_new()) == NULL) {
-        PyErr_Format(PyExc_MemoryError,
-                     "Insufficient memory for new key in function %s.", __FUNCTION__);
-    }
-
-    return ret;
-}
-
 EVP_PKEY *pkey_read_pem(BIO *f, PyObject *pyfunc) {
     EVP_PKEY *pk;
 
@@ -628,12 +599,6 @@ EVP_PKEY *pkey_read_pem(BIO *f, PyObject *pyfunc) {
     pk = PEM_read_bio_PrivateKey(f, NULL, passphrase_callback, (void *)pyfunc);
     Py_END_ALLOW_THREADS
     Py_DECREF(pyfunc);
-
-    if (pk == NULL) {
-        PyErr_Format(_evp_err,
-                     "Unable to read private key in function %s.", __FUNCTION__);
-    }
-
     return pk;
 }
 
@@ -645,18 +610,9 @@ EVP_PKEY *pkey_read_pem_pubkey(BIO *f, PyObject *pyfunc) {
     pk = PEM_read_bio_PUBKEY(f, NULL, passphrase_callback, (void *)pyfunc);
     Py_END_ALLOW_THREADS
     Py_DECREF(pyfunc);
-
-    if (pk == NULL) {
-        PyErr_Format(_evp_err,
-                     "Unable to read public key in function %s.", __FUNCTION__);
-    }
-
     return pk;
 }
-%}
-%typemap(out) EVP_PKEY * ;
 
-%inline %{
 int pkey_assign_rsa(EVP_PKEY *pkey, RSA *rsa) {
     return EVP_PKEY_assign_RSA(pkey, rsa);
 }
@@ -667,11 +623,15 @@ PyObject *pkey_as_der(EVP_PKEY *pkey) {
     PyObject * der;
     len = i2d_PUBKEY(pkey, &pp);
     if (len < 0){
-        PyErr_SetString(_evp_err, "EVP_PKEY as DER failed");
+        PyErr_SetString(PyExc_ValueError, "EVP_PKEY as DER failed");
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     der = PyBytes_FromStringAndSize((char*)pp, len);
+#else
+    der = PyString_FromStringAndSize((char*)pp, len);
+#endif
 
     OPENSSL_free(pp);
     return der;
@@ -706,7 +666,11 @@ PyObject *pkey_get_modulus(EVP_PKEY *pkey)
             }
             BIO_get_mem_ptr(bio, &bptr);
 
+#if PY_MAJOR_VERSION >= 3
             ret = PyBytes_FromStringAndSize(bptr->data, bptr->length);
+#else
+            ret = PyString_FromStringAndSize(bptr->data, bptr->length);
+#endif
 
             (void)BIO_set_close(bio, BIO_CLOSE);
             BIO_free(bio);
@@ -734,7 +698,11 @@ PyObject *pkey_get_modulus(EVP_PKEY *pkey)
             }
             BIO_get_mem_ptr(bio, &bptr);
 
+#if PY_MAJOR_VERSION >= 3
             ret = PyBytes_FromStringAndSize(bptr->data, bptr->length);
+#else
+            ret = PyString_FromStringAndSize(bptr->data, bptr->length);
+#endif
 
             (void)BIO_set_close(bio, BIO_CLOSE);
             BIO_free(bio);
@@ -744,7 +712,7 @@ PyObject *pkey_get_modulus(EVP_PKEY *pkey)
             break;
 
         default:
-            PyErr_SetString(_evp_err, "unsupported key type");
+            PyErr_SetString(PyExc_ValueError, "unsupported key type");
             return NULL;
     }
 }
diff --git a/SWIG/_lib.i b/SWIG/_lib.i
index 31e9512..257a2ac 100644
--- a/SWIG/_lib.i
+++ b/SWIG/_lib.i
@@ -16,12 +16,9 @@
 /* OpenSSL 1.1 compatibility shim */
 %include _lib11_compat.i
 
-/* Python 3 compatibility shim */
-%include _py3k_compat.i
-
 %{
-/* OpenSSL 1.0.2 copmatbility shim */
-#if OPENSSL_VERSION_NUMBER < 0x10002000L
+/* OpenSSL 1.0.2 compatibility shim */
+#if OPENSSL_VERSION_NUMBER < 0x10002000L || defined(LIBRESSL_VERSION_NUMBER)
 typedef void (*OPENSSL_sk_freefunc)(void *);
 typedef void *(*OPENSSL_sk_copyfunc)(const void *);
 typedef struct stack_st OPENSSL_STACK;
@@ -73,7 +70,7 @@ OPENSSL_STACK *OPENSSL_sk_deep_copy(const OPENSSL_STACK *sk,
     }
     return ret;
 }
-#endif /* OpenSSL 1.0.2 copmatbility shim */
+#endif /* OpenSSL 1.0.2 compatibility shim */
 
 
 /* Blob interface. Deprecated. */
@@ -145,20 +142,20 @@ static int m2_PyObject_GetBufferInt(PyObject *obj, Py_buffer *view, int flags)
     int ret;
 
     if (PyObject_CheckBuffer(obj))
-        ret = PyObject_GetBuffer(obj, view, flags);
+	ret = PyObject_GetBuffer(obj, view, flags);
     else {
-        const void *buf;
+	const void *buf;
 
-        ret = PyObject_AsReadBuffer(obj, &buf, &view->len);
-        if (ret == 0)
-            view->buf = (void *)buf;
+	ret = PyObject_AsReadBuffer(obj, &buf, &view->len);
+	if (ret == 0)
+	    view->buf = (void *)buf;
     }
     if (ret)
-        return ret;
+	return ret;
     if (view->len > INT_MAX) {
-        PyErr_SetString(PyExc_ValueError, "object too large");
-        m2_PyBuffer_Release(obj, view);
-        return -1;
+	PyErr_SetString(PyExc_ValueError, "object too large");
+	m2_PyBuffer_Release(obj, view);
+	return -1;
     }
 
     return 0;
@@ -169,7 +166,7 @@ m2_PyObject_AsBIGNUM(PyObject* value, PyObject* _py_exc)
 {
     BIGNUM* bn;
     const void* vbuf;
-    int vlen = 0;
+    int vlen;
 
     if (m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         return NULL;
@@ -185,7 +182,7 @@ m2_PyObject_AsBIGNUM(PyObject* value, PyObject* _py_exc)
 static void m2_PyBuffer_Release(PyObject *obj, Py_buffer *view)
 {
     if (PyObject_CheckBuffer(obj))
-        PyBuffer_Release(view);
+	PyBuffer_Release(view);
     /* else do nothing, view->buf comes from PyObject_AsReadBuffer */
 }
 
@@ -195,7 +192,11 @@ m2_PyString_AsStringAndSizeInt(PyObject *obj, char **s, int *len)
     int ret;
     Py_ssize_t len2;
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_AsStringAndSize(obj, s, &len2);
+#else
+    ret = PyString_AsStringAndSize(obj, s, &len2);
+#endif // PY_MAJOR_VERSION >= 3
 
     if (ret)
        return ret;
@@ -207,21 +208,7 @@ m2_PyString_AsStringAndSizeInt(PyObject *obj, char **s, int *len)
     return 0;
 }
 
-/* Works as PyFile_Name, but always returns a new object. */
-PyObject *m2_PyFile_Name(PyObject *pyfile) {
-    PyObject *out = NULL;
-#if PY_MAJOR_VERSION >= 3
-   out = PyObject_GetAttrString(pyfile, "name");
-#else
-   out = PyFile_Name(pyfile);
-   Py_XINCREF(out);
-#endif
-    return out;
-}
-
-/* Yes, __FUNCTION__ is a non-standard symbol, but it is supported by
- * both gcc and MSVC. */
-#define m2_PyErr_Msg(type) m2_PyErr_Msg_Caller(type, (const char*) __FUNCTION__)
+#define m2_PyErr_Msg(type) m2_PyErr_Msg_Caller(type, __func__)
 
 static void m2_PyErr_Msg_Caller(PyObject *err_type, const char* caller) {
     const char *err_msg;
@@ -275,15 +262,17 @@ int ssl_verify_callback(int ok, X509_STORE_CTX *ctx) {
     }
 
     if (new_style_callback) {
-        PyObject *x509mod;
-        
-        x509mod = PyDict_GetItemString(PyImport_GetModuleDict(), "M2Crypto.X509");
+        PyObject *x509mod = PyDict_GetItemString(PyImport_GetModuleDict(), "M2Crypto.X509");
         _klass = PyObject_GetAttrString(x509mod, "X509_Store_Context");
 
         _x509_store_ctx_swigptr = SWIG_NewPointerObj((void *)ctx, SWIGTYPE_p_X509_STORE_CTX, 0);
         _x509_store_ctx_obj = Py_BuildValue("(Oi)", _x509_store_ctx_swigptr, 0);
 
-        _x509_store_ctx_inst = PyObject_CallObject(_klass, _x509_store_ctx_obj);
+#if PY_MAJOR_VERSION >= 3
+        _x509_store_ctx_inst = PyType_GenericNew(_klass, _x509_store_ctx_obj, NULL);
+#else
+        _x509_store_ctx_inst = PyInstance_New(_klass, _x509_store_ctx_obj, NULL);
+#endif // PY_MAJOR_VERSION >= 3
 
         argv = Py_BuildValue("(iO)", ok, _x509_store_ctx_inst);
     } else {
@@ -315,8 +304,7 @@ int ssl_verify_callback(int ok, X509_STORE_CTX *ctx) {
          */
         cret = 0;
     } else {
-        /* FIXME This is possibly problematic if ret > MAXINT */
-        cret = (int)PyLong_AsLong(ret);
+        cret = (int)PyInt_AsLong(ret);
     }
     Py_XDECREF(ret);
     Py_XDECREF(argv);
@@ -341,19 +329,22 @@ int x509_store_verify_callback(int ok, X509_STORE_CTX *ctx) {
     PyObject *_x509_store_ctx_swigptr=0, *_x509_store_ctx_obj=0, *_x509_store_ctx_inst=0, *_klass=0;
     int cret;
     PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    PyObject *x509mod;
 
 
     gilstate = PyGILState_Ensure();
 
     /* Below, handle only what is called 'new style callback' in ssl_verify_callback().
        TODO: does 'old style callback' exist any more? */
-    x509mod = PyDict_GetItemString(PyImport_GetModuleDict(), "M2Crypto.X509");
+    PyObject *x509mod = PyDict_GetItemString(PyImport_GetModuleDict(), "M2Crypto.X509");
     _klass = PyObject_GetAttrString(x509mod, "X509_Store_Context");
     _x509_store_ctx_swigptr = SWIG_NewPointerObj((void *)ctx, SWIGTYPE_p_X509_STORE_CTX, 0);
     _x509_store_ctx_obj = Py_BuildValue("(Oi)", _x509_store_ctx_swigptr, 0);
 
-    _x509_store_ctx_inst = PyObject_CallObject(_klass, _x509_store_ctx_obj);
+#if PY_MAJOR_VERSION >= 3
+        _x509_store_ctx_inst = PyType_GenericNew(_klass, _x509_store_ctx_obj, NULL);
+#else
+        _x509_store_ctx_inst = PyInstance_New(_klass, _x509_store_ctx_obj, NULL);
+#endif // PY_MAJOR_VERSION >= 3
 
     argv = Py_BuildValue("(iO)", ok, _x509_store_ctx_inst);
 
@@ -477,6 +468,7 @@ int passphrase_callback(char *buf, int num, int v, void *arg) {
         return -1;
     }
 
+#if PY_MAJOR_VERSION >= 3
     if (!PyBytes_Check(ret)) {
         PyErr_SetString(PyExc_RuntimeError,
                         "Result of callback is not bytes().");
@@ -487,6 +479,16 @@ int passphrase_callback(char *buf, int num, int v, void *arg) {
     if ((len = PyBytes_Size(ret)) > num)
         len = num;
     str = PyBytes_AsString(ret);
+#else
+    if (!PyString_Check(ret)) {
+        Py_DECREF(ret);
+        PyGILState_Release(gilstate);
+        return -1;
+    }
+    if ((len = PyString_Size(ret)) > num)
+        len = num;
+    str = PyString_AsString(ret);
+#endif // PY_MAJOR_VERSION >= 3
 
     for (i = 0; i < len; i++)
         buf[i] = str[i];
@@ -499,7 +501,7 @@ int passphrase_callback(char *buf, int num, int v, void *arg) {
 %inline %{
 
 void lib_init() {
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#if OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER)
     SSLeay_add_all_algorithms();
     ERR_load_ERR_strings();
 #endif
@@ -509,7 +511,7 @@ void lib_init() {
 warrant a separate file. */
 
 PyObject *bn_to_mpi(const BIGNUM *bn) {
-    int len = 0;
+    int len;
     unsigned char *mpi;
     PyObject *pyo;
 
@@ -520,7 +522,11 @@ PyObject *bn_to_mpi(const BIGNUM *bn) {
     }
     len=BN_bn2mpi(bn, mpi);
 
+#if PY_MAJOR_VERSION >= 3
     pyo=PyBytes_FromStringAndSize((const char *)mpi, len);
+#else
+    pyo=PyString_FromStringAndSize((const char *)mpi, len);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(mpi);
     return pyo;
@@ -528,7 +534,7 @@ PyObject *bn_to_mpi(const BIGNUM *bn) {
 
 const BIGNUM *mpi_to_bn(PyObject *value) {
     const void *vbuf;
-    int vlen = 0;
+    int vlen;
 
     if (m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         return NULL;
@@ -537,7 +543,7 @@ const BIGNUM *mpi_to_bn(PyObject *value) {
 }
 
 PyObject *bn_to_bin(BIGNUM *bn) {
-    int len = 0;
+    int len;
     unsigned char *bin;
     PyObject *pyo;
 
@@ -548,7 +554,11 @@ PyObject *bn_to_bin(BIGNUM *bn) {
     }
     BN_bn2bin(bn, bin);
 
+#if PY_MAJOR_VERSION >= 3
     pyo=PyBytes_FromStringAndSize((const char *)bin, len);
+#else
+    pyo=PyString_FromStringAndSize((const char *)bin, len);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(bin);
     return pyo;
@@ -556,7 +566,7 @@ PyObject *bn_to_bin(BIGNUM *bn) {
 
 const BIGNUM *bin_to_bn(PyObject *value) {
     const void *vbuf;
-    int vlen = 0;
+    int vlen;
 
     if (m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         return NULL;
@@ -567,7 +577,7 @@ const BIGNUM *bin_to_bn(PyObject *value) {
 PyObject *bn_to_hex(BIGNUM *bn) {
     char *hex;
     PyObject *pyo;
-    Py_ssize_t len = 0;
+    Py_ssize_t len;
 
     hex = BN_bn2hex(bn);
     if (!hex) {
@@ -577,7 +587,11 @@ PyObject *bn_to_hex(BIGNUM *bn) {
     }
     len = strlen(hex);
 
+#if PY_MAJOR_VERSION >= 3
     pyo=PyBytes_FromStringAndSize(hex, len);
+#else
+    pyo=PyString_FromStringAndSize(hex, len);
+#endif // PY_MAJOR_VERSION >= 3
 
     OPENSSL_free(hex);
     return pyo;
@@ -585,7 +599,7 @@ PyObject *bn_to_hex(BIGNUM *bn) {
 
 BIGNUM *hex_to_bn(PyObject *value) {
     const void *vbuf;
-    Py_ssize_t vlen = 0;
+    Py_ssize_t vlen;
     BIGNUM *bn;
 
     if (PyObject_AsReadBuffer(value, &vbuf, &vlen) == -1)
@@ -605,7 +619,7 @@ BIGNUM *hex_to_bn(PyObject *value) {
 
 BIGNUM *dec_to_bn(PyObject *value) {
     const void *vbuf;
-    Py_ssize_t vlen = 0;
+    Py_ssize_t vlen;
     BIGNUM *bn;
 
     if (PyObject_AsReadBuffer(value, &vbuf, &vlen) == -1)
@@ -628,13 +642,21 @@ BIGNUM *dec_to_bn(PyObject *value) {
 /* Various useful typemaps. */
 
 %typemap(in) Blob * {
-    Py_ssize_t len = 0;
+    Py_ssize_t len;
 
+#if PY_MAJOR_VERSION >= 3
     if (!PyBytes_Check($input)) {
         PyErr_SetString(PyExc_TypeError, "expected PyString");
         return NULL;
     }
     len=PyBytes_Size($input);
+#else
+    if (!PyString_Check($input)) {
+        PyErr_SetString(PyExc_TypeError, "expected PyString");
+        return NULL;
+    }
+    len=PyString_Size($input);
+#endif // PY_MAJOR_VERSION >= 3
 
     if (len > INT_MAX) {
         PyErr_SetString(PyExc_ValueError, "object too large");
@@ -646,7 +668,11 @@ BIGNUM *dec_to_bn(PyObject *value) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     $1->data=(unsigned char *)PyBytes_AsString($input);
+#else
+    $1->data=(unsigned char *)PyString_AsString($input);
+#endif // PY_MAJOR_VERSION >= 3
 
     $1->len=len;
 }
@@ -657,13 +683,35 @@ BIGNUM *dec_to_bn(PyObject *value) {
         $result=Py_None;
     } else {
 
+#if PY_MAJOR_VERSION >= 3
         $result=PyBytes_FromStringAndSize((const char *)$1->data, $1->len);
+#else
+        $result=PyString_FromStringAndSize((const char *)$1->data, $1->len);
+#endif // PY_MAJOR_VERSION >= 3
 
         PyMem_Free($1->data);
         PyMem_Free($1);
     }
 }
 
+/*
+PyFile* is not part of Python3 ... if we’ll ever need it, we have to
+replace it completely.
+http://stackoverflow.com/questions/8195383/pyfile-type-replaced-by
+
+%typemap(in) FILE * {
+#if PY_MAJOR_VERSION >= 3
+    $1=PyObject_AsFileDescriptor($input);
+#else
+    if (!PyFile_Check($input)) {
+        PyErr_SetString(PyExc_TypeError, "expected PyFile");
+        return NULL;
+    }
+    $1=PyFile_AsFile($input);
+#endif // PY_MAJOR_VERSION >= 3
+}
+*/
+
 %typemap(in) PyObject *pyfunc {
     if (!PyCallable_Check($input)) {
         PyErr_SetString(PyExc_TypeError, "expected PyCallable");
@@ -673,7 +721,11 @@ BIGNUM *dec_to_bn(PyObject *value) {
 }
 
 %typemap(in) PyObject *pyblob {
+#if PY_MAJOR_VERSION >= 3
     if (!PyBytes_Check($input)) {
+#else
+    if (!PyString_Check($input)) {
+#endif // PY_MAJOR_VERSION >= 3
 
         PyErr_SetString(PyExc_TypeError, "expected PyString");
         return NULL;
@@ -690,7 +742,7 @@ BIGNUM *dec_to_bn(PyObject *value) {
 }
 
 %typemap(out) int {
-    $result=PyLong_FromLong($1);
+    $result=PyInt_FromLong($1);
     if (PyErr_Occurred()) SWIG_fail;
 }
 
diff --git a/SWIG/_lib11_compat.i b/SWIG/_lib11_compat.i
index 1ec42dd..9053dfb 100644
--- a/SWIG/_lib11_compat.i
+++ b/SWIG/_lib11_compat.i
@@ -8,7 +8,7 @@
  */
 
 %{
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#if OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER)
 
 #include <string.h>
 #include <openssl/engine.h>
diff --git a/SWIG/_m2crypto.i b/SWIG/_m2crypto.i
index 239249f..73f07b8 100644
--- a/SWIG/_m2crypto.i
+++ b/SWIG/_m2crypto.i
@@ -21,17 +21,7 @@
 #endif
 
 %{
-#ifdef _WIN32
-#define _WINSOCKAPI_
-#include <WinSock2.h>
-#include <Windows.h>
-#pragma comment(lib, "Ws2_32")
-typedef unsigned __int64 uint64_t;
-#endif
-%}
-
-%{
-#if defined __GNUC__ && __GNUC__ < 5
+#if __GNUC__ < 5
 #pragma GCC diagnostic ignored "-Wunused-label"
 #pragma GCC diagnostic warning "-Wstrict-prototypes"
 #endif
@@ -40,7 +30,6 @@ typedef unsigned __int64 uint64_t;
 #include <openssl/rand.h>
 #include <_lib.h>
 #include <libcrypto-compat.h>
-#include <py3k_compat.h>
 
 #include "compile.h"
 
@@ -54,7 +43,7 @@ static PyObject *x509_store_verify_cb_func;
 %include <openssl/opensslv.h>
 
 /* Bring in STACK_OF macro definition */
-#ifdef _WIN32
+#ifdef _MSC_VER
 %include <windows.i>
 #endif
 %include <openssl/safestack.h>
diff --git a/SWIG/_m2crypto_wrap.c b/SWIG/_m2crypto_wrap.c
index a09fe09..856e2c1 100644
--- a/SWIG/_m2crypto_wrap.c
+++ b/SWIG/_m2crypto_wrap.c
@@ -8,6 +8,13 @@
  * interface file instead. 
  * ----------------------------------------------------------------------------- */
 
+#ifdef _MSC_VER
+#include <Winsock2.h>
+#pragma comment(lib, "Ws2_32")
+typedef unsigned __int64 uint64_t;
+#endif
+
+
 #define SWIGPYTHON
 #define SWIG_PYTHON_THREADS
 #define SWIG_PYTHON_DIRECTOR_NO_VTABLE
@@ -3492,17 +3499,16 @@ SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
 #define SWIGTYPE_p_p_X509_NAME_ENTRY swig_types[48]
 #define SWIGTYPE_p_p_char swig_types[49]
 #define SWIGTYPE_p_p_unsigned_char swig_types[50]
-#define SWIGTYPE_p_pyfd_struct swig_types[51]
-#define SWIGTYPE_p_stack_st swig_types[52]
-#define SWIGTYPE_p_stack_st_OPENSSL_BLOCK swig_types[53]
-#define SWIGTYPE_p_stack_st_OPENSSL_STRING swig_types[54]
-#define SWIGTYPE_p_stack_st_SSL_CIPHER swig_types[55]
-#define SWIGTYPE_p_stack_st_X509 swig_types[56]
-#define SWIGTYPE_p_stack_st_X509_EXTENSION swig_types[57]
-#define SWIGTYPE_p_unsigned_char swig_types[58]
-#define SWIGTYPE_p_void swig_types[59]
-static swig_type_info *swig_types[61];
-static swig_module_info swig_module = {swig_types, 60, 0, 0, 0, 0};
+#define SWIGTYPE_p_stack_st swig_types[51]
+#define SWIGTYPE_p_stack_st_OPENSSL_BLOCK swig_types[52]
+#define SWIGTYPE_p_stack_st_OPENSSL_STRING swig_types[53]
+#define SWIGTYPE_p_stack_st_SSL_CIPHER swig_types[54]
+#define SWIGTYPE_p_stack_st_X509 swig_types[55]
+#define SWIGTYPE_p_stack_st_X509_EXTENSION swig_types[56]
+#define SWIGTYPE_p_unsigned_char swig_types[57]
+#define SWIGTYPE_p_void swig_types[58]
+static swig_type_info *swig_types[60];
+static swig_module_info swig_module = {swig_types, 59, 0, 0, 0, 0};
 #define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
 #define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
 
@@ -3540,16 +3546,7 @@ static swig_module_info swig_module = {swig_types, 60, 0, 0, 0, 0};
 #define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 
 
 
-#ifdef _WIN32
-#define _WINSOCKAPI_
-#include <WinSock2.h>
-#include <Windows.h>
-#pragma comment(lib, "Ws2_32")
-typedef unsigned __int64 uint64_t;
-#endif
-
-
-#if defined __GNUC__ && __GNUC__ < 5
+#if __GNUC__ < 5
 #pragma GCC diagnostic ignored "-Wunused-label"
 #pragma GCC diagnostic warning "-Wstrict-prototypes"
 #endif
@@ -3558,7 +3555,6 @@ typedef unsigned __int64 uint64_t;
 #include <openssl/rand.h>
 #include <_lib.h>
 #include <libcrypto-compat.h>
-#include <py3k_compat.h>
 
 #include "compile.h"
 
@@ -4287,47 +4283,6 @@ int X509_NAME_get0_der(X509_NAME *nm, const unsigned char **pder,
 #endif /* OPENSSL_VERSION_NUMBER */
 
 
-#if PY_MAJOR_VERSION >= 3
-
-FILE* PyFile_AsFile(PyObject *pyfile) {
-    FILE* fp;
-    int fd;
-    const char *mode_str = NULL;
-    PyObject *mode_obj;
-
-    if ((fd = PyObject_AsFileDescriptor(pyfile)) == -1) {
-        PyErr_SetString(PyExc_BlockingIOError,
-                        "Cannot find file handler for the Python file!");
-        return NULL;
-    }
-
-    if ((mode_obj = PyObject_GetAttrString(pyfile, "mode")) == NULL) {
-        mode_str = "rb";
-        PyErr_Clear();
-    }
-    else {
-        /* convert to plain string
-         * note that error checking is embedded in the function
-         */
-        mode_str = PyUnicode_AsUTF8AndSize(mode_obj, NULL);
-    }
-
-    if((fp = fdopen(fd, mode_str)) == NULL) {
-         PyErr_SetFromErrno(PyExc_IOError);
-    }
-
-    Py_XDECREF(mode_obj);
-    return fp;
-}
-
-#else /* PY2K */
-
-#define PyLong_FromLong(x) PyInt_FromLong(x)
-#define PyUnicode_AsUTF8(x) PyString_AsString(x)
-
-#endif /* PY_MAJOR_VERSION */
-
-
 /* OpenSSL 1.0.2 copmatbility shim */
 #if OPENSSL_VERSION_NUMBER < 0x10002000L
 typedef void (*OPENSSL_sk_freefunc)(void *);
@@ -4446,20 +4401,20 @@ static int m2_PyObject_GetBufferInt(PyObject *obj, Py_buffer *view, int flags)
     int ret;
 
     if (PyObject_CheckBuffer(obj))
-        ret = PyObject_GetBuffer(obj, view, flags);
+	ret = PyObject_GetBuffer(obj, view, flags);
     else {
-        const void *buf;
+	const void *buf;
 
-        ret = PyObject_AsReadBuffer(obj, &buf, &view->len);
-        if (ret == 0)
-            view->buf = (void *)buf;
+	ret = PyObject_AsReadBuffer(obj, &buf, &view->len);
+	if (ret == 0)
+	    view->buf = (void *)buf;
     }
     if (ret)
-        return ret;
+	return ret;
     if (view->len > INT_MAX) {
-        PyErr_SetString(PyExc_ValueError, "object too large");
-        m2_PyBuffer_Release(obj, view);
-        return -1;
+	PyErr_SetString(PyExc_ValueError, "object too large");
+	m2_PyBuffer_Release(obj, view);
+	return -1;
     }
 
     return 0;
@@ -4470,7 +4425,7 @@ m2_PyObject_AsBIGNUM(PyObject* value, PyObject* _py_exc)
 {
     BIGNUM* bn;
     const void* vbuf;
-    int vlen = 0;
+    int vlen;
 
     if (m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         return NULL;
@@ -4486,7 +4441,7 @@ m2_PyObject_AsBIGNUM(PyObject* value, PyObject* _py_exc)
 static void m2_PyBuffer_Release(PyObject *obj, Py_buffer *view)
 {
     if (PyObject_CheckBuffer(obj))
-        PyBuffer_Release(view);
+	PyBuffer_Release(view);
     /* else do nothing, view->buf comes from PyObject_AsReadBuffer */
 }
 
@@ -4496,7 +4451,11 @@ m2_PyString_AsStringAndSizeInt(PyObject *obj, char **s, int *len)
     int ret;
     Py_ssize_t len2;
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_AsStringAndSize(obj, s, &len2);
+#else
+    ret = PyString_AsStringAndSize(obj, s, &len2);
+#endif // PY_MAJOR_VERSION >= 3
 
     if (ret)
        return ret;
@@ -4508,21 +4467,7 @@ m2_PyString_AsStringAndSizeInt(PyObject *obj, char **s, int *len)
     return 0;
 }
 
-/* Works as PyFile_Name, but always returns a new object. */
-PyObject *m2_PyFile_Name(PyObject *pyfile) {
-    PyObject *out = NULL;
-#if PY_MAJOR_VERSION >= 3
-   out = PyObject_GetAttrString(pyfile, "name");
-#else
-   out = PyFile_Name(pyfile);
-   Py_XINCREF(out);
-#endif
-    return out;
-}
-
-/* Yes, __FUNCTION__ is a non-standard symbol, but it is supported by
- * both gcc and MSVC. */
-#define m2_PyErr_Msg(type) m2_PyErr_Msg_Caller(type, (const char*) __FUNCTION__)
+#define m2_PyErr_Msg(type) m2_PyErr_Msg_Caller(type, __func__)
 
 static void m2_PyErr_Msg_Caller(PyObject *err_type, const char* caller) {
     const char *err_msg;
@@ -4576,15 +4521,17 @@ int ssl_verify_callback(int ok, X509_STORE_CTX *ctx) {
     }
 
     if (new_style_callback) {
-        PyObject *x509mod;
-        
-        x509mod = PyDict_GetItemString(PyImport_GetModuleDict(), "M2Crypto.X509");
+        PyObject *x509mod = PyDict_GetItemString(PyImport_GetModuleDict(), "M2Crypto.X509");
         _klass = PyObject_GetAttrString(x509mod, "X509_Store_Context");
 
         _x509_store_ctx_swigptr = SWIG_NewPointerObj((void *)ctx, SWIGTYPE_p_X509_STORE_CTX, 0);
         _x509_store_ctx_obj = Py_BuildValue("(Oi)", _x509_store_ctx_swigptr, 0);
 
-        _x509_store_ctx_inst = PyObject_CallObject(_klass, _x509_store_ctx_obj);
+#if PY_MAJOR_VERSION >= 3
+        _x509_store_ctx_inst = PyType_GenericNew(_klass, _x509_store_ctx_obj, NULL);
+#else
+        _x509_store_ctx_inst = PyInstance_New(_klass, _x509_store_ctx_obj, NULL);
+#endif // PY_MAJOR_VERSION >= 3
 
         argv = Py_BuildValue("(iO)", ok, _x509_store_ctx_inst);
     } else {
@@ -4616,8 +4563,7 @@ int ssl_verify_callback(int ok, X509_STORE_CTX *ctx) {
          */
         cret = 0;
     } else {
-        /* FIXME This is possibly problematic if ret > MAXINT */
-        cret = (int)PyLong_AsLong(ret);
+        cret = (int)PyInt_AsLong(ret);
     }
     Py_XDECREF(ret);
     Py_XDECREF(argv);
@@ -4642,19 +4588,22 @@ int x509_store_verify_callback(int ok, X509_STORE_CTX *ctx) {
     PyObject *_x509_store_ctx_swigptr=0, *_x509_store_ctx_obj=0, *_x509_store_ctx_inst=0, *_klass=0;
     int cret;
     PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    PyObject *x509mod;
 
 
     gilstate = PyGILState_Ensure();
 
     /* Below, handle only what is called 'new style callback' in ssl_verify_callback().
        TODO: does 'old style callback' exist any more? */
-    x509mod = PyDict_GetItemString(PyImport_GetModuleDict(), "M2Crypto.X509");
+    PyObject *x509mod = PyDict_GetItemString(PyImport_GetModuleDict(), "M2Crypto.X509");
     _klass = PyObject_GetAttrString(x509mod, "X509_Store_Context");
     _x509_store_ctx_swigptr = SWIG_NewPointerObj((void *)ctx, SWIGTYPE_p_X509_STORE_CTX, 0);
     _x509_store_ctx_obj = Py_BuildValue("(Oi)", _x509_store_ctx_swigptr, 0);
 
-    _x509_store_ctx_inst = PyObject_CallObject(_klass, _x509_store_ctx_obj);
+#if PY_MAJOR_VERSION >= 3
+        _x509_store_ctx_inst = PyType_GenericNew(_klass, _x509_store_ctx_obj, NULL);
+#else
+        _x509_store_ctx_inst = PyInstance_New(_klass, _x509_store_ctx_obj, NULL);
+#endif // PY_MAJOR_VERSION >= 3
 
     argv = Py_BuildValue("(iO)", ok, _x509_store_ctx_inst);
 
@@ -4778,6 +4727,7 @@ int passphrase_callback(char *buf, int num, int v, void *arg) {
         return -1;
     }
 
+#if PY_MAJOR_VERSION >= 3
     if (!PyBytes_Check(ret)) {
         PyErr_SetString(PyExc_RuntimeError,
                         "Result of callback is not bytes().");
@@ -4788,6 +4738,16 @@ int passphrase_callback(char *buf, int num, int v, void *arg) {
     if ((len = PyBytes_Size(ret)) > num)
         len = num;
     str = PyBytes_AsString(ret);
+#else
+    if (!PyString_Check(ret)) {
+        Py_DECREF(ret);
+        PyGILState_Release(gilstate);
+        return -1;
+    }
+    if ((len = PyString_Size(ret)) > num)
+        len = num;
+    str = PyString_AsString(ret);
+#endif // PY_MAJOR_VERSION >= 3
 
     for (i = 0; i < len; i++)
         buf[i] = str[i];
@@ -4809,18 +4769,22 @@ void lib_init() {
 warrant a separate file. */
 
 PyObject *bn_to_mpi(const BIGNUM *bn) {
-    int len = 0;
+    int len;
     unsigned char *mpi;
     PyObject *pyo;
 
     len = BN_bn2mpi(bn, NULL);
     if (!(mpi=(unsigned char *)PyMem_Malloc(len))) {
-        m2_PyErr_Msg(PyExc_MemoryError);
+        m2_PyErr_Msg(PyExc_RuntimeError);
         return NULL;
     }
     len=BN_bn2mpi(bn, mpi);
 
+#if PY_MAJOR_VERSION >= 3
     pyo=PyBytes_FromStringAndSize((const char *)mpi, len);
+#else
+    pyo=PyString_FromStringAndSize((const char *)mpi, len);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(mpi);
     return pyo;
@@ -4828,7 +4792,7 @@ PyObject *bn_to_mpi(const BIGNUM *bn) {
 
 const BIGNUM *mpi_to_bn(PyObject *value) {
     const void *vbuf;
-    int vlen = 0;
+    int vlen;
 
     if (m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         return NULL;
@@ -4837,7 +4801,7 @@ const BIGNUM *mpi_to_bn(PyObject *value) {
 }
 
 PyObject *bn_to_bin(BIGNUM *bn) {
-    int len = 0;
+    int len;
     unsigned char *bin;
     PyObject *pyo;
 
@@ -4848,7 +4812,11 @@ PyObject *bn_to_bin(BIGNUM *bn) {
     }
     BN_bn2bin(bn, bin);
 
+#if PY_MAJOR_VERSION >= 3
     pyo=PyBytes_FromStringAndSize((const char *)bin, len);
+#else
+    pyo=PyString_FromStringAndSize((const char *)bin, len);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(bin);
     return pyo;
@@ -4856,7 +4824,7 @@ PyObject *bn_to_bin(BIGNUM *bn) {
 
 const BIGNUM *bin_to_bn(PyObject *value) {
     const void *vbuf;
-    int vlen = 0;
+    int vlen;
 
     if (m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         return NULL;
@@ -4867,7 +4835,7 @@ const BIGNUM *bin_to_bn(PyObject *value) {
 PyObject *bn_to_hex(BIGNUM *bn) {
     char *hex;
     PyObject *pyo;
-    Py_ssize_t len = 0;
+    Py_ssize_t len;
 
     hex = BN_bn2hex(bn);
     if (!hex) {
@@ -4877,7 +4845,11 @@ PyObject *bn_to_hex(BIGNUM *bn) {
     }
     len = strlen(hex);
 
+#if PY_MAJOR_VERSION >= 3
     pyo=PyBytes_FromStringAndSize(hex, len);
+#else
+    pyo=PyString_FromStringAndSize(hex, len);
+#endif // PY_MAJOR_VERSION >= 3
 
     OPENSSL_free(hex);
     return pyo;
@@ -4885,7 +4857,7 @@ PyObject *bn_to_hex(BIGNUM *bn) {
 
 BIGNUM *hex_to_bn(PyObject *value) {
     const void *vbuf;
-    Py_ssize_t vlen = 0;
+    Py_ssize_t vlen;
     BIGNUM *bn;
 
     if (PyObject_AsReadBuffer(value, &vbuf, &vlen) == -1)
@@ -4905,7 +4877,7 @@ BIGNUM *hex_to_bn(PyObject *value) {
 
 BIGNUM *dec_to_bn(PyObject *value) {
     const void *vbuf;
-    Py_ssize_t vlen = 0;
+    Py_ssize_t vlen;
     BIGNUM *bn;
 
     if (PyObject_AsReadBuffer(value, &vbuf, &vlen) == -1)
@@ -4994,67 +4966,144 @@ SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val)
 #include <openssl/bio.h>
 
 
-static PyObject *_bio_err;
+SWIGINTERN int
+SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
+{
+#if PY_VERSION_HEX>=0x03000000
+  if (PyUnicode_Check(obj))
+#else  
+  if (PyString_Check(obj))
+#endif
+  {
+    char *cstr; Py_ssize_t len;
+#if PY_VERSION_HEX>=0x03000000
+    if (!alloc && cptr) {
+        /* We can't allow converting without allocation, since the internal
+           representation of string in Python 3 is UCS-2/UCS-4 but we require
+           a UTF-8 representation.
+           TODO(bhy) More detailed explanation */
+        return SWIG_RuntimeError;
+    }
+    obj = PyUnicode_AsUTF8String(obj);
+    PyBytes_AsStringAndSize(obj, &cstr, &len);
+    if(alloc) *alloc = SWIG_NEWOBJ;
+#else
+    PyString_AsStringAndSize(obj, &cstr, &len);
+#endif
+    if (cptr) {
+      if (alloc) {
+	/* 
+	   In python the user should not be able to modify the inner
+	   string representation. To warranty that, if you define
+	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
+	   buffer is always returned.
 
+	   The default behavior is just to return the pointer value,
+	   so, be careful.
+	*/ 
+#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
+	if (*alloc != SWIG_OLDOBJ) 
+#else
+	if (*alloc == SWIG_NEWOBJ) 
+#endif
+	  {
+	    *cptr = (char *)memcpy((char *)malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
+	    *alloc = SWIG_NEWOBJ;
+	  }
+	else {
+	  *cptr = cstr;
+	  *alloc = SWIG_OLDOBJ;
+	}
+      } else {
+        #if PY_VERSION_HEX>=0x03000000
+        assert(0); /* Should never reach here in Python 3 */
+        #endif
+	*cptr = SWIG_Python_str_AsChar(obj);
+      }
+    }
+    if (psize) *psize = len + 1;
+#if PY_VERSION_HEX>=0x03000000
+    Py_XDECREF(obj);
+#endif
+    return SWIG_OK;
+  } else {
+    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
+    if (pchar_descriptor) {
+      void* vptr = 0;
+      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
+	if (cptr) *cptr = (char *) vptr;
+	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
+	if (alloc) *alloc = SWIG_OLDOBJ;
+	return SWIG_OK;
+      }
+    }
+  }
+  return SWIG_TypeError;
+}
 
-void pyfd_init(void);
 
-void bio_init(PyObject *bio_err) {
-    Py_INCREF(bio_err);
-    _bio_err = bio_err;
-    pyfd_init();
-}
 
-int bio_free(BIO *bio) {
-    int ret;
 
-    Py_BEGIN_ALLOW_THREADS
-    ret = BIO_free(bio);
-    Py_END_ALLOW_THREADS
-    if (ret == 0) {
-        m2_PyErr_Msg(_bio_err);
-    }
-    return ret;
-}
 
-BIO * bio_new_file(const char *filename, const char *mode) {
-    BIO *ret;
+static PyObject *_bio_err;
 
-    Py_BEGIN_ALLOW_THREADS
-    ret = BIO_new_file(filename, mode);
-    Py_END_ALLOW_THREADS
 
-    if (ret == NULL) {
-        m2_PyErr_Msg(_bio_err);
-    }
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+void pyfd_init(void);
+#endif
 
-    return ret;
+void bio_init(PyObject *bio_err) {
+    Py_INCREF(bio_err);
+    _bio_err = bio_err;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    pyfd_init();
+#endif
 }
 
 BIO *bio_new_pyfile(PyObject *pyfile, int bio_close) {
     FILE *fp = NULL;
-    BIO *bio = NULL;
+#if PY_MAJOR_VERSION >= 3
+    if (PyObject_HasAttrString(pyfile, "fileno")) {
+        int fd = (int)PyLong_AsLong(PyObject_CallMethod(pyfile, "fileno", NULL));
+        if (PyObject_HasAttrString(pyfile, "mode")) {
+            char *mode = PyUnicode_AsUTF8AndSize(
+                    PyObject_CallMethod(pyfile, "mode", NULL), NULL);
+            fp = fdopen(fd, mode);
+        }
+        else {
+            PyErr_Format(PyExc_ValueError,
+                         "File doesn’t have mode attribute!");
+            return NULL;
+        }
+    }
+    else {
+        PyErr_Format(PyExc_ValueError, "File doesn’t have fileno method!");
+        return NULL;
+    }
 
+#else
     fp = PyFile_AsFile(pyfile);
+#endif
+    BIO *bio = BIO_new_fp(fp, bio_close); /* returns NULL if error occurred */
 
-    bio = BIO_new_fp(fp, bio_close);
-
-    /* returns NULL if error occurred */
     if (bio == NULL) {
-        /* Find out the name of the file so we can have good error
-         * message. */
-        PyObject *pyname = m2_PyFile_Name(pyfile);
-        char *name = PyBytes_AsString(pyname);
-
-        if (name == NULL) {
-            PyErr_Format(_bio_err,
-                         "Opening of the new BIO on file failed!");
+        char *name = "";
+#if PY_MAJOR_VERSION >= 3
+        if (PyObject_HasAttrString(pyfile, "name")) {
+            char *name = PyUnicode_AsUTF8AndSize(
+                    PyObject_CallMethod(pyfile, "name", NULL), NULL);
         }
         else {
-            PyErr_Format(_bio_err,
-                         "Opening of the new BIO on file %s failed!", name);
+            PyErr_Format(PyExc_ValueError,
+                         "File doesn’t have name attribute!");
+            return NULL;
         }
-        Py_DECREF(pyname);
+#else
+        name = PyString_AsString(PyFile_Name(pyfile));
+#endif
+        PyErr_Format(PyExc_MemoryError,
+                     "Opening of the new BIO on file %s failed!", name);
+        return NULL;
     }
     return bio;
 }
@@ -5080,7 +5129,11 @@ PyObject *bio_read(BIO *bio, int num) {
         Py_RETURN_NONE;
     }
 
+#if PY_MAJOR_VERSION >= 3
     blob = PyBytes_FromStringAndSize(buf, r);
+#else
+    blob = PyString_FromStringAndSize(buf, r);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(buf);
     return blob;
@@ -5107,7 +5160,11 @@ PyObject *bio_gets(BIO *bio, int num) {
         Py_RETURN_NONE;
     }
 
+#if PY_MAJOR_VERSION >= 3
     blob = PyBytes_FromStringAndSize(buf, r);
+#else
+    blob = PyString_FromStringAndSize(buf, r);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(buf);
     return blob;
@@ -5115,7 +5172,7 @@ PyObject *bio_gets(BIO *bio, int num) {
 
 int bio_write(BIO *bio, PyObject *from) {
     const void *fbuf;
-    int flen = 0, ret;
+    int flen, ret;
 
     if (m2_PyObject_AsReadBufferInt(from, &fbuf, &flen) == -1)
         return -1;
@@ -5150,88 +5207,9 @@ int bio_reset(BIO *bio) {
 }
 
 
-SWIGINTERN int
-SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
-{
-#if PY_VERSION_HEX>=0x03000000
-  if (PyUnicode_Check(obj))
-#else  
-  if (PyString_Check(obj))
-#endif
-  {
-    char *cstr; Py_ssize_t len;
-#if PY_VERSION_HEX>=0x03000000
-    if (!alloc && cptr) {
-        /* We can't allow converting without allocation, since the internal
-           representation of string in Python 3 is UCS-2/UCS-4 but we require
-           a UTF-8 representation.
-           TODO(bhy) More detailed explanation */
-        return SWIG_RuntimeError;
-    }
-    obj = PyUnicode_AsUTF8String(obj);
-    PyBytes_AsStringAndSize(obj, &cstr, &len);
-    if(alloc) *alloc = SWIG_NEWOBJ;
-#else
-    PyString_AsStringAndSize(obj, &cstr, &len);
-#endif
-    if (cptr) {
-      if (alloc) {
-	/* 
-	   In python the user should not be able to modify the inner
-	   string representation. To warranty that, if you define
-	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
-	   buffer is always returned.
-
-	   The default behavior is just to return the pointer value,
-	   so, be careful.
-	*/ 
-#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
-	if (*alloc != SWIG_OLDOBJ) 
-#else
-	if (*alloc == SWIG_NEWOBJ) 
-#endif
-	  {
-	    *cptr = (char *)memcpy((char *)malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
-	    *alloc = SWIG_NEWOBJ;
-	  }
-	else {
-	  *cptr = cstr;
-	  *alloc = SWIG_OLDOBJ;
-	}
-      } else {
-        #if PY_VERSION_HEX>=0x03000000
-        assert(0); /* Should never reach here in Python 3 */
-        #endif
-	*cptr = SWIG_Python_str_AsChar(obj);
-      }
-    }
-    if (psize) *psize = len + 1;
-#if PY_VERSION_HEX>=0x03000000
-    Py_XDECREF(obj);
-#endif
-    return SWIG_OK;
-  } else {
-    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
-    if (pchar_descriptor) {
-      void* vptr = 0;
-      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
-	if (cptr) *cptr = (char *) vptr;
-	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
-	if (alloc) *alloc = SWIG_OLDOBJ;
-	return SWIG_OK;
-      }
-    }
-  }
-  return SWIG_TypeError;
-}
-
-
-
-
-
-int bio_flush(BIO *bio) {
-    return (int)BIO_flush(bio);
-}
+int bio_flush(BIO *bio) {
+    return (int)BIO_flush(bio);
+}
 
 int bio_seek(BIO *bio, int offset) {
     return (int)BIO_seek(bio, offset);
@@ -5301,48 +5279,10 @@ int bio_should_write(BIO* a) {
     return BIO_should_write(a);
 }
 
-/* Macros for things not defined before 1.1.0 */
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
-static BIO_METHOD *
-BIO_meth_new( int type, const char *name )
-{
-    BIO_METHOD *method = malloc( sizeof(BIO_METHOD) );
-    memset( method, 0, sizeof(BIO_METHOD) );
-
-    method->type = type;
-    method->name = name;
-
-    return method;
-}
-
-static void
-BIO_meth_free( BIO_METHOD *meth )
-{
-    if ( meth == NULL ) {
-        return;
-    }
-
-    free(meth);
-}
-#define BIO_meth_set_write(m, f) (m)->bwrite = (f)
-#define BIO_meth_set_read(m, f) (m)->bread = (f)
-#define BIO_meth_set_puts(m, f) (m)->bputs = (f)
-#define BIO_meth_set_gets(m, f) (m)->bgets = (f)
-#define BIO_meth_set_ctrl(m, f) (m)->ctrl = (f)
-#define BIO_meth_set_create(m, f) (m)->create = (f)
-#define BIO_meth_set_destroy(m, f) (m)->destroy = (f)
-#define BIO_set_shutdown(b, x) (b)->shutdown = x
-#define BIO_get_shutdown(b) (b)->shutdown
-#define BIO_set_init(b, x)    b->init = x
-#define BIO_get_init(b) (b)->init
-#define BIO_set_data(b, x)    b->ptr = x
-#define BIO_clear_flags(b, x)    b->flags &= ~(x)
-#define BIO_get_data(b)    b->ptr
-#endif
-
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
 /* implment custom BIO_s_pyfd */
 
-#ifdef _WIN32
+#ifdef WIN32
 #  define clear_sys_error()       SetLastError(0)
 /* Linux doesn't use underscored calls yet */
 #  define open(p, f, m) _open(p, f, m)
@@ -5351,7 +5291,7 @@ BIO_meth_free( BIO_METHOD *meth )
 #  define close(f) _close(f)
 #  define lseek(fd, o, w) _lseek(fd, o, w)
 #else
-# define clear_sys_error()       errno=0
+#  define clear_sys_error()       errno=0
 #endif
 
 typedef struct pyfd_struct {
@@ -5524,15 +5464,9 @@ static long pyfd_ctrl(BIO *b, int cmd, long num, void *ptr) {
 }
 
 void pyfd_init(void) {
-#if OPENSSL_VERSION_NUMBER >= 0x10100000L
     methods_fdp = BIO_meth_new(
         BIO_get_new_index()|BIO_TYPE_DESCRIPTOR|BIO_TYPE_SOURCE_SINK,
         "python file descriptor");
-#else
-    methods_fdp = BIO_meth_new(
-        100 |BIO_TYPE_DESCRIPTOR|BIO_TYPE_SOURCE_SINK,
-        "python file descriptor");
-#endif
 
     BIO_meth_set_write(methods_fdp, pyfd_write);
     BIO_meth_set_read(methods_fdp, pyfd_read);
@@ -5550,6 +5484,7 @@ BIO* BIO_new_pyfd(int fd, int close_flag) {
     BIO_set_fd(ret, fd, close_flag);
     return ret;
     }
+#endif
 
 
 SWIGINTERNINLINE int
@@ -5605,11 +5540,14 @@ PyObject *bn_rand_range(PyObject *range)
     BIGNUM *rng = NULL;
     PyObject *ret, *tuple;
     PyObject *format, *rangePyString;
-    char *randhex; /* PyLong_FromString is unhappy with const */
-    const char *rangehex;
+    char *randhex, *rangehex;
 
     /* Wow, it's a lot of work to convert into a hex string in C! */
+#if PY_MAJOR_VERSION >= 3
     format = PyUnicode_FromString("%x");
+#else
+    format = PyString_FromString("%x");
+#endif // PY_MAJOR_VERSION >= 3
 
     if (!format) {
         PyErr_SetString(PyExc_RuntimeError, "Cannot create Python string '%x'");
@@ -5624,7 +5562,11 @@ PyObject *bn_rand_range(PyObject *range)
     Py_INCREF(range);
     PyTuple_SET_ITEM(tuple, 0, range);
 
+#if PY_MAJOR_VERSION >= 3
     rangePyString = PyUnicode_Format(format, tuple);
+#else
+    rangePyString = PyString_Format(format, tuple);
+#endif // PY_MAJOR_VERSION >= 3
 
     if (!rangePyString) {
         PyErr_SetString(PyExc_Exception, "String Format failed");
@@ -5635,7 +5577,11 @@ PyObject *bn_rand_range(PyObject *range)
     Py_DECREF(format);
     Py_DECREF(tuple);
 
-    rangehex = (const char*)PyUnicode_AsUTF8(rangePyString);
+#if PY_MAJOR_VERSION >= 3
+    rangehex = PyUnicode_AsUTF8(rangePyString);
+#else
+    rangehex = PyString_AsString(rangePyString);
+#endif // PY_MAJOR_VERSION >= 3
 
     if (!BN_hex2bn(&rng, rangehex)) {
         /*Custom errors?*/
@@ -5686,9 +5632,10 @@ void rand_init(PyObject *rand_err) {
 
 PyObject *rand_seed(PyObject *seed) {
     const void *buf;
-    int len = 0;
+    int len;
 
-    m2_PyObject_AsReadBufferInt(seed, &buf, &len);
+    if (m2_PyObject_AsReadBufferInt(seed, &buf, &len) == -1)
+        return NULL;
 
     RAND_seed(buf, len);
     Py_RETURN_NONE;
@@ -5696,9 +5643,10 @@ PyObject *rand_seed(PyObject *seed) {
 
 PyObject *rand_add(PyObject *blob, double entropy) {
     const void *buf;
-    int len = 0;
+    int len;
 
-    m2_PyObject_AsReadBufferInt(blob, &buf, &len);
+    if (m2_PyObject_AsReadBufferInt(blob, &buf, &len) == -1)
+        return NULL;
 
     RAND_add(buf, len, entropy);
     Py_RETURN_NONE;
@@ -5706,31 +5654,23 @@ PyObject *rand_add(PyObject *blob, double entropy) {
 
 PyObject *rand_bytes(int n) {
     void *blob;
-    int ret;
     PyObject *obj;
     
     if (!(blob = PyMem_Malloc(n))) {
-        PyErr_SetString(PyExc_MemoryError,
-        "Insufficient memory for rand_bytes.");
+        PyErr_SetString(PyExc_MemoryError, "rand_bytes");
         return NULL;
     }
-    if ((ret = RAND_bytes(blob, n)) == 1) {
+    if (RAND_bytes(blob, n)) {
+#if PY_MAJOR_VERSION >= 3
         obj = PyBytes_FromStringAndSize(blob, n);
+#else
+        obj = PyString_FromStringAndSize(blob, n);
+#endif // PY_MAJOR_VERSION >= 3
         PyMem_Free(blob);
         return obj;
-    } else if (ret == 0) {
-        PyErr_SetString(_rand_err, "Not enough randomness.");
-        PyMem_Free(blob);
-        return NULL;
-    } else if (ret == -1) {
-        PyErr_SetString(_rand_err,
-                        "Not supported by the current RAND method.");
-        PyMem_Free(blob);
-        return NULL;
     } else {
         PyMem_Free(blob);
-        m2_PyErr_Msg(_rand_err);
-        return NULL;
+        Py_RETURN_NONE;
     }
 }
 
@@ -5740,7 +5680,7 @@ PyObject *rand_pseudo_bytes(int n) {
     PyObject *tuple;
     
     if (!(blob=(unsigned char *)PyMem_Malloc(n))) {
-        PyErr_SetString(PyExc_MemoryError, "Insufficient memory for rand_pseudo_bytes.");
+        PyErr_SetString(PyExc_MemoryError, "rand_pseudo_bytes");
         return NULL;
     }
     if (!(tuple=PyTuple_New(2))) {
@@ -5752,14 +5692,16 @@ PyObject *rand_pseudo_bytes(int n) {
     if (ret == -1) {
         PyMem_Free(blob);
         Py_DECREF(tuple);
-        PyErr_SetString(_rand_err,
-            "Function RAND_pseudo_bytes not supported by the current RAND method.");
-        return NULL;
+        Py_RETURN_NONE;
     } else {
+#if PY_MAJOR_VERSION >= 3
         PyTuple_SET_ITEM(tuple, 0, PyBytes_FromStringAndSize((char*)blob, n));
+#else
+         PyTuple_SET_ITEM(tuple, 0, PyString_FromStringAndSize((char*)blob, n));
+#endif // PY_MAJOR_VERSION >= 3
 
         PyMem_Free(blob);
-        PyTuple_SET_ITEM(tuple, 1, PyLong_FromLong((long)ret));
+        PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong((long)ret));
         return tuple;
     }
 }
@@ -5782,13 +5724,13 @@ PyObject *rand_file_name(void) {
 }
 
 void rand_screen(void) {
-#ifdef _WIN32
+#ifdef __WINDOWS__
     RAND_screen();
 #endif
 }
 
 int rand_win32_event(unsigned int imsg, int wparam, long lparam) {
-#ifdef _WIN32
+#ifdef __WINDOWS__
     return RAND_event(imsg, wparam, lparam);
 #else
     return 0;
@@ -5846,21 +5788,6 @@ void evp_init(PyObject *evp_err) {
     _evp_err = evp_err;
 }
 
-
-RSA *pkey_get1_rsa(EVP_PKEY *pkey) {
-    RSA *ret = NULL;
-
-    if ((ret = EVP_PKEY_get1_RSA(pkey)) == NULL) {
-        /* _evp_err now inherits from PyExc_ValueError, so we should
-         * keep API intact.
-         */
-        PyErr_Format(_evp_err, "Invalid key in function %s.", __FUNCTION__);
-    }
-
-    return ret;
-}
-
-
 PyObject *pkcs5_pbkdf2_hmac_sha1(PyObject *pass,
                                  PyObject *salt,
                                  int iter,
@@ -5869,7 +5796,7 @@ PyObject *pkcs5_pbkdf2_hmac_sha1(PyObject *pass,
     unsigned char *saltbuf;
     char *passbuf;
     PyObject *ret;
-    int passlen = 0, saltlen = 0;
+    int passlen, saltlen;
 
     if (m2_PyObject_AsReadBufferInt(pass, (const void **)&passbuf,
                                     &passlen) == -1)
@@ -5883,7 +5810,11 @@ PyObject *pkcs5_pbkdf2_hmac_sha1(PyObject *pass,
 	return PyErr_NoMemory();
     PKCS5_PBKDF2_HMAC_SHA1(passbuf, passlen, saltbuf, saltlen, iter,
                            keylen, key);
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((char*)key, keylen);
+#else
+    ret = PyString_FromStringAndSize((char*)key, keylen);
+#endif
     OPENSSL_cleanse(key, keylen);
     PyMem_Free(key);
     return ret;
@@ -5928,7 +5859,11 @@ PyObject *digest_final(EVP_MD_CTX *ctx) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(blob, blen);
+#else
+    ret = PyString_FromStringAndSize(blob, blen);
+#endif
 
     PyMem_Free(blob);
     return ret;
@@ -5950,7 +5885,7 @@ void hmac_ctx_free(HMAC_CTX *ctx) {
 
 PyObject *hmac_init(HMAC_CTX *ctx, PyObject *key, const EVP_MD *md) {
     const void *kbuf;
-    int klen = 0;
+    int klen;
 
     if (m2_PyObject_AsReadBufferInt(key, &kbuf, &klen) == -1)
         return NULL;
@@ -5991,7 +5926,11 @@ PyObject *hmac_final(HMAC_CTX *ctx) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(blob, blen);
+#else
+    ret = PyString_FromStringAndSize(blob, blen);
+#endif
 
     PyMem_Free(blob);
     return ret;
@@ -6000,7 +5939,7 @@ PyObject *hmac_final(HMAC_CTX *ctx) {
 PyObject *hmac(PyObject *key, PyObject *data, const EVP_MD *md) {
     const void *kbuf, *dbuf;
     void *blob;
-    int klen = 0;
+    int klen;
     unsigned int blen;
     Py_ssize_t dlen;
     PyObject *ret;
@@ -6016,7 +5955,11 @@ PyObject *hmac(PyObject *key, PyObject *data, const EVP_MD *md) {
     HMAC(md, kbuf, klen, dbuf, dlen, blob, &blen);
     blob = PyMem_Realloc(blob, blen);
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(blob, blen);
+#else
+    ret = PyString_FromStringAndSize(blob, blen);
+#endif
 
     PyMem_Free(blob);
     return ret;
@@ -6043,7 +5986,7 @@ PyObject *bytes_to_key(const EVP_CIPHER *cipher, EVP_MD *md,
                         int iter) {
     unsigned char key[EVP_MAX_KEY_LENGTH];
     const void *dbuf, *sbuf;
-    int dlen = 0, klen;
+    int dlen, klen;
     Py_ssize_t slen;
     PyObject *ret;
 
@@ -6056,7 +5999,11 @@ PyObject *bytes_to_key(const EVP_CIPHER *cipher, EVP_MD *md,
         (unsigned char *)dbuf, dlen, iter,
         key, NULL); /* Since we are not returning IV no need to derive it */
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((char*)key, klen);
+#else
+    ret = PyString_FromStringAndSize((char*)key, klen);
+#endif
 
     return ret;
 }
@@ -6080,7 +6027,7 @@ PyObject *cipher_init(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
 
 PyObject *cipher_update(EVP_CIPHER_CTX *ctx, PyObject *blob) {
     const void *buf;
-    int len = 0, olen;
+    int len, olen;
     void *obuf;
     PyObject *ret;
 
@@ -6097,7 +6044,11 @@ PyObject *cipher_update(EVP_CIPHER_CTX *ctx, PyObject *blob) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(obuf, olen);
+#else
+    ret = PyString_FromStringAndSize(obuf, olen);
+#endif
 
     PyMem_Free(obuf);
     return ret;
@@ -6118,7 +6069,11 @@ PyObject *cipher_final(EVP_CIPHER_CTX *ctx) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(obuf, olen);
+#else
+    ret = PyString_FromStringAndSize(obuf, olen);
+#endif
 
     PyMem_Free(obuf);
     return ret;
@@ -6156,7 +6111,11 @@ PyObject *sign_final(EVP_MD_CTX *ctx, EVP_PKEY *pkey) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((char*)sigbuf, siglen);
+#else
+    ret = PyString_FromStringAndSize((char*)sigbuf, siglen);
+#endif
 
     OPENSSL_cleanse(sigbuf, siglen);
     OPENSSL_free(sigbuf);
@@ -6176,7 +6135,7 @@ int verify_update(EVP_MD_CTX *ctx, PyObject *blob) {
 
 int verify_final(EVP_MD_CTX *ctx, PyObject *blob, EVP_PKEY *pkey) {
     unsigned char *kbuf;
-    int len = 0;
+    int len;
 
     if (m2_PyObject_AsReadBufferInt(blob, (const void **)&kbuf, &len) == -1)
         return -1;
@@ -6185,17 +6144,6 @@ int verify_final(EVP_MD_CTX *ctx, PyObject *blob, EVP_PKEY *pkey) {
 }
 
 
-const EVP_MD *get_digestbyname(const char* name) {
-    const EVP_MD *ret = NULL;
-
-    if ((ret = EVP_get_digestbyname(name)) == NULL) {
-        m2_PyErr_Msg(_evp_err);
-    }
-
-    return ret;
-}
-
-
 int pkey_write_pem_no_cipher(EVP_PKEY *pkey, BIO *f, PyObject *pyfunc) {
     int ret;
 
@@ -6222,17 +6170,6 @@ int pkey_write_pem(EVP_PKEY *pkey, BIO *f, EVP_CIPHER *cipher, PyObject *pyfunc)
 }
 
 
-EVP_PKEY *pkey_new(void) {
-    EVP_PKEY *ret;
-
-    if ((ret = EVP_PKEY_new()) == NULL) {
-        PyErr_Format(PyExc_MemoryError,
-                     "Insufficient memory for new key in function %s.", __FUNCTION__);
-    }
-
-    return ret;
-}
-
 EVP_PKEY *pkey_read_pem(BIO *f, PyObject *pyfunc) {
     EVP_PKEY *pk;
 
@@ -6241,12 +6178,6 @@ EVP_PKEY *pkey_read_pem(BIO *f, PyObject *pyfunc) {
     pk = PEM_read_bio_PrivateKey(f, NULL, passphrase_callback, (void *)pyfunc);
     Py_END_ALLOW_THREADS
     Py_DECREF(pyfunc);
-
-    if (pk == NULL) {
-        PyErr_Format(_evp_err,
-                     "Unable to read private key in function %s.", __FUNCTION__);
-    }
-
     return pk;
 }
 
@@ -6258,16 +6189,9 @@ EVP_PKEY *pkey_read_pem_pubkey(BIO *f, PyObject *pyfunc) {
     pk = PEM_read_bio_PUBKEY(f, NULL, passphrase_callback, (void *)pyfunc);
     Py_END_ALLOW_THREADS
     Py_DECREF(pyfunc);
-
-    if (pk == NULL) {
-        PyErr_Format(_evp_err,
-                     "Unable to read public key in function %s.", __FUNCTION__);
-    }
-
     return pk;
 }
 
-
 int pkey_assign_rsa(EVP_PKEY *pkey, RSA *rsa) {
     return EVP_PKEY_assign_RSA(pkey, rsa);
 }
@@ -6278,11 +6202,15 @@ PyObject *pkey_as_der(EVP_PKEY *pkey) {
     PyObject * der;
     len = i2d_PUBKEY(pkey, &pp);
     if (len < 0){
-        PyErr_SetString(_evp_err, "EVP_PKEY as DER failed");
+        PyErr_SetString(PyExc_ValueError, "EVP_PKEY as DER failed");
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     der = PyBytes_FromStringAndSize((char*)pp, len);
+#else
+    der = PyString_FromStringAndSize((char*)pp, len);
+#endif
 
     OPENSSL_free(pp);
     return der;
@@ -6317,7 +6245,11 @@ PyObject *pkey_get_modulus(EVP_PKEY *pkey)
             }
             BIO_get_mem_ptr(bio, &bptr);
 
+#if PY_MAJOR_VERSION >= 3
             ret = PyBytes_FromStringAndSize(bptr->data, bptr->length);
+#else
+            ret = PyString_FromStringAndSize(bptr->data, bptr->length);
+#endif
 
             (void)BIO_set_close(bio, BIO_CLOSE);
             BIO_free(bio);
@@ -6345,7 +6277,11 @@ PyObject *pkey_get_modulus(EVP_PKEY *pkey)
             }
             BIO_get_mem_ptr(bio, &bptr);
 
+#if PY_MAJOR_VERSION >= 3
             ret = PyBytes_FromStringAndSize(bptr->data, bptr->length);
+#else
+            ret = PyString_FromStringAndSize(bptr->data, bptr->length);
+#endif
 
             (void)BIO_set_close(bio, BIO_CLOSE);
             BIO_free(bio);
@@ -6355,7 +6291,7 @@ PyObject *pkey_get_modulus(EVP_PKEY *pkey)
             break;
 
         default:
-            PyErr_SetString(_evp_err, "unsupported key type");
+            PyErr_SetString(PyExc_ValueError, "unsupported key type");
             return NULL;
     }
 }
@@ -6396,34 +6332,34 @@ void AES_free(AES_KEY *key) {
 }
 
 /* 
-// op == 0: encrypt
-// otherwise: decrypt (Python code will supply the value 1.)
+// op == 0: decrypt
+// otherwise: encrypt (Python code will supply the value 1.)
 */
 PyObject *AES_set_key(AES_KEY *key, PyObject *value, int bits, int op) { 
-    char *vbuf; 
+    const void *vbuf; 
     Py_ssize_t vlen;
 
-    if (PyBytes_AsStringAndSize(value, &vbuf, &vlen) == -1)
+    if (PyObject_AsReadBuffer(value, &vbuf, &vlen) == -1)
         return NULL;
 
     if (op == 0) 
-        AES_set_encrypt_key((const unsigned char *)vbuf, bits, key);
+        AES_set_encrypt_key(vbuf, bits, key);
     else
-        AES_set_decrypt_key((const unsigned char *)vbuf, bits, key);
+        AES_set_decrypt_key(vbuf, bits, key);
     Py_RETURN_NONE;
 }
 
 /* 
-// op == 0: encrypt
-// otherwise: decrypt (Python code will supply the value 1.)
+// op == 0: decrypt
+// otherwise: encrypt (Python code will supply the value 1.)
 */
 PyObject *AES_crypt(const AES_KEY *key, PyObject *in, int outlen, int op) {
-    char *buf;
+    const void *buf;
     Py_ssize_t len;
     unsigned char *out;
     PyObject *res;
 
-    if (PyBytes_AsStringAndSize(in, &buf, &len) == -1)
+    if (PyObject_AsReadBuffer(in, &buf, &len) == -1)
         return NULL;
 
     if (!(out=(unsigned char *)PyMem_Malloc(outlen))) {
@@ -6431,10 +6367,14 @@ PyObject *AES_crypt(const AES_KEY *key, PyObject *in, int outlen, int op) {
         return NULL;
     }
     if (op == 0)
-        AES_encrypt((const unsigned char *)buf, out, key);
+        AES_encrypt((const unsigned char *)in, out, key);
     else
-        AES_decrypt((const unsigned char *)buf, out, key);
-    res = PyBytes_FromStringAndSize((char*)out, outlen);
+        AES_decrypt((const unsigned char *)in, out, key);
+#if PY_MAJOR_VERSION >= 3
+    return PyBytes_FromStringAndSize((char*)out, outlen);
+#else
+    return PyString_FromStringAndSize((char*)out, outlen);
+#endif // PY_MAJOR_VERSION >= 3
     PyMem_Free(out);
     return res;
 }
@@ -6461,7 +6401,7 @@ void rc4_free(RC4_KEY *key) {
 
 PyObject *rc4_set_key(RC4_KEY *key, PyObject *value) {
     const void *vbuf;
-    int vlen = 0;
+    int vlen;
 
     if (m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         return NULL;
@@ -6485,7 +6425,11 @@ PyObject *rc4_update(RC4_KEY *key, PyObject *in) {
     }
     RC4(key, len, buf, out);
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(out, len);
+#else
+    ret = PyString_FromStringAndSize(out, len);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(out);
     return ret;
@@ -6561,7 +6505,7 @@ int dh_check(DH *dh) {
 
 PyObject *dh_compute_key(DH *dh, PyObject *pubkey) {
     const void *pkbuf;
-    int pklen = 0, klen;
+    int pklen, klen;
     void *key;
     BIGNUM *pk;
     PyObject *ret;
@@ -6585,7 +6529,11 @@ PyObject *dh_compute_key(DH *dh, PyObject *pubkey) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((const char *)key, klen);
+#else
+	ret = PyString_FromStringAndSize((const char *)key, klen);
+#endif // PY_MAJOR_VERSION >= 3
 
     BN_free(pk);
     PyMem_Free(key);
@@ -6801,7 +6749,7 @@ PyObject *rsa_set_en(RSA *rsa, PyObject *eval, PyObject* nval) {
 static BIGNUM* PyObject_Bin_AsBIGNUM(PyObject* value) {
     BIGNUM* bn;
     const void* vbuf;
-    int vlen = 0;
+    int vlen;
 
     if (m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         return NULL;
@@ -6834,7 +6782,7 @@ PyObject *rsa_set_en_bin(RSA *rsa, PyObject *eval, PyObject* nval) {
 PyObject *rsa_private_encrypt(RSA *rsa, PyObject *from, int padding) {
     const void *fbuf;
     void *tbuf;
-    int flen = 0, tlen;
+    int flen, tlen;
     PyObject *ret;
 
     if (m2_PyObject_AsReadBufferInt(from, &fbuf, &flen) == -1)
@@ -6852,7 +6800,11 @@ PyObject *rsa_private_encrypt(RSA *rsa, PyObject *from, int padding) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((const char *)tbuf, tlen);
+#else
+    ret = PyString_FromStringAndSize((const char *)tbuf, tlen);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(tbuf);
     return ret;
@@ -6861,7 +6813,7 @@ PyObject *rsa_private_encrypt(RSA *rsa, PyObject *from, int padding) {
 PyObject *rsa_public_decrypt(RSA *rsa, PyObject *from, int padding) {
     const void *fbuf;
     void *tbuf;
-    int flen = 0, tlen = 0;
+    int flen, tlen;
     PyObject *ret;
 
     if (m2_PyObject_AsReadBufferInt(from, &fbuf, &flen) == -1)
@@ -6882,7 +6834,11 @@ PyObject *rsa_public_decrypt(RSA *rsa, PyObject *from, int padding) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((const char *)tbuf, tlen);
+#else
+    ret = PyString_FromStringAndSize((const char *)tbuf, tlen);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(tbuf);
     return ret;
@@ -6891,7 +6847,7 @@ PyObject *rsa_public_decrypt(RSA *rsa, PyObject *from, int padding) {
 PyObject *rsa_public_encrypt(RSA *rsa, PyObject *from, int padding) {
     const void *fbuf;
     void *tbuf;
-    int flen = 0, tlen;
+    int flen, tlen;
     PyObject *ret;
 
     if (m2_PyObject_AsReadBufferInt(from, &fbuf, &flen) == -1)
@@ -6909,7 +6865,11 @@ PyObject *rsa_public_encrypt(RSA *rsa, PyObject *from, int padding) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((const char *)tbuf, tlen);
+#else
+    ret = PyString_FromStringAndSize((const char *)tbuf, tlen);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(tbuf);
     return ret;
@@ -6918,7 +6878,7 @@ PyObject *rsa_public_encrypt(RSA *rsa, PyObject *from, int padding) {
 PyObject *rsa_private_decrypt(RSA *rsa, PyObject *from, int padding) {
     const void *fbuf;
     void *tbuf;
-    int flen = 0, tlen;
+    int flen, tlen;
     PyObject *ret;
 
     if (m2_PyObject_AsReadBufferInt(from, &fbuf, &flen) == -1)
@@ -6935,7 +6895,11 @@ PyObject *rsa_private_decrypt(RSA *rsa, PyObject *from, int padding) {
         PyMem_Free(tbuf);
         return NULL;
     }
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((const char *)tbuf, tlen);
+#else
+    ret = PyString_FromStringAndSize((const char *)tbuf, tlen);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(tbuf);
     return ret;
@@ -6970,7 +6934,11 @@ PyObject *rsa_padding_add_pkcs1_pss(RSA *rsa, PyObject *digest, EVP_MD *hash, in
         OPENSSL_free(tbuf);
         return NULL;
     }
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((const char *)tbuf, tlen);
+#else
+    ret = PyString_FromStringAndSize((const char *)tbuf, tlen);
+#endif // PY_MAJOR_VERSION >= 3
     OPENSSL_cleanse(tbuf, tlen);
     OPENSSL_free(tbuf);
     return ret;
@@ -7027,7 +6995,11 @@ PyObject *rsa_sign(RSA *rsa, PyObject *py_digest_string, int method_type) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     signature =  PyBytes_FromStringAndSize((const char*) sign_buf, buf_len);
+#else
+    signature =  PyString_FromStringAndSize((const char*) sign_buf, buf_len);
+#endif
 
     PyMem_Free(sign_buf);
     return signature;
@@ -7150,7 +7122,6 @@ void dsa_init(PyObject *dsa_err) {
     _dsa_err = dsa_err;
 }
 
-
 DSA *dsa_generate_parameters(int bits, PyObject *pyfunc) {
     DSA *dsa;
     BN_GENCB *gencb;
@@ -7183,55 +7154,6 @@ DSA *dsa_generate_parameters(int bits, PyObject *pyfunc) {
     return NULL;
 }
 
-DSA *dsa_read_params(BIO *f, PyObject *pyfunc) {
-    DSA *ret;
-
-    Py_INCREF(pyfunc);
-    Py_BEGIN_ALLOW_THREADS
-    ret = PEM_read_bio_DSAparams(f, NULL, passphrase_callback, (void *)pyfunc);
-    Py_END_ALLOW_THREADS
-    Py_DECREF(pyfunc);
-
-    if (ret == NULL) {
-        m2_PyErr_Msg(_dsa_err);
-    }
-
-    return ret;
-}
-
-DSA *dsa_read_key(BIO *f, PyObject *pyfunc) {
-    DSA *ret;
-
-    Py_INCREF(pyfunc);
-    Py_BEGIN_ALLOW_THREADS
-    ret = PEM_read_bio_DSAPrivateKey(f, NULL, passphrase_callback, (void *)pyfunc);
-    Py_END_ALLOW_THREADS
-    Py_DECREF(pyfunc);
-
-    if (ret == NULL) {
-        m2_PyErr_Msg(_dsa_err);
-    }
-
-    return ret;
-}
-
-DSA *dsa_read_pub_key(BIO *f, PyObject *pyfunc) {
-    DSA *ret;
-
-    Py_INCREF(pyfunc);
-    Py_BEGIN_ALLOW_THREADS
-    ret = PEM_read_bio_DSA_PUBKEY(f, NULL, passphrase_callback, (void *)pyfunc);
-    Py_END_ALLOW_THREADS
-    Py_DECREF(pyfunc);
-
-    if (ret == NULL) {
-        m2_PyErr_Msg(_dsa_err);
-    }
-
-    return ret;
-}
-
-
 PyObject *dsa_get_p(DSA *dsa) {
     const BIGNUM* p = NULL;
     DSA_get0_pqg(dsa, &p, NULL, NULL);
@@ -7306,7 +7228,7 @@ PyObject *dsa_set_pqg(DSA *dsa, PyObject *pval, PyObject* qval, PyObject* gval)
 PyObject *dsa_set_pub(DSA *dsa, PyObject *value) {
     BIGNUM *bn;
     const void *vbuf;
-    int vlen = 0;
+    int vlen;
 
     if (m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         return NULL;
@@ -7323,6 +7245,18 @@ PyObject *dsa_set_pub(DSA *dsa, PyObject *value) {
 }
 
 
+DSA *dsa_read_params(BIO *f, PyObject *pyfunc) {
+    DSA *ret;
+
+    Py_INCREF(pyfunc);
+    Py_BEGIN_ALLOW_THREADS
+    ret = PEM_read_bio_DSAparams(f, NULL, passphrase_callback, (void *)pyfunc);
+    Py_END_ALLOW_THREADS
+    Py_DECREF(pyfunc);
+    return ret;
+}
+
+
 int dsa_write_params_bio(DSA* dsa, BIO* f) {
     return PEM_write_bio_DSAparams(f, dsa);
 }
@@ -7359,22 +7293,45 @@ int dsa_write_pub_key_bio(DSA* dsa, BIO* f) {
 }
 
 
-PyObject *dsa_sign(DSA *dsa, PyObject *value) {
-    const void *vbuf;
-    int vlen = 0;
-    PyObject *tuple;
-    DSA_SIG *sig;
+DSA *dsa_read_key(BIO *f, PyObject *pyfunc) {
+    DSA *ret;
 
-    if (m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
-        return NULL;
+    Py_INCREF(pyfunc);
+    Py_BEGIN_ALLOW_THREADS
+    ret = PEM_read_bio_DSAPrivateKey(f, NULL, passphrase_callback, (void *)pyfunc);
+    Py_END_ALLOW_THREADS
+    Py_DECREF(pyfunc);
+    return ret;
+}
 
-    if (!(sig = DSA_do_sign(vbuf, vlen, dsa))) {
-        m2_PyErr_Msg(_dsa_err);
-        return NULL;
-    }
-    if (!(tuple = PyTuple_New(2))) {
-        DSA_SIG_free(sig);
-        PyErr_SetString(PyExc_RuntimeError, "PyTuple_New() fails");
+
+DSA *dsa_read_pub_key(BIO *f, PyObject *pyfunc) {
+    DSA *ret;
+
+    Py_INCREF(pyfunc);
+    Py_BEGIN_ALLOW_THREADS
+    ret = PEM_read_bio_DSA_PUBKEY(f, NULL, passphrase_callback, (void *)pyfunc);
+    Py_END_ALLOW_THREADS
+    Py_DECREF(pyfunc);
+    return ret;
+}
+
+PyObject *dsa_sign(DSA *dsa, PyObject *value) {
+    const void *vbuf;
+    int vlen;
+    PyObject *tuple;
+    DSA_SIG *sig;
+
+    if (m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
+        return NULL;
+
+    if (!(sig = DSA_do_sign(vbuf, vlen, dsa))) {
+        m2_PyErr_Msg(_dsa_err);
+        return NULL;
+    }
+    if (!(tuple = PyTuple_New(2))) {
+        DSA_SIG_free(sig);
+        PyErr_SetString(PyExc_RuntimeError, "PyTuple_New() fails");
         return NULL;
     }
     PyTuple_SET_ITEM(tuple, 0, dsa_sig_get_r(sig));
@@ -7385,7 +7342,7 @@ PyObject *dsa_sign(DSA *dsa, PyObject *value) {
 
 int dsa_verify(DSA *dsa, PyObject *value, PyObject *r, PyObject *s) {
     const void *vbuf, *rbuf, *sbuf;
-    int vlen = 0, rlen = 0, slen = 0;
+    int vlen, rlen, slen;
     DSA_SIG *sig;
     BIGNUM* pr, *ps;
     int ret;
@@ -7427,7 +7384,7 @@ int dsa_verify(DSA *dsa, PyObject *value, PyObject *r, PyObject *s) {
 
 PyObject *dsa_sign_asn1(DSA *dsa, PyObject *value) {
     const void *vbuf;
-    int vlen = 0;
+    int vlen;
     void *sigbuf;
     unsigned int siglen;
     PyObject *ret;
@@ -7445,7 +7402,11 @@ PyObject *dsa_sign_asn1(DSA *dsa, PyObject *value) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(sigbuf, siglen);
+#else
+    ret = PyString_FromStringAndSize(sigbuf, siglen);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(sigbuf);
     return ret;
@@ -7454,7 +7415,7 @@ PyObject *dsa_sign_asn1(DSA *dsa, PyObject *value) {
 int dsa_verify_asn1(DSA *dsa, PyObject *value, PyObject *sig) {
     const void *vbuf;
     void *sbuf;
-    int vlen = 0, slen = 0, ret = 0;
+    int vlen, slen, ret;
 
     if ((m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         || (m2_PyObject_AsReadBufferInt(sig, (const void **)&sbuf, &slen)
@@ -7496,12 +7457,7 @@ int dsa_type_check(DSA *dsa) {
 #include <openssl/ssl.h>
 #include <openssl/tls1.h>
 #include <openssl/x509.h>
-#ifdef _WIN32
-#include <WinSock2.h>
-#include <Windows.h>
-#pragma comment(lib, "Ws2_32")
-typedef unsigned __int64 uint64_t;
-#else
+#ifndef _MSC_VER
 #include <poll.h>
 #include <sys/time.h>
 #endif
@@ -7545,7 +7501,7 @@ void ssl_ctx_passphrase_callback(SSL_CTX *ctx, PyObject *pyfunc) {
 
 int ssl_ctx_use_x509(SSL_CTX *ctx, X509 *x) {
     int i;
-
+    
     if (!(i = SSL_CTX_use_certificate(ctx, x))) {
         m2_PyErr_Msg(_ssl_err);
         return -1;
@@ -7556,7 +7512,7 @@ int ssl_ctx_use_x509(SSL_CTX *ctx, X509 *x) {
 
 int ssl_ctx_use_cert(SSL_CTX *ctx, char *file) {
     int i;
-
+    
     if (!(i = SSL_CTX_use_certificate_file(ctx, file, SSL_FILETYPE_PEM))) {
         m2_PyErr_Msg(_ssl_err);
         return -1;
@@ -7577,7 +7533,7 @@ int ssl_ctx_use_cert_chain(SSL_CTX *ctx, char *file) {
 
 int ssl_ctx_use_privkey(SSL_CTX *ctx, char *file) {
     int i;
-
+    
     if (!(i = SSL_CTX_use_PrivateKey_file(ctx, file, SSL_FILETYPE_PEM))) {
         m2_PyErr_Msg(_ssl_err);
         return -1;
@@ -7608,7 +7564,7 @@ int ssl_ctx_use_pkey_privkey(SSL_CTX *ctx, EVP_PKEY *pkey) {
 
 int ssl_ctx_check_privkey(SSL_CTX *ctx) {
     int ret;
-
+    
     if (!(ret = SSL_CTX_check_private_key(ctx))) {
         m2_PyErr_Msg(_ssl_err);
         return -1;
@@ -7633,7 +7589,7 @@ void ssl_ctx_set_verify(SSL_CTX *ctx, int mode, PyObject *pyfunc) {
 
 int ssl_ctx_set_session_id_context(SSL_CTX *ctx, PyObject *sid_ctx) {
     const void *buf;
-    int len = 0;
+    int len;
 
     if (m2_PyObject_AsReadBufferInt(sid_ctx, &buf, &len) == -1)
         return -1;
@@ -7713,7 +7669,7 @@ void ssl_set_client_CA_list_from_context(SSL *ssl, SSL_CTX *ctx) {
 
 int ssl_set_session_id_context(SSL *ssl, PyObject *sid_ctx) {
     const void *buf;
-    int len = 0;
+    int len;
 
     if (m2_PyObject_AsReadBufferInt(sid_ctx, &buf, &len) == -1)
         return -1;
@@ -7723,7 +7679,7 @@ int ssl_set_session_id_context(SSL *ssl, PyObject *sid_ctx) {
 
 int ssl_set_fd(SSL *ssl, int fd) {
     int ret;
-
+    
     if (!(ret = SSL_set_fd(ssl, fd))) {
         m2_PyErr_Msg(_ssl_err);
         return -1;
@@ -7750,14 +7706,14 @@ static void ssl_handle_error(int ssl_err, int ret) {
             else
                 assert(0);
             break;
-        default:
+		default:
             PyErr_SetString(_ssl_err, "unexpected SSL error");
      }
 }
 
-#ifdef _WIN32
+#ifdef _MSC_VER
 /* http://stackoverflow.com/questions/10905892/equivalent-of-gettimeday-for-windows */
-int gettimeofday(struct timeval *tp, void *tzp)
+int gettimeofday(struct timeval * tp, struct timezone * tzp)
 {
     // Note: some broken versions only have 8 trailing zero's, the correct epoch has 9 trailing zero's
     static const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);
@@ -7779,11 +7735,7 @@ int gettimeofday(struct timeval *tp, void *tzp)
 
 static int ssl_sleep_with_timeout(SSL *ssl, const struct timeval *start,
                                   double timeout, int ssl_err) {
-#ifdef _WIN32
-WSAPOLLFD fd;
-#else
-struct pollfd fd;
-#endif
+    struct pollfd fd;
     struct timeval tv;
     int ms, tmp;
 
@@ -7829,7 +7781,7 @@ struct pollfd fd;
         return -1;
     }
     Py_BEGIN_ALLOW_THREADS
-#ifdef _WIN32
+#ifdef _MSC_VER
     tmp = WSAPoll(&fd, 1, ms);
 #else
     tmp = poll(&fd, 1, ms);
@@ -7841,7 +7793,7 @@ struct pollfd fd;
     	case 0:
             goto timeout;
     	case -1:
-#ifdef _WIN32
+#ifdef _MSC_VER
             if (WSAGetLastError() == EINTR)
 #else
             if (errno == EINTR)
@@ -7874,12 +7826,12 @@ PyObject *ssl_accept(SSL *ssl, double timeout) {
     switch (ssl_err) {
         case SSL_ERROR_NONE:
         case SSL_ERROR_ZERO_RETURN:
-            obj = PyLong_FromLong((long)1);
+            obj = PyInt_FromLong((long)1);
             break;
         case SSL_ERROR_WANT_WRITE:
         case SSL_ERROR_WANT_READ:
             if (timeout <= 0) {
-                obj = PyLong_FromLong((long)0);
+                obj = PyInt_FromLong((long)0);
                 break;
             }
             if (ssl_sleep_with_timeout(ssl, &tv, timeout, ssl_err) == 0)
@@ -7914,12 +7866,12 @@ PyObject *ssl_connect(SSL *ssl, double timeout) {
     switch (ssl_err) {
         case SSL_ERROR_NONE:
         case SSL_ERROR_ZERO_RETURN:
-            obj = PyLong_FromLong((long)1);
+            obj = PyInt_FromLong((long)1);
             break;
         case SSL_ERROR_WANT_WRITE:
         case SSL_ERROR_WANT_READ:
             if (timeout <= 0) {
-                obj = PyLong_FromLong((long)0);
+                obj = PyInt_FromLong((long)0);
                 break;
             }
             if (ssl_sleep_with_timeout(ssl, &tv, timeout, ssl_err) == 0)
@@ -7962,7 +7914,11 @@ PyObject *ssl_read(SSL *ssl, int num, double timeout) {
 
     if (r >= 0) {
         buf = PyMem_Realloc(buf, r);
+#if PY_MAJOR_VERSION >= 3
         obj = PyBytes_FromStringAndSize(buf, r);
+#else
+        obj = PyString_FromStringAndSize(buf, r);
+#endif //PY_MAJOR_VERSION >= 3
     } else {
         int ssl_err;
 
@@ -8007,19 +7963,23 @@ PyObject *ssl_read_nbio(SSL *ssl, int num) {
         PyErr_SetString(PyExc_MemoryError, "ssl_read");
         return NULL;
     }
-
-
+    
+    
     Py_BEGIN_ALLOW_THREADS
     r = SSL_read(ssl, buf, num);
     Py_END_ALLOW_THREADS
-
-
+    
+    
     switch (SSL_get_error(ssl, r)) {
         case SSL_ERROR_NONE:
         case SSL_ERROR_ZERO_RETURN:
             buf = PyMem_Realloc(buf, r);
 
+#if PY_MAJOR_VERSION >= 3
             obj = PyBytes_FromStringAndSize(buf, r);
+#else
+            obj = PyString_FromStringAndSize(buf, r);
+#endif // PY_MAJOR_VERSION >= 3
 
             break;
         case SSL_ERROR_WANT_WRITE:
@@ -8044,8 +8004,8 @@ PyObject *ssl_read_nbio(SSL *ssl, int num) {
             break;
     }
     PyMem_Free(buf);
-
-
+    
+    
     return obj;
 }
 
@@ -8090,7 +8050,7 @@ int ssl_write(SSL *ssl, PyObject *blob, double timeout) {
         default:
             ret = -1;
     }
-
+    
     m2_PyBuffer_Release(blob, &buf);
     return ret;
 }
@@ -8104,12 +8064,12 @@ int ssl_write_nbio(SSL *ssl, PyObject *blob) {
         return -1;
     }
 
-
+    
     Py_BEGIN_ALLOW_THREADS
     r = SSL_write(ssl, buf.buf, buf.len);
     Py_END_ALLOW_THREADS
-
-
+    
+    
     switch (SSL_get_error(ssl, r)) {
         case SSL_ERROR_NONE:
         case SSL_ERROR_ZERO_RETURN:
@@ -8134,7 +8094,7 @@ int ssl_write_nbio(SSL *ssl, PyObject *blob) {
         default:
             ret = -1;
     }
-
+    
     m2_PyBuffer_Release(blob, &buf);
     return ret;
 }
@@ -8214,16 +8174,6 @@ ASN1_ITEM_TEMPLATE_END(SEQ_CERT)
 IMPLEMENT_ASN1_FUNCTIONS(SEQ_CERT)
 
 
-X509 *x509_read_pem(BIO *bio) {
-    return PEM_read_bio_X509(bio, NULL, NULL, NULL);
-}
-
-
-X509 *d2i_x509(BIO *bio) {
-    return d2i_X509_bio(bio, NULL);
-}
-
-
 static PyObject *_x509_err;
 
 void x509_init(PyObject *x509_err) {
@@ -8232,17 +8182,22 @@ void x509_init(PyObject *x509_err) {
 }
 
 
-X509_REQ *d2i_x509_req(BIO *bio) {
-    return d2i_X509_REQ_bio(bio, NULL);
+X509 *x509_read_pem(BIO *bio) {
+    return PEM_read_bio_X509(bio, NULL, NULL, NULL);
 }
 
 
-X509_REQ *x509_req_read_pem(BIO *bio) {
-    return PEM_read_bio_X509_REQ(bio, NULL, NULL, NULL);
+X509 *d2i_x509(BIO *bio) {
+    return d2i_X509_bio(bio, NULL);
 }
 
 
-PyObject *i2d_x509(X509 *x) {
+X509_REQ *d2i_x509_req(BIO *bio) {
+    return d2i_X509_REQ_bio(bio, NULL);
+}
+
+PyObject *i2d_x509(X509 *x)
+{
     int len;
     PyObject *ret = NULL;
     unsigned char *buf = NULL;
@@ -8250,9 +8205,13 @@ PyObject *i2d_x509(X509 *x) {
     if (len < 0) {
         m2_PyErr_Msg(_x509_err);
     }
-    else {
+    else {     
 
+#if PY_MAJOR_VERSION >= 3 
         ret = PyBytes_FromStringAndSize((char*)buf, len);
+#else
+        ret = PyString_FromStringAndSize((char*)buf, len);
+#endif // PY_MAJOR_VERSION >= 3 
 
         OPENSSL_free(buf);
     }
@@ -8260,6 +8219,11 @@ PyObject *i2d_x509(X509 *x) {
 }
 
 
+X509_REQ *x509_req_read_pem(BIO *bio) {
+    return PEM_read_bio_X509_REQ(bio, NULL, NULL, NULL);
+}
+
+
 int x509_req_write_pem(BIO *bio, X509_REQ *x) {
     return PEM_write_bio_X509_REQ(bio, x);
 }
@@ -8269,7 +8233,6 @@ X509_CRL *x509_crl_read_pem(BIO *bio) {
     return PEM_read_bio_X509_CRL(bio, NULL, NULL, NULL);
 }
 
-
 /* X509_set_version() is a macro. */
 int x509_set_version(X509 *x, long version) {
     return X509_set_version(x, version);
@@ -8324,14 +8287,23 @@ PyObject *x509_name_by_nid(X509_NAME *name, int nid) {
     }
     xlen = X509_NAME_get_text_by_NID(name, nid, buf, len);
 
+/* FIXME Shouldn’t we have here casting to (char *) as well? */
+#if PY_MAJOR_VERSION >= 3 
     ret = PyBytes_FromStringAndSize(buf, xlen);
+#else
+    ret = PyString_FromStringAndSize(buf, xlen);
+#endif // PY_MAJOR_VERSION >= 3 
 
     PyMem_Free(buf);
     return ret;
 }
 
 int x509_name_set_by_nid(X509_NAME *name, int nid, PyObject *obj) {
+#if PY_MAJOR_VERSION >= 3 
     return X509_NAME_add_entry_by_NID(name, nid, MBSTRING_ASC, (unsigned char *)PyBytes_AsString(obj), -1, -1, 0);
+#else
+    return X509_NAME_add_entry_by_NID(name, nid, MBSTRING_ASC, (unsigned char *)PyString_AsString(obj), -1, -1, 0);
+#endif // PY_MAJOR_VERSION >= 3 
 }
 
 /* x509_name_add_entry_by_txt */
@@ -8339,7 +8311,8 @@ int x509_name_add_entry_by_txt(X509_NAME *name, char *field, int type, char *byt
     return X509_NAME_add_entry_by_txt(name, field, type, (unsigned char *)bytes, len, loc, set);
 }
 
-PyObject *x509_name_get_der(X509_NAME *name) {
+PyObject *x509_name_get_der(X509_NAME *name)
+{
     const char* pder="";
     size_t pderlen;
     i2d_X509_NAME(name, 0);
@@ -8347,7 +8320,16 @@ PyObject *x509_name_get_der(X509_NAME *name) {
         m2_PyErr_Msg(_x509_err);
         return NULL;
     }
+#if PY_MAJOR_VERSION >= 3 
     return PyBytes_FromStringAndSize(pder, pderlen);
+#else
+    return PyString_FromStringAndSize(pder, pderlen);
+#endif // PY_MAJOR_VERSION >= 3 
+}
+
+/* sk_X509_new_null() is a macro returning "STACK_OF(X509) *". */
+STACK_OF(X509) *sk_x509_new_null(void) {
+    return sk_X509_new_null();
 }
 
 /* sk_X509_free() is a macro. */
@@ -8365,14 +8347,8 @@ X509 *sk_x509_pop(STACK_OF(X509) *stack) {
     return sk_X509_pop(stack);
 }
 
-
 int x509_store_load_locations(X509_STORE *store, const char *file) {
-    int locations = 0;
-
-    if ((locations = X509_STORE_load_locations(store, file, NULL)) < 1) {
-        m2_PyErr_Msg(_x509_err);
-    }
-    return locations;
+    return X509_STORE_load_locations(store, file, NULL);
 }
 
 int x509_type_check(X509 *x509) {
@@ -8403,7 +8379,6 @@ X509_NAME_ENTRY *x509_name_entry_create_by_txt(X509_NAME_ENTRY **ne, char *field
     return X509_NAME_ENTRY_create_by_txt( ne, field, type, (unsigned char *)bytes, len);
 }
 
-
 X509V3_CTX *
 x509v3_set_nconf(void) {
       X509V3_CTX * ctx;
@@ -8413,21 +8388,18 @@ x509v3_set_nconf(void) {
           PyErr_SetString(PyExc_MemoryError, "x509v3_set_nconf");
           return NULL;
       }
-      /* X509V3_set_nconf does not generate any error signs at all. */
       X509V3_set_nconf(ctx, conf);
       return ctx;
 }
 
-
 X509_EXTENSION *
 x509v3_ext_conf(void *conf, X509V3_CTX *ctx, char *name, char *value) {
       X509_EXTENSION * ext = NULL;
-      ext = X509V3_EXT_conf(conf, ctx, name, value);
-      PyMem_Free(ctx);
+      ext = X509V3_EXT_conf(conf, ctx, name, value); 
+      PyMem_Free(ctx); 
       return ext;
 }
 
-
 /* X509_EXTENSION_free() might be a macro, didn't find definition. */
 void x509_extension_free(X509_EXTENSION *ext) {
     X509_EXTENSION_free(ext);
@@ -8435,13 +8407,17 @@ void x509_extension_free(X509_EXTENSION *ext) {
 
 PyObject *x509_extension_get_name(X509_EXTENSION *ext) {
     PyObject * ext_name;
-    const char * ext_name_str;
+    const char * ext_name_str; 
     ext_name_str = OBJ_nid2sn(OBJ_obj2nid(X509_EXTENSION_get_object(ext)));
     if (!ext_name_str) {
         m2_PyErr_Msg(_x509_err);
         return NULL;
     }
+#if PY_MAJOR_VERSION >= 3 
     ext_name = PyBytes_FromStringAndSize(ext_name_str, strlen(ext_name_str));
+#else
+    ext_name = PyString_FromStringAndSize(ext_name_str, strlen(ext_name_str));
+#endif // PY_MAJOR_VERSION >= 3 
     return ext_name;
 }
 
@@ -8492,63 +8468,66 @@ void x509_store_set_verify_cb(X509_STORE *store, PyObject *pyfunc) {
     X509_STORE_set_verify_cb(store, x509_store_verify_callback);
 }
 
-
 STACK_OF(X509) *
 make_stack_from_der_sequence(PyObject * pyEncodedString){
     STACK_OF(X509) *certs;
     Py_ssize_t encoded_string_len;
     char *encoded_string;
-    const unsigned char *tmp_str;
 
+#if PY_MAJOR_VERSION >= 3 
     encoded_string_len = PyBytes_Size(pyEncodedString);
+#else
+    encoded_string_len = PyString_Size(pyEncodedString);
+#endif
 
     if (encoded_string_len > INT_MAX) {
-        PyErr_Format(_x509_err, "object too large");
+        PyErr_SetString(PyExc_ValueError, "object too large");
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3 
     encoded_string = PyBytes_AsString(pyEncodedString);
+#else
+    encoded_string = PyString_AsString(pyEncodedString);
+#endif 
 
     if (!encoded_string) {
-        PyErr_SetString(_x509_err,
-                        "Cannot convert Python Bytes to (char *).");
         return NULL;
     }
 
-    tmp_str = (unsigned char *)encoded_string;
+    const unsigned char *tmp_str = (unsigned char *)encoded_string;
     certs = d2i_SEQ_CERT(NULL, &tmp_str, encoded_string_len);
-    if (certs == NULL) {
-        PyErr_SetString(_x509_err, "Generating STACK_OF(X509) failed.");
+    if (!certs) {
+        m2_PyErr_Msg(_x509_err);
         return NULL;
     }
-    return certs;
-}
 
-/* sk_X509_new_null() is a macro returning "STACK_OF(X509) *". */
-STACK_OF(X509) *sk_x509_new_null(void) {
-    return sk_X509_new_null();
+    return certs;
 }
 
-
 PyObject *
 get_der_encoding_stack(STACK_OF(X509) *stack){
     PyObject * encodedString;
-
+    
     unsigned char * encoding = NULL;
-    int len;
-
+    int len; 
+    
     len = i2d_SEQ_CERT(stack, &encoding);
     if (!encoding) {
        m2_PyErr_Msg(_x509_err);
        return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3 
     encodedString = PyBytes_FromStringAndSize((const char *)encoding, len);
+#else
+    encodedString = PyString_FromStringAndSize((const char *)encoding, len);
+#endif // PY_MAJOR_VERSION >= 3 
 
     if (encoding)
         OPENSSL_free(encoding);
 
-    return encodedString;
+    return encodedString; 
 }
 
 
@@ -8599,10 +8578,6 @@ int asn1_integer_set(ASN1_INTEGER *asn1, PyObject *value) {
     BIGNUM *bn = NULL;
     PyObject *fmt, *args, *hex;
 
-/* Despite all hopes to the contrary, we cannot survive here with
- * PyLong_AsLong shims as provided in
- * /usr/include/python2.7/longobject.h.
- */
 #if PY_MAJOR_VERSION >= 3
     if (PyLong_Check(value))
         return ASN1_INTEGER_set(asn1, PyLong_AsLong(value));
@@ -8683,6 +8658,10 @@ void smime_init(PyObject *smime_err) {
 }
 
 
+PKCS7 *pkcs7_encrypt(STACK_OF(X509) *stack, BIO *bio, EVP_CIPHER *cipher, int flags) {
+    return PKCS7_encrypt(stack, bio, cipher, flags);
+}
+
 PyObject *pkcs7_decrypt(PKCS7 *pkcs7, EVP_PKEY *pkey, X509 *cert, int flags) {
     int outlen;
     char *outbuf;
@@ -8706,7 +8685,11 @@ PyObject *pkcs7_decrypt(PKCS7 *pkcs7, EVP_PKEY *pkey, X509 *cert, int flags) {
     }
     BIO_read(bio, outbuf, outlen);
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(outbuf, outlen);
+#else
+    ret = PyString_FromStringAndSize(outbuf, outlen);
+#endif // PY_MAJOR_VERSION >= 3
 
     BIO_free(bio);
     PyMem_Free(outbuf);
@@ -8714,22 +8697,19 @@ PyObject *pkcs7_decrypt(PKCS7 *pkcs7, EVP_PKEY *pkey, X509 *cert, int flags) {
 }
 
 
-PKCS7 *pkcs7_encrypt(STACK_OF(X509) *stack, BIO *bio, EVP_CIPHER *cipher, int flags) {
-    return PKCS7_encrypt(stack, bio, cipher, flags);
-}
-
-
-
 PKCS7 *pkcs7_sign1(X509 *x509, EVP_PKEY *pkey, STACK_OF(X509) *stack, BIO *bio, EVP_MD *hash, int flags) {
 
     PKCS7 *p7 = PKCS7_sign(NULL, NULL, stack, bio, flags | PKCS7_STREAM);
     if (p7 == NULL) {
+        m2_PyErr_Msg(_pkcs7_err);
         return NULL;
     }
     if (PKCS7_sign_add_signer(p7, x509, pkey, hash, flags) == NULL) {
+        m2_PyErr_Msg(_pkcs7_err);
         return NULL;
     }
     if (PKCS7_final(p7, bio, flags) != 1) {
+        m2_PyErr_Msg(_pkcs7_err);
         return NULL;
     }
     return p7;
@@ -8741,16 +8721,6 @@ PKCS7 *pkcs7_sign0(X509 *x509, EVP_PKEY *pkey, BIO *bio, EVP_MD *hash, int flags
 }
 
 
-PKCS7 *pkcs7_read_bio(BIO *bio) {
-    return PEM_read_bio_PKCS7(bio, NULL, NULL, NULL);
-}
-
-
-PKCS7 *pkcs7_read_bio_der(BIO *bio) {
-    return d2i_PKCS7_bio(bio, NULL);
-}
-
-
 PyObject *pkcs7_verify1(PKCS7 *pkcs7, STACK_OF(X509) *stack, X509_STORE *store, BIO *data, int flags) {
     int res, outlen;
     char *outbuf;
@@ -8777,7 +8747,11 @@ PyObject *pkcs7_verify1(PKCS7 *pkcs7, STACK_OF(X509) *stack, X509_STORE *store,
     }
     BIO_read(bio, outbuf, outlen);
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(outbuf, outlen);
+#else
+    ret = PyString_FromStringAndSize(outbuf, outlen);
+#endif // PY_MAJOR_VERSION >= 3
 
     BIO_free(bio);
     PyMem_Free(outbuf);
@@ -8836,6 +8810,16 @@ PyObject *smime_read_pkcs7(BIO *bio) {
 }
 
 
+PKCS7 *pkcs7_read_bio(BIO *bio) {
+    return PEM_read_bio_PKCS7(bio, NULL, NULL, NULL);
+}
+
+
+PKCS7 *pkcs7_read_bio_der(BIO *bio) {
+    return d2i_PKCS7_bio(bio, NULL);
+}
+
+
 int pkcs7_write_bio(PKCS7 *pkcs7, BIO* bio) {
     return PEM_write_bio_PKCS7(bio, pkcs7);
 }
@@ -8890,7 +8874,11 @@ PyObject *util_hex_to_string(PyObject *blob) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     obj = PyBytes_FromString(ret);
+#else
+    obj = PyString_FromString(ret);
+#endif // PY_MAJOR_VERSION >= 3
 
     OPENSSL_free(ret);
     return obj;
@@ -8912,7 +8900,11 @@ PyObject *util_string_to_hex(PyObject *blob) {
         m2_PyErr_Msg(_util_err);
         return NULL;
     }
+#if PY_MAJOR_VERSION >= 3
     obj = PyBytes_FromStringAndSize((char*)ret, len);
+#else
+    obj = PyString_FromStringAndSize((char*)ret, len);
+#endif // PY_MAJOR_VERSION >= 3
     OPENSSL_free(ret);
     return obj;
 }
@@ -9025,12 +9017,16 @@ EC_KEY* ec_key_new_by_curve_name(int nid)
 }
 
 PyObject *ec_key_get_public_der(EC_KEY *key) {
-    char *src=NULL;
+
+    unsigned char *src=NULL;
+    void *dst=NULL;
     int src_len=0;
+    Py_ssize_t dst_len=0;
     PyObject *pyo=NULL;
+    int ret=0;
 
     /* Convert to binary */
-    src_len = i2d_EC_PUBKEY( key, (unsigned char**)&src );
+    src_len = i2d_EC_PUBKEY( key, &src );
     if (src_len < 0)
     {
         m2_PyErr_Msg(_ec_err);
@@ -9039,7 +9035,22 @@ PyObject *ec_key_get_public_der(EC_KEY *key) {
     /* Create a PyBuffer containing a copy of the binary,
      * to simplify memory deallocation
      */
+#if PY_MAJOR_VERSION >= 3
     pyo = PyBytes_FromStringAndSize( src, src_len );
+#else
+    pyo = PyBuffer_New( src_len );
+    ret = PyObject_AsWriteBuffer( pyo, &dst, &dst_len );
+    assert( src_len == dst_len );
+    if (ret < 0)
+    {
+        Py_DECREF(pyo);
+        OPENSSL_free(src);
+        PyErr_SetString(_ec_err, "cannot get write buffer");
+        return NULL;
+    }
+    memcpy( dst, src, src_len );
+
+#endif // PY_MAJOR_VERSION == 2
 
     OPENSSL_free(src);
 
@@ -9047,19 +9058,41 @@ PyObject *ec_key_get_public_der(EC_KEY *key) {
 }
 
 PyObject *ec_key_get_public_key(EC_KEY *key) {
-    char *src=NULL;
+
+    unsigned char *src=NULL;
+    void *dst=NULL;
     int src_len=0;
+    Py_ssize_t dst_len=0;
     PyObject *pyo=NULL;
+    int ret=0;
 
     /* Convert to binary */
-    src_len = i2o_ECPublicKey(key, (unsigned char**)&src);
+    src_len = i2o_ECPublicKey(key, &src);
     if (src_len < 0)
     {
         m2_PyErr_Msg(_ec_err);
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     pyo = PyBytes_FromStringAndSize( src, src_len );
+#else
+    /* Create a PyBuffer containing a copy of the binary,
+     * to simplify memory deallocation
+     */
+    pyo = PyBuffer_New( src_len );
+    ret = PyObject_AsWriteBuffer( pyo, &dst, &dst_len );
+    assert( src_len == dst_len );
+    if (ret < 0)
+    {
+        Py_DECREF(pyo);
+        OPENSSL_free(src);
+        PyErr_SetString(_ec_err, "cannot get write buffer");
+        return NULL;
+    }
+    memcpy( dst, src, src_len );
+
+#endif // PY_MAJOR_VERSION == 2
 
     OPENSSL_free(src);
 
@@ -9130,7 +9163,7 @@ PyObject *ecdsa_sig_get_s(ECDSA_SIG *ecdsa_sig) {
 
 PyObject *ecdsa_sign(EC_KEY *key, PyObject *value) {
     const void *vbuf;
-    int vlen = 0;
+    int vlen;
     PyObject *tuple;
     ECDSA_SIG *sig;
 
@@ -9154,7 +9187,7 @@ PyObject *ecdsa_sign(EC_KEY *key, PyObject *value) {
 
 int ecdsa_verify(EC_KEY *key, PyObject *value, PyObject *r, PyObject *s) {
     const void *vbuf, *rbuf, *sbuf;
-    int vlen = 0, rlen = 0, slen = 0;
+    int vlen, rlen, slen;
     ECDSA_SIG *sig;
     int ret;
     BIGNUM* pr, *ps;
@@ -9197,7 +9230,7 @@ int ecdsa_verify(EC_KEY *key, PyObject *value, PyObject *r, PyObject *s) {
 
 PyObject *ecdsa_sign_asn1(EC_KEY *key, PyObject *value) {
     const void *vbuf;
-    int vlen = 0;
+    int vlen;
     void *sigbuf;
     unsigned int siglen;
     PyObject *ret;
@@ -9214,7 +9247,11 @@ PyObject *ecdsa_sign_asn1(EC_KEY *key, PyObject *value) {
         PyMem_Free(sigbuf);
         return NULL;
     }
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(sigbuf, siglen);
+#else
+    ret = PyString_FromStringAndSize(sigbuf, siglen);
+#endif // PY_MAJOR_VERSION == 2
 
     PyMem_Free(sigbuf);
     return ret;
@@ -9224,7 +9261,7 @@ PyObject *ecdsa_sign_asn1(EC_KEY *key, PyObject *value) {
 int ecdsa_verify_asn1(EC_KEY *key, PyObject *value, PyObject *sig) {
     const void *vbuf;
     void *sbuf;
-    int vlen = 0, slen = 0, ret;
+    int vlen, slen, ret;
 
     if ((m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         || (m2_PyObject_AsReadBufferInt(sig, (const void **)&sbuf, &slen)
@@ -9262,7 +9299,11 @@ PyObject *ecdh_compute_key(EC_KEY *keypairA, EC_KEY *pubkeyB) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((const char *)sharedkey, sharedkeylen);
+#else
+    ret = PyString_FromStringAndSize((const char *)sharedkey, sharedkeylen);
+#endif // PY_MAJOR_VERSION == 2
 
     PyMem_Free(sharedkey);
 
@@ -9469,7 +9510,11 @@ PyObject *obj_obj2txt(const ASN1_OBJECT *obj, int no_name)
     buf = PyMem_Malloc(len + 1);
     len = OBJ_obj2txt(buf, len + 1, obj, no_name);
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(buf, len);
+#else
+    ret = PyString_FromStringAndSize(buf, len);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(buf);
 
@@ -10908,17 +10953,55 @@ fail:
 }
 
 
-SWIGINTERN PyObject *_wrap_bio_free_all(PyObject *self, PyObject *args) {
+SWIGINTERN PyObject *_wrap_bio_new_file(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  char *arg2 = (char *) 0 ;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  int res2 ;
+  char *buf2 = 0 ;
+  int alloc2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  BIO *result = 0 ;
+  
+  if(!PyArg_UnpackTuple(args,(char *)"bio_new_file",2,2,&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "bio_new_file" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "bio_new_file" "', argument " "2"" of type '" "char const *""'");
+  }
+  arg2 = (char *)(buf2);
+  result = (BIO *)BIO_new_file((char const *)arg1,(char const *)arg2);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_BIO, 0 |  0 );
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_bio_free(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   BIO *arg1 = (BIO *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
+  int result;
   
-  if(!PyArg_UnpackTuple(args,(char *)"bio_free_all",1,1,&obj0)) SWIG_fail;
+  if(!PyArg_UnpackTuple(args,(char *)"bio_free",1,1,&obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "bio_free_all" "', argument " "1"" of type '" "BIO *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "bio_free" "', argument " "1"" of type '" "BIO *""'"); 
   }
   arg1 = (BIO *)(argp1);
   {
@@ -10928,7 +11011,40 @@ SWIGINTERN PyObject *_wrap_bio_free_all(PyObject *self, PyObject *args) {
   }
   {
     SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-    BIO_free_all(arg1);
+    result = (int)BIO_free(arg1);
+    SWIG_PYTHON_THREAD_END_ALLOW;
+  }
+  {
+    resultobj=PyInt_FromLong(result);
+    if (PyErr_Occurred()) SWIG_fail;
+  }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_bio_free_all(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0;
+  BIO *arg1 = (BIO *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if(!PyArg_UnpackTuple(args,(char *)"bio_free_all",1,1,&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "bio_free_all" "', argument " "1"" of type '" "BIO *""'"); 
+  }
+  arg1 = (BIO *)(argp1);
+  {
+    if (!arg1) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  {
+    SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+    BIO_free_all(arg1);
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   resultobj = SWIG_Py_Void();
@@ -11033,36 +11149,6 @@ fail:
 }
 
 
-SWIGINTERN PyObject *_wrap_bio_eof(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  BIO *arg1 = (BIO *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"bio_eof",1,1,&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "bio_eof" "', argument " "1"" of type '" "BIO *""'"); 
-  }
-  arg1 = (BIO *)(argp1);
-  {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  result = (int)BIO_eof(arg1);
-  {
-    resultobj=PyLong_FromLong(result);
-    if (PyErr_Occurred()) SWIG_fail;
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
 SWIGINTERN int Swig_var__bio_err_set(PyObject *_val) {
   {
     void *argp = 0;
@@ -11088,17 +11174,6 @@ SWIGINTERN PyObject *Swig_var__bio_err_get(void) {
 }
 
 
-SWIGINTERN PyObject *_wrap_pyfd_init(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  
-  pyfd_init();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
 SWIGINTERN PyObject *_wrap_bio_init(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   PyObject *arg1 = (PyObject *) 0 ;
@@ -11116,73 +11191,6 @@ fail:
 }
 
 
-SWIGINTERN PyObject *_wrap_bio_free(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  BIO *arg1 = (BIO *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"bio_free",1,1,&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "bio_free" "', argument " "1"" of type '" "BIO *""'"); 
-  }
-  arg1 = (BIO *)(argp1);
-  {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  result = (int)bio_free(arg1);
-  {
-    resultobj=PyLong_FromLong(result);
-    if (PyErr_Occurred()) SWIG_fail;
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_bio_new_file(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  char *arg2 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  BIO *result = 0 ;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"bio_new_file",2,2,&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "bio_new_file" "', argument " "1"" of type '" "char const *""'");
-  }
-  arg1 = (char *)(buf1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "bio_new_file" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = (char *)(buf2);
-  result = (BIO *)bio_new_file((char const *)arg1,(char const *)arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_BIO, 0 |  0 );
-  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
-  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
-  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
-  return NULL;
-}
-
-
 SWIGINTERN PyObject *_wrap_bio_new_pyfile(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   PyObject *arg1 = (PyObject *) 0 ;
@@ -11312,7 +11320,7 @@ SWIGINTERN PyObject *_wrap_bio_write(PyObject *self, PyObject *args) {
   }
   result = (int)bio_write(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11342,7 +11350,7 @@ SWIGINTERN PyObject *_wrap_bio_ctrl_pending(PyObject *self, PyObject *args) {
   }
   result = (int)bio_ctrl_pending(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11372,7 +11380,7 @@ SWIGINTERN PyObject *_wrap_bio_ctrl_wpending(PyObject *self, PyObject *args) {
   }
   result = (int)bio_ctrl_wpending(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11402,7 +11410,7 @@ SWIGINTERN PyObject *_wrap_bio_ctrl_get_write_guarantee(PyObject *self, PyObject
   }
   result = (int)bio_ctrl_get_write_guarantee(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11432,7 +11440,7 @@ SWIGINTERN PyObject *_wrap_bio_reset(PyObject *self, PyObject *args) {
   }
   result = (int)bio_reset(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11466,7 +11474,7 @@ SWIGINTERN PyObject *_wrap_bio_flush(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11505,7 +11513,7 @@ SWIGINTERN PyObject *_wrap_bio_seek(PyObject *self, PyObject *args) {
   }
   result = (int)bio_seek(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11535,7 +11543,7 @@ SWIGINTERN PyObject *_wrap_bio_tell(PyObject *self, PyObject *args) {
   }
   result = (int)bio_tell(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11600,7 +11608,7 @@ SWIGINTERN PyObject *_wrap_bio_get_flags(PyObject *self, PyObject *args) {
   }
   result = (int)bio_get_flags(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11696,7 +11704,7 @@ SWIGINTERN PyObject *_wrap_bio_set_mem_eof_return(PyObject *self, PyObject *args
   }
   result = (int)bio_set_mem_eof_return(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11726,7 +11734,7 @@ SWIGINTERN PyObject *_wrap_bio_get_fd(PyObject *self, PyObject *args) {
   }
   result = (int)bio_get_fd(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11760,7 +11768,7 @@ SWIGINTERN PyObject *_wrap_bio_do_handshake(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11804,7 +11812,7 @@ SWIGINTERN PyObject *_wrap_bio_make_bio_pair(PyObject *self, PyObject *args) {
   }
   result = (int)bio_make_bio_pair(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11843,7 +11851,7 @@ SWIGINTERN PyObject *_wrap_bio_set_write_buf_size(PyObject *self, PyObject *args
   }
   result = (int)bio_set_write_buf_size(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11873,7 +11881,7 @@ SWIGINTERN PyObject *_wrap_bio_should_retry(PyObject *self, PyObject *args) {
   }
   result = (int)bio_should_retry(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11903,7 +11911,7 @@ SWIGINTERN PyObject *_wrap_bio_should_read(PyObject *self, PyObject *args) {
   }
   result = (int)bio_should_read(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11933,7 +11941,7 @@ SWIGINTERN PyObject *_wrap_bio_should_write(PyObject *self, PyObject *args) {
   }
   result = (int)bio_should_write(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -11942,663 +11950,157 @@ fail:
 }
 
 
-SWIGINTERN PyObject *_wrap_BIO_meth_new(PyObject *self, PyObject *args) {
+SWIGINTERN PyObject *_wrap_bn_rand(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   int arg1 ;
-  char *arg2 = (char *) 0 ;
+  int arg2 ;
+  int arg3 ;
   int val1 ;
   int ecode1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
-  BIO_METHOD *result = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject *result = 0 ;
   
-  if(!PyArg_UnpackTuple(args,(char *)"BIO_meth_new",2,2,&obj0,&obj1)) SWIG_fail;
+  if(!PyArg_UnpackTuple(args,(char *)"bn_rand",3,3,&obj0,&obj1,&obj2)) SWIG_fail;
   ecode1 = SWIG_AsVal_int(obj0, &val1);
   if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "BIO_meth_new" "', argument " "1"" of type '" "int""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "bn_rand" "', argument " "1"" of type '" "int""'");
   } 
   arg1 = (int)(val1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BIO_meth_new" "', argument " "2"" of type '" "char const *""'");
+  ecode2 = SWIG_AsVal_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "bn_rand" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = (int)(val2);
+  ecode3 = SWIG_AsVal_int(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "bn_rand" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = (int)(val3);
+  result = (PyObject *)bn_rand(arg1,arg2,arg3);
+  {
+    resultobj=result;
   }
-  arg2 = (char *)(buf2);
-  result = (BIO_METHOD *)BIO_meth_new(arg1,(char const *)arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_BIO_METHOD, 0 |  0 );
-  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
   return resultobj;
 fail:
-  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_BIO_meth_free(PyObject *self, PyObject *args) {
+SWIGINTERN PyObject *_wrap_bn_rand_range(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
-  BIO_METHOD *arg1 = (BIO_METHOD *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
+  PyObject *arg1 = (PyObject *) 0 ;
   PyObject * obj0 = 0 ;
+  PyObject *result = 0 ;
   
-  if(!PyArg_UnpackTuple(args,(char *)"BIO_meth_free",1,1,&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO_METHOD, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BIO_meth_free" "', argument " "1"" of type '" "BIO_METHOD *""'"); 
+  if(!PyArg_UnpackTuple(args,(char *)"bn_rand_range",1,1,&obj0)) SWIG_fail;
+  {
+    arg1=obj0;
   }
-  arg1 = (BIO_METHOD *)(argp1);
+  result = (PyObject *)bn_rand_range(arg1);
   {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
+    resultobj=result;
   }
-  BIO_meth_free(arg1);
-  resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_BIO_PYFD_CTX_fd_set(PyObject *self, PyObject *args) {
+SWIGINTERN PyObject *_wrap_rand_file_name__SWIG_0(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
-  struct pyfd_struct *arg1 = (struct pyfd_struct *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
+  char *arg1 = (char *) 0 ;
+  size_t arg2 ;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  size_t val2 ;
   int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
+  char *result = 0 ;
   
-  if(!PyArg_UnpackTuple(args,(char *)"BIO_PYFD_CTX_fd_set",1,1,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pyfd_struct, 0 |  0 );
+  if(!PyArg_UnpackTuple(args,(char *)"rand_file_name",2,2,&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BIO_PYFD_CTX_fd_set" "', argument " "1"" of type '" "struct pyfd_struct *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "rand_file_name" "', argument " "1"" of type '" "char *""'");
   }
-  arg1 = (struct pyfd_struct *)(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
+  arg1 = (char *)(buf1);
+  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BIO_PYFD_CTX_fd_set" "', argument " "2"" of type '" "int""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rand_file_name" "', argument " "2"" of type '" "size_t""'");
   } 
-  arg2 = (int)(val2);
-  if (arg1) (arg1)->fd = arg2;
-  resultobj = SWIG_Py_Void();
+  arg2 = (size_t)(val2);
+  result = (char *)RAND_file_name(arg1,arg2);
+  resultobj = SWIG_FromCharPtr((const char *)result);
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_BIO_PYFD_CTX_fd_get(PyObject *self, PyObject *args) {
+SWIGINTERN PyObject *_wrap_rand_load_file(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
-  struct pyfd_struct *arg1 = (struct pyfd_struct *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
+  char *arg1 = (char *) 0 ;
+  long arg2 ;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  long val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
   int result;
   
-  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pyfd_struct, 0 |  0 );
+  if(!PyArg_UnpackTuple(args,(char *)"rand_load_file",2,2,&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BIO_PYFD_CTX_fd_get" "', argument " "1"" of type '" "struct pyfd_struct *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "rand_load_file" "', argument " "1"" of type '" "char const *""'");
   }
-  arg1 = (struct pyfd_struct *)(argp1);
-  result = (int) ((arg1)->fd);
+  arg1 = (char *)(buf1);
+  ecode2 = SWIG_AsVal_long(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rand_load_file" "', argument " "2"" of type '" "long""'");
+  } 
+  arg2 = (long)(val2);
+  result = (int)RAND_load_file((char const *)arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return resultobj;
 fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
   return NULL;
 }
 
 
-SWIGINTERN int _wrap_new_BIO_PYFD_CTX(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  struct pyfd_struct *result = 0 ;
-  
-  result = (struct pyfd_struct *)calloc(1, sizeof(struct pyfd_struct));
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pyfd_struct, SWIG_BUILTIN_INIT |  0 );
-  return resultobj == Py_None ? -1 : 0;
-fail:
-  return -1;
-}
-
-
-SWIGINTERN PyObject *_wrap_delete_BIO_PYFD_CTX(PyObject *self, PyObject *args) {
+SWIGINTERN PyObject *_wrap_rand_save_file(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
-  struct pyfd_struct *arg1 = (struct pyfd_struct *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
+  char *arg1 = (char *) 0 ;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
+  int result;
   
-  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_pyfd_struct, SWIG_POINTER_DISOWN |  0 );
+  if(!PyArg_UnpackTuple(args,(char *)"rand_save_file",1,1,&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BIO_PYFD_CTX" "', argument " "1"" of type '" "struct pyfd_struct *""'"); 
-  }
-  arg1 = (struct pyfd_struct *)(argp1);
-  free((char *) arg1);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN int Swig_var_methods_fdp_set(PyObject *_val) {
-  {
-    void *argp = 0;
-    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_BIO_METHOD,  0 );  
-    if (!SWIG_IsOK(res)) {
-      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""methods_fdp""' of type '""BIO_METHOD *""'");
-    }
-    methods_fdp = (BIO_METHOD *)(argp);
-  }
-  return 0;
-fail:
-  return 1;
-}
-
-
-SWIGINTERN PyObject *Swig_var_methods_fdp_get(void) {
-  PyObject *pyobj = 0;
-  PyObject *self = 0;
-  
-  (void)self;
-  pyobj = SWIG_NewPointerObj(SWIG_as_voidptr(methods_fdp), SWIGTYPE_p_BIO_METHOD,  0 );
-  return pyobj;
-}
-
-
-SWIGINTERN PyObject *_wrap_pyfd_write(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  BIO *arg1 = (BIO *) 0 ;
-  char *arg2 = (char *) 0 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  int result;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"pyfd_write",3,3,&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyfd_write" "', argument " "1"" of type '" "BIO *""'"); 
-  }
-  arg1 = (BIO *)(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "pyfd_write" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = (char *)(buf2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "pyfd_write" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = (int)(val3);
-  {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  result = (int)pyfd_write(arg1,(char const *)arg2,arg3);
-  {
-    resultobj=PyLong_FromLong(result);
-    if (PyErr_Occurred()) SWIG_fail;
-  }
-  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_pyfd_read(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  BIO *arg1 = (BIO *) 0 ;
-  char *arg2 = (char *) 0 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  int result;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"pyfd_read",3,3,&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyfd_read" "', argument " "1"" of type '" "BIO *""'"); 
-  }
-  arg1 = (BIO *)(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "pyfd_read" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = (char *)(buf2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "pyfd_read" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = (int)(val3);
-  {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  result = (int)pyfd_read(arg1,arg2,arg3);
-  {
-    resultobj=PyLong_FromLong(result);
-    if (PyErr_Occurred()) SWIG_fail;
-  }
-  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_pyfd_puts(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  BIO *arg1 = (BIO *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  int result;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"pyfd_puts",2,2,&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyfd_puts" "', argument " "1"" of type '" "BIO *""'"); 
-  }
-  arg1 = (BIO *)(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "pyfd_puts" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = (char *)(buf2);
-  {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  result = (int)pyfd_puts(arg1,(char const *)arg2);
-  {
-    resultobj=PyLong_FromLong(result);
-    if (PyErr_Occurred()) SWIG_fail;
-  }
-  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_pyfd_gets(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  BIO *arg1 = (BIO *) 0 ;
-  char *arg2 = (char *) 0 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  int result;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"pyfd_gets",3,3,&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyfd_gets" "', argument " "1"" of type '" "BIO *""'"); 
-  }
-  arg1 = (BIO *)(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "pyfd_gets" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = (char *)(buf2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "pyfd_gets" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = (int)(val3);
-  {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  result = (int)pyfd_gets(arg1,arg2,arg3);
-  {
-    resultobj=PyLong_FromLong(result);
-    if (PyErr_Occurred()) SWIG_fail;
-  }
-  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_pyfd_new(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  BIO *arg1 = (BIO *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"pyfd_new",1,1,&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyfd_new" "', argument " "1"" of type '" "BIO *""'"); 
-  }
-  arg1 = (BIO *)(argp1);
-  {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  result = (int)pyfd_new(arg1);
-  {
-    resultobj=PyLong_FromLong(result);
-    if (PyErr_Occurred()) SWIG_fail;
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_pyfd_free(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  BIO *arg1 = (BIO *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"pyfd_free",1,1,&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyfd_free" "', argument " "1"" of type '" "BIO *""'"); 
-  }
-  arg1 = (BIO *)(argp1);
-  {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  result = (int)pyfd_free(arg1);
-  {
-    resultobj=PyLong_FromLong(result);
-    if (PyErr_Occurred()) SWIG_fail;
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_pyfd_ctrl(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  BIO *arg1 = (BIO *) 0 ;
-  int arg2 ;
-  long arg3 ;
-  void *arg4 = (void *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  long val3 ;
-  int ecode3 = 0 ;
-  int res4 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  long result;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"pyfd_ctrl",4,4,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyfd_ctrl" "', argument " "1"" of type '" "BIO *""'"); 
-  }
-  arg1 = (BIO *)(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "pyfd_ctrl" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = (int)(val2);
-  ecode3 = SWIG_AsVal_long(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "pyfd_ctrl" "', argument " "3"" of type '" "long""'");
-  } 
-  arg3 = (long)(val3);
-  res4 = SWIG_ConvertPtr(obj3,SWIG_as_voidptrptr(&arg4), 0, 0);
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "pyfd_ctrl" "', argument " "4"" of type '" "void *""'"); 
-  }
-  {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  result = (long)pyfd_ctrl(arg1,arg2,arg3,arg4);
-  resultobj = SWIG_From_long((long)(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_bio_new_pyfd(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  BIO *result = 0 ;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"bio_new_pyfd",2,2,&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "bio_new_pyfd" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = (int)(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "bio_new_pyfd" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = (int)(val2);
-  result = (BIO *)BIO_new_pyfd(arg1,arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_BIO, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_bn_rand(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  int arg3 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject *result = 0 ;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"bn_rand",3,3,&obj0,&obj1,&obj2)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "bn_rand" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = (int)(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "bn_rand" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = (int)(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "bn_rand" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = (int)(val3);
-  result = (PyObject *)bn_rand(arg1,arg2,arg3);
-  {
-    resultobj=result;
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_bn_rand_range(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  PyObject *arg1 = (PyObject *) 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject *result = 0 ;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"bn_rand_range",1,1,&obj0)) SWIG_fail;
-  {
-    arg1=obj0;
-  }
-  result = (PyObject *)bn_rand_range(arg1);
-  {
-    resultobj=result;
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_rand_file_name__SWIG_0(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  size_t arg2 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  char *result = 0 ;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"rand_file_name",2,2,&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "rand_file_name" "', argument " "1"" of type '" "char *""'");
-  }
-  arg1 = (char *)(buf1);
-  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rand_file_name" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = (size_t)(val2);
-  result = (char *)RAND_file_name(arg1,arg2);
-  resultobj = SWIG_FromCharPtr((const char *)result);
-  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_rand_load_file(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  long arg2 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  long val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  int result;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"rand_load_file",2,2,&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "rand_load_file" "', argument " "1"" of type '" "char const *""'");
-  }
-  arg1 = (char *)(buf1);
-  ecode2 = SWIG_AsVal_long(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rand_load_file" "', argument " "2"" of type '" "long""'");
-  } 
-  arg2 = (long)(val2);
-  result = (int)RAND_load_file((char const *)arg1,arg2);
-  {
-    resultobj=PyLong_FromLong(result);
-    if (PyErr_Occurred()) SWIG_fail;
-  }
-  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_rand_save_file(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"rand_save_file",1,1,&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "rand_save_file" "', argument " "1"" of type '" "char const *""'");
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "rand_save_file" "', argument " "1"" of type '" "char const *""'");
   }
   arg1 = (char *)(buf1);
   result = (int)RAND_write_file((char const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
@@ -12615,7 +12117,7 @@ SWIGINTERN PyObject *_wrap_rand_poll(PyObject *self, PyObject *args) {
   
   result = (int)RAND_poll();
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -12630,7 +12132,7 @@ SWIGINTERN PyObject *_wrap_rand_status(PyObject *self, PyObject *args) {
   
   result = (int)RAND_status();
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -12885,7 +12387,7 @@ SWIGINTERN PyObject *_wrap_rand_win32_event(PyObject *self, PyObject *args) {
   arg3 = (long)(val3);
   result = (int)rand_win32_event(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -13013,7 +12515,7 @@ SWIGINTERN PyObject *_wrap_digest_init(PyObject *self, PyObject *args) {
   }
   result = (int)EVP_DigestInit(arg1,(EVP_MD const *)arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -13022,6 +12524,31 @@ fail:
 }
 
 
+SWIGINTERN PyObject *_wrap_get_digestbyname(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0;
+  char *arg1 = (char *) 0 ;
+  int res1 ;
+  char *buf1 = 0 ;
+  int alloc1 = 0 ;
+  PyObject * obj0 = 0 ;
+  EVP_MD *result = 0 ;
+  
+  if(!PyArg_UnpackTuple(args,(char *)"get_digestbyname",1,1,&obj0)) SWIG_fail;
+  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "get_digestbyname" "', argument " "1"" of type '" "char const *""'");
+  }
+  arg1 = (char *)(buf1);
+  result = (EVP_MD *)EVP_get_digestbyname((char const *)arg1);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EVP_MD, 0 |  0 );
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return resultobj;
+fail:
+  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_des_ecb(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   EVP_CIPHER *result = 0 ;
@@ -13496,7 +13023,7 @@ SWIGINTERN PyObject *_wrap_cipher_set_padding(PyObject *self, PyObject *args) {
   }
   result = (int)EVP_CIPHER_CTX_set_padding(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -13505,6 +13032,18 @@ fail:
 }
 
 
+SWIGINTERN PyObject *_wrap_pkey_new(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0;
+  EVP_PKEY *result = 0 ;
+  
+  result = (EVP_PKEY *)EVP_PKEY_new();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EVP_PKEY, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_pkey_free(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   EVP_PKEY *arg1 = (EVP_PKEY *) 0 ;
@@ -13571,7 +13110,7 @@ SWIGINTERN PyObject *_wrap_pkey_assign(PyObject *self, PyObject *args) {
   }
   result = (int)EVP_PKEY_assign(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
@@ -13612,7 +13151,7 @@ SWIGINTERN PyObject *_wrap_pkey_assign_ec(PyObject *self, PyObject *args) {
   }
   result = (int)EVP_PKEY_assign_EC_KEY(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -13650,15 +13189,42 @@ SWIGINTERN PyObject *_wrap_pkey_set1_rsa(PyObject *self, PyObject *args) {
     }
   }
   {
-    if (!arg2) {
+    if (!arg2) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  result = (int)EVP_PKEY_set1_RSA(arg1,arg2);
+  {
+    resultobj=PyInt_FromLong(result);
+    if (PyErr_Occurred()) SWIG_fail;
+  }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_pkey_get1_rsa(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0;
+  EVP_PKEY *arg1 = (EVP_PKEY *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  RSA *result = 0 ;
+  
+  if(!PyArg_UnpackTuple(args,(char *)"pkey_get1_rsa",1,1,&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EVP_PKEY, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pkey_get1_rsa" "', argument " "1"" of type '" "EVP_PKEY *""'"); 
+  }
+  arg1 = (EVP_PKEY *)(argp1);
+  {
+    if (!arg1) {
       SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
     }
   }
-  result = (int)EVP_PKEY_set1_RSA(arg1,arg2);
-  {
-    resultobj=PyLong_FromLong(result);
-    if (PyErr_Occurred()) SWIG_fail;
-  }
+  result = (RSA *)EVP_PKEY_get1_RSA(arg1);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RSA, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
@@ -13700,7 +13266,7 @@ SWIGINTERN PyObject *_wrap_sign_init(PyObject *self, PyObject *args) {
   }
   result = (int)EVP_SignInit(arg1,(EVP_MD const *)arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -13744,7 +13310,7 @@ SWIGINTERN PyObject *_wrap_verify_init(PyObject *self, PyObject *args) {
   }
   result = (int)EVP_VerifyInit(arg1,(EVP_MD const *)arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -13774,7 +13340,7 @@ SWIGINTERN PyObject *_wrap_pkey_size(PyObject *self, PyObject *args) {
   }
   result = (int)EVP_PKEY_size(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -13825,41 +13391,6 @@ fail:
 }
 
 
-SWIGINTERN PyObject *_wrap_pkey_get1_rsa(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  EVP_PKEY *arg1 = (EVP_PKEY *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  RSA *result = 0 ;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"pkey_get1_rsa",1,1,&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EVP_PKEY, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pkey_get1_rsa" "', argument " "1"" of type '" "EVP_PKEY *""'"); 
-  }
-  arg1 = (EVP_PKEY *)(argp1);
-  {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  result = (RSA *)pkey_get1_rsa(arg1);
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_RSA, 0);
-    else {
-      resultobj = NULL;
-    }
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
 SWIGINTERN PyObject *_wrap_pkcs5_pbkdf2_hmac_sha1(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   PyObject *arg1 = (PyObject *) 0 ;
@@ -13967,7 +13498,7 @@ SWIGINTERN PyObject *_wrap_digest_update(PyObject *self, PyObject *args) {
   }
   result = (int)digest_update(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -14526,7 +14057,7 @@ SWIGINTERN PyObject *_wrap_verify_update(PyObject *self, PyObject *args) {
   }
   result = (int)verify_update(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -14575,7 +14106,7 @@ SWIGINTERN PyObject *_wrap_verify_final(PyObject *self, PyObject *args) {
   }
   result = (int)verify_final(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -14584,39 +14115,6 @@ fail:
 }
 
 
-SWIGINTERN PyObject *_wrap_get_digestbyname(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  EVP_MD *result = 0 ;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"get_digestbyname",1,1,&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "get_digestbyname" "', argument " "1"" of type '" "char const *""'");
-  }
-  arg1 = (char *)(buf1);
-  result = (EVP_MD *)get_digestbyname((char const *)arg1);
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_EVP_MD, 0);
-    else {
-      resultobj = NULL;
-    }
-  }
-  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
-  return NULL;
-}
-
-
 SWIGINTERN PyObject *_wrap_pkey_write_pem_no_cipher(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   EVP_PKEY *arg1 = (EVP_PKEY *) 0 ;
@@ -14661,7 +14159,7 @@ SWIGINTERN PyObject *_wrap_pkey_write_pem_no_cipher(PyObject *self, PyObject *ar
   }
   result = (int)pkey_write_pem_no_cipher(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -14728,7 +14226,7 @@ SWIGINTERN PyObject *_wrap_pkey_write_pem(PyObject *self, PyObject *args) {
   }
   result = (int)pkey_write_pem(arg1,arg2,arg3,arg4);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -14737,26 +14235,6 @@ fail:
 }
 
 
-SWIGINTERN PyObject *_wrap_pkey_new(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  EVP_PKEY *result = 0 ;
-  
-  result = (EVP_PKEY *)pkey_new();
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_EVP_PKEY, 0);
-    else {
-      resultobj = NULL;
-    }
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
 SWIGINTERN PyObject *_wrap_pkey_read_pem(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   BIO *arg1 = (BIO *) 0 ;
@@ -14786,15 +14264,7 @@ SWIGINTERN PyObject *_wrap_pkey_read_pem(PyObject *self, PyObject *args) {
     }
   }
   result = (EVP_PKEY *)pkey_read_pem(arg1,arg2);
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_EVP_PKEY, 0);
-    else {
-      resultobj = NULL;
-    }
-  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EVP_PKEY, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
@@ -14830,15 +14300,7 @@ SWIGINTERN PyObject *_wrap_pkey_read_pem_pubkey(PyObject *self, PyObject *args)
     }
   }
   result = (EVP_PKEY *)pkey_read_pem_pubkey(arg1,arg2);
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_EVP_PKEY, 0);
-    else {
-      resultobj = NULL;
-    }
-  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EVP_PKEY, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
@@ -14880,7 +14342,7 @@ SWIGINTERN PyObject *_wrap_pkey_assign_rsa(PyObject *self, PyObject *args) {
   }
   result = (int)pkey_assign_rsa(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -15110,7 +14572,7 @@ SWIGINTERN PyObject *_wrap_AES_type_check(PyObject *self, PyObject *args) {
   }
   result = (int)AES_type_check(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -15246,7 +14708,7 @@ SWIGINTERN PyObject *_wrap_rc4_type_check(PyObject *self, PyObject *args) {
   }
   result = (int)rc4_type_check(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -15314,7 +14776,7 @@ SWIGINTERN PyObject *_wrap_dh_size(PyObject *self, PyObject *args) {
   }
   result = (int)DH_size((DH const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -15344,7 +14806,7 @@ SWIGINTERN PyObject *_wrap_dh_generate_key(PyObject *self, PyObject *args) {
   }
   result = (int)DH_generate_key(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -15392,7 +14854,7 @@ SWIGINTERN PyObject *_wrap_dhparams_print(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -15464,7 +14926,7 @@ SWIGINTERN PyObject *_wrap_dh_type_check(PyObject *self, PyObject *args) {
   }
   result = (int)dh_type_check(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -15565,7 +15027,7 @@ SWIGINTERN PyObject *_wrap_dh_check(PyObject *self, PyObject *args) {
   }
   result = (int)dh_check(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -15784,7 +15246,7 @@ SWIGINTERN PyObject *_wrap_rsa_size(PyObject *self, PyObject *args) {
   }
   result = (int)RSA_size((RSA const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -15852,7 +15314,7 @@ SWIGINTERN PyObject *_wrap_rsa_check_key(PyObject *self, PyObject *args) {
   }
   result = (int)RSA_check_key((RSA const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -16007,7 +15469,7 @@ SWIGINTERN PyObject *_wrap_rsa_write_key(PyObject *self, PyObject *args) {
   }
   result = (int)rsa_write_key(arg1,arg2,arg3,arg4);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -16065,7 +15527,7 @@ SWIGINTERN PyObject *_wrap_rsa_write_key_no_cipher(PyObject *self, PyObject *arg
   }
   result = (int)rsa_write_key_no_cipher(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -16144,7 +15606,7 @@ SWIGINTERN PyObject *_wrap_rsa_write_pub_key(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -16658,7 +16120,7 @@ SWIGINTERN PyObject *_wrap_rsa_verify_pkcs1_pss(PyObject *self, PyObject *args)
   }
   result = (int)rsa_verify_pkcs1_pss(arg1,arg2,arg3,arg4,arg5);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -16750,7 +16212,7 @@ SWIGINTERN PyObject *_wrap_rsa_verify(PyObject *self, PyObject *args) {
   }
   result = (int)rsa_verify(arg1,arg2,arg3,arg4);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -16827,7 +16289,7 @@ SWIGINTERN PyObject *_wrap_rsa_type_check(PyObject *self, PyObject *args) {
   }
   result = (int)rsa_type_check(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -16857,7 +16319,7 @@ SWIGINTERN PyObject *_wrap_rsa_check_pub_key(PyObject *self, PyObject *args) {
   }
   result = (int)rsa_check_pub_key(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -16905,7 +16367,7 @@ SWIGINTERN PyObject *_wrap_rsa_write_key_der(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -16960,186 +16422,21 @@ SWIGINTERN PyObject *_wrap_dsa_size(PyObject *self, PyObject *args) {
   PyObject * obj0 = 0 ;
   int result;
   
-  if(!PyArg_UnpackTuple(args,(char *)"dsa_size",1,1,&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_DSA, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dsa_size" "', argument " "1"" of type '" "DSA const *""'"); 
-  }
-  arg1 = (DSA *)(argp1);
-  {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  result = (int)DSA_size((DSA const *)arg1);
-  {
-    resultobj=PyLong_FromLong(result);
-    if (PyErr_Occurred()) SWIG_fail;
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_dsa_gen_key(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  DSA *arg1 = (DSA *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"dsa_gen_key",1,1,&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_DSA, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dsa_gen_key" "', argument " "1"" of type '" "DSA *""'"); 
-  }
-  arg1 = (DSA *)(argp1);
-  {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  result = (int)DSA_generate_key(arg1);
-  {
-    resultobj=PyLong_FromLong(result);
-    if (PyErr_Occurred()) SWIG_fail;
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN int Swig_var__dsa_err_set(PyObject *_val) {
-  {
-    void *argp = 0;
-    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_PyObject,  0 );  
-    if (!SWIG_IsOK(res)) {
-      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""_dsa_err""' of type '""PyObject *""'");
-    }
-    _dsa_err = (PyObject *)(argp);
-  }
-  return 0;
-fail:
-  return 1;
-}
-
-
-SWIGINTERN PyObject *Swig_var__dsa_err_get(void) {
-  PyObject *pyobj = 0;
-  PyObject *self = 0;
-  
-  (void)self;
-  pyobj = SWIG_NewPointerObj(SWIG_as_voidptr(_dsa_err), SWIGTYPE_p_PyObject,  0 );
-  return pyobj;
-}
-
-
-SWIGINTERN PyObject *_wrap_dsa_init(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  PyObject *arg1 = (PyObject *) 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"dsa_init",1,1,&obj0)) SWIG_fail;
-  {
-    arg1=obj0;
-  }
-  dsa_init(arg1);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_dsa_generate_parameters(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  PyObject *arg2 = (PyObject *) 0 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  DSA *result = 0 ;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"dsa_generate_parameters",2,2,&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "dsa_generate_parameters" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = (int)(val1);
-  {
-    if (!PyCallable_Check(obj1)) {
-      PyErr_SetString(PyExc_TypeError, "expected PyCallable");
-      return NULL;
-    }
-    arg2=obj1;
-  }
-  {
-    if (!arg2) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  result = (DSA *)dsa_generate_parameters(arg1,arg2);
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_DSA, 0);
-    else {
-      resultobj = NULL;
-    }
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_dsa_read_params(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  BIO *arg1 = (BIO *) 0 ;
-  PyObject *arg2 = (PyObject *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  DSA *result = 0 ;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"dsa_read_params",2,2,&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
+  if(!PyArg_UnpackTuple(args,(char *)"dsa_size",1,1,&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_DSA, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dsa_read_params" "', argument " "1"" of type '" "BIO *""'"); 
-  }
-  arg1 = (BIO *)(argp1);
-  {
-    if (!PyCallable_Check(obj1)) {
-      PyErr_SetString(PyExc_TypeError, "expected PyCallable");
-      return NULL;
-    }
-    arg2=obj1;
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dsa_size" "', argument " "1"" of type '" "DSA const *""'"); 
   }
+  arg1 = (DSA *)(argp1);
   {
     if (!arg1) {
       SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
     }
   }
+  result = (int)DSA_size((DSA const *)arg1);
   {
-    if (!arg2) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  result = (DSA *)dsa_read_params(arg1,arg2);
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_DSA, 0);
-    else {
-      resultobj = NULL;
-    }
+    resultobj=PyInt_FromLong(result);
+    if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
 fail:
@@ -17147,71 +16444,94 @@ fail:
 }
 
 
-SWIGINTERN PyObject *_wrap_dsa_read_key(PyObject *self, PyObject *args) {
+SWIGINTERN PyObject *_wrap_dsa_gen_key(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
-  BIO *arg1 = (BIO *) 0 ;
-  PyObject *arg2 = (PyObject *) 0 ;
+  DSA *arg1 = (DSA *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  DSA *result = 0 ;
+  int result;
   
-  if(!PyArg_UnpackTuple(args,(char *)"dsa_read_key",2,2,&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
+  if(!PyArg_UnpackTuple(args,(char *)"dsa_gen_key",1,1,&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_DSA, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dsa_read_key" "', argument " "1"" of type '" "BIO *""'"); 
-  }
-  arg1 = (BIO *)(argp1);
-  {
-    if (!PyCallable_Check(obj1)) {
-      PyErr_SetString(PyExc_TypeError, "expected PyCallable");
-      return NULL;
-    }
-    arg2=obj1;
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dsa_gen_key" "', argument " "1"" of type '" "DSA *""'"); 
   }
+  arg1 = (DSA *)(argp1);
   {
     if (!arg1) {
       SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
     }
   }
+  result = (int)DSA_generate_key(arg1);
   {
-    if (!arg2) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
+    resultobj=PyInt_FromLong(result);
+    if (PyErr_Occurred()) SWIG_fail;
   }
-  result = (DSA *)dsa_read_key(arg1,arg2);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN int Swig_var__dsa_err_set(PyObject *_val) {
   {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_DSA, 0);
-    else {
-      resultobj = NULL;
+    void *argp = 0;
+    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_PyObject,  0 );  
+    if (!SWIG_IsOK(res)) {
+      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""_dsa_err""' of type '""PyObject *""'");
     }
+    _dsa_err = (PyObject *)(argp);
+  }
+  return 0;
+fail:
+  return 1;
+}
+
+
+SWIGINTERN PyObject *Swig_var__dsa_err_get(void) {
+  PyObject *pyobj = 0;
+  PyObject *self = 0;
+  
+  (void)self;
+  pyobj = SWIG_NewPointerObj(SWIG_as_voidptr(_dsa_err), SWIGTYPE_p_PyObject,  0 );
+  return pyobj;
+}
+
+
+SWIGINTERN PyObject *_wrap_dsa_init(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0;
+  PyObject *arg1 = (PyObject *) 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if(!PyArg_UnpackTuple(args,(char *)"dsa_init",1,1,&obj0)) SWIG_fail;
+  {
+    arg1=obj0;
   }
+  dsa_init(arg1);
+  resultobj = SWIG_Py_Void();
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_dsa_read_pub_key(PyObject *self, PyObject *args) {
+SWIGINTERN PyObject *_wrap_dsa_generate_parameters(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
-  BIO *arg1 = (BIO *) 0 ;
+  int arg1 ;
   PyObject *arg2 = (PyObject *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
+  int val1 ;
+  int ecode1 = 0 ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   DSA *result = 0 ;
   
-  if(!PyArg_UnpackTuple(args,(char *)"dsa_read_pub_key",2,2,&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dsa_read_pub_key" "', argument " "1"" of type '" "BIO *""'"); 
-  }
-  arg1 = (BIO *)(argp1);
+  if(!PyArg_UnpackTuple(args,(char *)"dsa_generate_parameters",2,2,&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_int(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "dsa_generate_parameters" "', argument " "1"" of type '" "int""'");
+  } 
+  arg1 = (int)(val1);
   {
     if (!PyCallable_Check(obj1)) {
       PyErr_SetString(PyExc_TypeError, "expected PyCallable");
@@ -17219,26 +16539,13 @@ SWIGINTERN PyObject *_wrap_dsa_read_pub_key(PyObject *self, PyObject *args) {
     }
     arg2=obj1;
   }
-  {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
   {
     if (!arg2) {
       SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
     }
   }
-  result = (DSA *)dsa_read_pub_key(arg1,arg2);
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_DSA, 0);
-    else {
-      resultobj = NULL;
-    }
-  }
+  result = (DSA *)dsa_generate_parameters(arg1,arg2);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DSA, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
@@ -17468,6 +16775,47 @@ fail:
 }
 
 
+SWIGINTERN PyObject *_wrap_dsa_read_params(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0;
+  BIO *arg1 = (BIO *) 0 ;
+  PyObject *arg2 = (PyObject *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  DSA *result = 0 ;
+  
+  if(!PyArg_UnpackTuple(args,(char *)"dsa_read_params",2,2,&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dsa_read_params" "', argument " "1"" of type '" "BIO *""'"); 
+  }
+  arg1 = (BIO *)(argp1);
+  {
+    if (!PyCallable_Check(obj1)) {
+      PyErr_SetString(PyExc_TypeError, "expected PyCallable");
+      return NULL;
+    }
+    arg2=obj1;
+  }
+  {
+    if (!arg1) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  {
+    if (!arg2) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  result = (DSA *)dsa_read_params(arg1,arg2);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DSA, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_dsa_write_params_bio(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   DSA *arg1 = (DSA *) 0 ;
@@ -17507,7 +16855,7 @@ SWIGINTERN PyObject *_wrap_dsa_write_params_bio(PyObject *self, PyObject *args)
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -17579,7 +16927,7 @@ SWIGINTERN PyObject *_wrap_dsa_write_key_bio(PyObject *self, PyObject *args) {
   }
   result = (int)dsa_write_key_bio(arg1,arg2,arg3,arg4);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -17637,7 +16985,7 @@ SWIGINTERN PyObject *_wrap_dsa_write_key_bio_no_cipher(PyObject *self, PyObject
   }
   result = (int)dsa_write_key_bio_no_cipher(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -17668,7 +17016,96 @@ SWIGINTERN PyObject *_wrap_dsa_write_pub_key_bio(PyObject *self, PyObject *args)
   if (!SWIG_IsOK(res2)) {
     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "dsa_write_pub_key_bio" "', argument " "2"" of type '" "BIO *""'"); 
   }
-  arg2 = (BIO *)(argp2);
+  arg2 = (BIO *)(argp2);
+  {
+    if (!arg1) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  {
+    if (!arg2) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  {
+    SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+    result = (int)dsa_write_pub_key_bio(arg1,arg2);
+    SWIG_PYTHON_THREAD_END_ALLOW;
+  }
+  {
+    resultobj=PyInt_FromLong(result);
+    if (PyErr_Occurred()) SWIG_fail;
+  }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_dsa_read_key(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0;
+  BIO *arg1 = (BIO *) 0 ;
+  PyObject *arg2 = (PyObject *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  DSA *result = 0 ;
+  
+  if(!PyArg_UnpackTuple(args,(char *)"dsa_read_key",2,2,&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dsa_read_key" "', argument " "1"" of type '" "BIO *""'"); 
+  }
+  arg1 = (BIO *)(argp1);
+  {
+    if (!PyCallable_Check(obj1)) {
+      PyErr_SetString(PyExc_TypeError, "expected PyCallable");
+      return NULL;
+    }
+    arg2=obj1;
+  }
+  {
+    if (!arg1) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  {
+    if (!arg2) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  result = (DSA *)dsa_read_key(arg1,arg2);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DSA, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_dsa_read_pub_key(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0;
+  BIO *arg1 = (BIO *) 0 ;
+  PyObject *arg2 = (PyObject *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  DSA *result = 0 ;
+  
+  if(!PyArg_UnpackTuple(args,(char *)"dsa_read_pub_key",2,2,&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dsa_read_pub_key" "', argument " "1"" of type '" "BIO *""'"); 
+  }
+  arg1 = (BIO *)(argp1);
+  {
+    if (!PyCallable_Check(obj1)) {
+      PyErr_SetString(PyExc_TypeError, "expected PyCallable");
+      return NULL;
+    }
+    arg2=obj1;
+  }
   {
     if (!arg1) {
       SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
@@ -17679,15 +17116,8 @@ SWIGINTERN PyObject *_wrap_dsa_write_pub_key_bio(PyObject *self, PyObject *args)
       SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
     }
   }
-  {
-    SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-    result = (int)dsa_write_pub_key_bio(arg1,arg2);
-    SWIG_PYTHON_THREAD_END_ALLOW;
-  }
-  {
-    resultobj=PyLong_FromLong(result);
-    if (PyErr_Occurred()) SWIG_fail;
-  }
+  result = (DSA *)dsa_read_pub_key(arg1,arg2);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DSA, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
@@ -17764,7 +17194,7 @@ SWIGINTERN PyObject *_wrap_dsa_verify(PyObject *self, PyObject *args) {
   }
   result = (int)dsa_verify(arg1,arg2,arg3,arg4);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -17838,7 +17268,7 @@ SWIGINTERN PyObject *_wrap_dsa_verify_asn1(PyObject *self, PyObject *args) {
   }
   result = (int)dsa_verify_asn1(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -17868,7 +17298,7 @@ SWIGINTERN PyObject *_wrap_dsa_check_key(PyObject *self, PyObject *args) {
   }
   result = (int)dsa_check_key(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -17898,7 +17328,7 @@ SWIGINTERN PyObject *_wrap_dsa_check_pub_key(PyObject *self, PyObject *args) {
   }
   result = (int)dsa_check_pub_key(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -17928,7 +17358,7 @@ SWIGINTERN PyObject *_wrap_dsa_keylen(PyObject *self, PyObject *args) {
   }
   result = (int)dsa_keylen(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -17958,7 +17388,7 @@ SWIGINTERN PyObject *_wrap_dsa_type_check(PyObject *self, PyObject *args) {
   }
   result = (int)dsa_type_check(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -18051,7 +17481,7 @@ SWIGINTERN PyObject *_wrap_ssl_get_error(PyObject *self, PyObject *args) {
   }
   result = (int)SSL_get_error((SSL const *)arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -18327,7 +17757,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_get_verify_depth(PyObject *self, PyObject *ar
   }
   result = (int)SSL_CTX_get_verify_depth((SSL_CTX const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -18357,7 +17787,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_get_verify_mode(PyObject *self, PyObject *arg
   }
   result = (int)SSL_CTX_get_verify_mode((SSL_CTX const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -18397,7 +17827,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_set_cipher_list(PyObject *self, PyObject *arg
   }
   result = (int)SSL_CTX_set_cipher_list(arg1,(char const *)arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
@@ -18438,7 +17868,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_add_session(PyObject *self, PyObject *args) {
   }
   result = (int)SSL_CTX_add_session(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -18477,7 +17907,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_remove_session(PyObject *self, PyObject *args
   }
   result = (int)SSL_CTX_remove_session(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -18597,7 +18027,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_set_default_verify_paths(PyObject *self, PyOb
   }
   result = (int)SSL_CTX_set_default_verify_paths(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -18612,7 +18042,7 @@ SWIGINTERN PyObject *_wrap_ssl_get_ex_data_x509_store_ctx_idx(PyObject *self, Py
   
   result = (int)SSL_get_ex_data_X509_STORE_CTX_idx();
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -18868,7 +18298,7 @@ SWIGINTERN PyObject *_wrap_ssl_get_shutdown(PyObject *self, PyObject *args) {
   }
   result = (int)SSL_get_shutdown((SSL const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -18937,7 +18367,7 @@ SWIGINTERN PyObject *_wrap_ssl_shutdown(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -18967,7 +18397,7 @@ SWIGINTERN PyObject *_wrap_ssl_clear(PyObject *self, PyObject *args) {
   }
   result = (int)SSL_clear(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -19001,7 +18431,7 @@ SWIGINTERN PyObject *_wrap_ssl_do_handshake(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -19035,7 +18465,7 @@ SWIGINTERN PyObject *_wrap_ssl_renegotiate(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -19065,7 +18495,7 @@ SWIGINTERN PyObject *_wrap_ssl_pending(PyObject *self, PyObject *args) {
   }
   result = (int)SSL_pending((SSL const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -19149,7 +18579,7 @@ SWIGINTERN PyObject *_wrap_ssl_get_verify_mode(PyObject *self, PyObject *args) {
   }
   result = (int)SSL_get_verify_mode((SSL const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -19179,7 +18609,7 @@ SWIGINTERN PyObject *_wrap_ssl_get_verify_depth(PyObject *self, PyObject *args)
   }
   result = (int)SSL_get_verify_depth((SSL const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -19300,7 +18730,7 @@ SWIGINTERN PyObject *_wrap_ssl_set_cipher_list(PyObject *self, PyObject *args) {
   }
   result = (int)SSL_set_cipher_list(arg1,(char const *)arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
@@ -19485,7 +18915,7 @@ SWIGINTERN PyObject *_wrap_ssl_set_session(PyObject *self, PyObject *args) {
   }
   result = (int)SSL_set_session(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -19549,7 +18979,7 @@ SWIGINTERN PyObject *_wrap_ssl_session_print(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -19777,7 +19207,7 @@ SWIGINTERN PyObject *_wrap_ssl_write(PyObject *self, PyObject *args) {
   }
   result = (int)ssl_write(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -19952,7 +19382,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_use_x509(PyObject *self, PyObject *args) {
   }
   result = (int)ssl_ctx_use_x509(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -19992,7 +19422,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_use_cert(PyObject *self, PyObject *args) {
   }
   result = (int)ssl_ctx_use_cert(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
@@ -20034,7 +19464,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_use_cert_chain(PyObject *self, PyObject *args
   }
   result = (int)ssl_ctx_use_cert_chain(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
@@ -20076,7 +19506,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_use_privkey(PyObject *self, PyObject *args) {
   }
   result = (int)ssl_ctx_use_privkey(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
@@ -20122,7 +19552,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_use_rsa_privkey(PyObject *self, PyObject *arg
   }
   result = (int)ssl_ctx_use_rsa_privkey(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -20166,7 +19596,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_use_pkey_privkey(PyObject *self, PyObject *ar
   }
   result = (int)ssl_ctx_use_pkey_privkey(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -20196,7 +19626,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_check_privkey(PyObject *self, PyObject *args)
   }
   result = (int)ssl_ctx_check_privkey(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -20353,7 +19783,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_set_session_id_context(PyObject *self, PyObje
   }
   result = (int)ssl_ctx_set_session_id_context(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -20605,7 +20035,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_load_verify_locations(PyObject *self, PyObjec
   }
   result = (int)ssl_ctx_load_verify_locations(arg1,(char const *)arg2,(char const *)arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
@@ -20698,7 +20128,7 @@ SWIGINTERN PyObject *_wrap_bio_set_ssl(PyObject *self, PyObject *args) {
   }
   result = (int)bio_set_ssl(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -20801,7 +20231,7 @@ SWIGINTERN PyObject *_wrap_ssl_set_tlsext_host_name(PyObject *self, PyObject *ar
   }
   result = (int)ssl_set_tlsext_host_name(arg1,(char const *)arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
@@ -20916,7 +20346,7 @@ SWIGINTERN PyObject *_wrap_ssl_set_session_id_context(PyObject *self, PyObject *
   }
   result = (int)ssl_set_session_id_context(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -20955,7 +20385,7 @@ SWIGINTERN PyObject *_wrap_ssl_set_fd(PyObject *self, PyObject *args) {
   }
   result = (int)ssl_set_fd(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -21063,7 +20493,7 @@ SWIGINTERN PyObject *_wrap_ssl_write_nbio(PyObject *self, PyObject *args) {
   }
   result = (int)ssl_write_nbio(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -21093,7 +20523,7 @@ SWIGINTERN PyObject *_wrap_ssl_cipher_get_bits(PyObject *self, PyObject *args) {
   }
   result = (int)ssl_cipher_get_bits(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -21123,7 +20553,7 @@ SWIGINTERN PyObject *_wrap_sk_ssl_cipher_num(PyObject *self, PyObject *args) {
   }
   result = (int)sk_ssl_cipher_num(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -21216,7 +20646,7 @@ SWIGINTERN PyObject *_wrap_sk_x509_num(PyObject *self, PyObject *args) {
   }
   result = (int)sk_x509_num(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -21324,16 +20754,7 @@ SWIGINTERN PyObject *_wrap_ssl_session_read_pem(PyObject *self, PyObject *args)
     result = (SSL_SESSION *)ssl_session_read_pem(arg1);
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_SSL_SESSION, 0);
-    else {
-      m2_PyErr_Msg(_ssl_err);
-      resultobj = NULL;
-    }
-  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SSL_SESSION, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
@@ -21374,7 +20795,7 @@ SWIGINTERN PyObject *_wrap_ssl_session_write_pem(PyObject *self, PyObject *args)
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -21413,7 +20834,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_set_session_cache_mode(PyObject *self, PyObje
   }
   result = (int)ssl_ctx_set_session_cache_mode(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -21443,7 +20864,7 @@ SWIGINTERN PyObject *_wrap_ssl_ctx_get_session_cache_mode(PyObject *self, PyObje
   }
   result = (int)ssl_ctx_get_session_cache_mode(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -21509,7 +20930,7 @@ SWIGINTERN PyObject *_wrap_ssl_is_init_finished(PyObject *self, PyObject *args)
   }
   result = (int)ssl_is_init_finished(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -21539,7 +20960,7 @@ SWIGINTERN PyObject *_wrap_x509_check_ca(PyObject *self, PyObject *args) {
   }
   result = (int)X509_check_ca(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -21690,7 +21111,7 @@ SWIGINTERN PyObject *_wrap_x509_print(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -21738,7 +21159,7 @@ SWIGINTERN PyObject *_wrap_x509_crl_print(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -21804,7 +21225,7 @@ SWIGINTERN PyObject *_wrap_x509_set_serial_number(PyObject *self, PyObject *args
   }
   result = (int)X509_set_serialNumber(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -21875,7 +21296,7 @@ SWIGINTERN PyObject *_wrap_x509_set_pubkey(PyObject *self, PyObject *args) {
   }
   result = (int)X509_set_pubkey(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -21946,7 +21367,7 @@ SWIGINTERN PyObject *_wrap_x509_set_issuer_name(PyObject *self, PyObject *args)
   }
   result = (int)X509_set_issuer_name(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22017,7 +21438,7 @@ SWIGINTERN PyObject *_wrap_x509_set_subject_name(PyObject *self, PyObject *args)
   }
   result = (int)X509_set_subject_name(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22042,7 +21463,7 @@ SWIGINTERN PyObject *_wrap_x509_cmp_current_time(PyObject *self, PyObject *args)
   arg1 = (ASN1_TIME *)(argp1);
   result = (int)X509_cmp_current_time(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22090,7 +21511,7 @@ SWIGINTERN PyObject *_wrap_x509_check_purpose(PyObject *self, PyObject *args) {
   }
   result = (int)X509_check_purpose(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22138,7 +21559,7 @@ SWIGINTERN PyObject *_wrap_x509_check_trust(PyObject *self, PyObject *args) {
   }
   result = (int)X509_check_trust(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22186,7 +21607,7 @@ SWIGINTERN PyObject *_wrap_x509_write_pem(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22225,7 +21646,7 @@ SWIGINTERN PyObject *_wrap_x509_write_pem_file(PyObject *self, PyObject *args) {
   }
   result = (int)PEM_write_X509(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22269,7 +21690,7 @@ SWIGINTERN PyObject *_wrap_x509_verify(PyObject *self, PyObject *args) {
   }
   result = (int)X509_verify(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22339,7 +21760,7 @@ SWIGINTERN PyObject *_wrap_x509_add_ext(PyObject *self, PyObject *args) {
   }
   result = (int)X509_add_ext(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22369,7 +21790,7 @@ SWIGINTERN PyObject *_wrap_x509_get_ext_count(PyObject *self, PyObject *args) {
   }
   result = (int)X509_get_ext_count(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22466,7 +21887,7 @@ SWIGINTERN PyObject *_wrap_x509_ext_print(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22561,7 +21982,7 @@ SWIGINTERN PyObject *_wrap_x509_name_print(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22627,7 +22048,7 @@ SWIGINTERN PyObject *_wrap_x509_name_entry_count(PyObject *self, PyObject *args)
   }
   result = (int)X509_NAME_entry_count(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22725,7 +22146,7 @@ SWIGINTERN PyObject *_wrap_x509_name_add_entry(PyObject *self, PyObject *args) {
   }
   result = (int)X509_NAME_add_entry(arg1,arg2,arg3,arg4);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22809,7 +22230,7 @@ SWIGINTERN PyObject *_wrap_x509_name_add_entry_by_obj(PyObject *self, PyObject *
   }
   result = (int)X509_NAME_add_entry_by_OBJ(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22893,7 +22314,7 @@ SWIGINTERN PyObject *_wrap_x509_name_add_entry_by_nid(PyObject *self, PyObject *
   }
   result = (int)X509_NAME_add_entry_by_NID(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -22959,7 +22380,7 @@ SWIGINTERN PyObject *_wrap_x509_name_print_ex(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23034,7 +22455,7 @@ SWIGINTERN PyObject *_wrap_x509_name_get_index_by_nid(PyObject *self, PyObject *
   }
   result = (int)X509_NAME_get_index_by_NID(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23169,7 +22590,7 @@ SWIGINTERN PyObject *_wrap_x509_name_entry_set_object(PyObject *self, PyObject *
   }
   result = (int)X509_NAME_ENTRY_set_object(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23262,12 +22683,12 @@ SWIGINTERN PyObject *_wrap_x509_name_entry_set_data(PyObject *self, PyObject *ar
     if (PyString_Check(obj2)) {
       Py_ssize_t len;
       
-      arg3 = (unsigned char *)PyString_AsString(obj2);
+      arg3 = (unsigned char *)PyString_AsString(obj2); 
       len = PyString_Size(obj2);
       
       
       if (len > INT_MAX) {
-        PyErr_SetString(_x509_err, "object too large");
+        PyErr_SetString(PyExc_ValueError, "object too large");
         return NULL;
       }
       arg4 = len;
@@ -23283,7 +22704,7 @@ SWIGINTERN PyObject *_wrap_x509_name_entry_set_data(PyObject *self, PyObject *ar
   }
   result = (int)X509_NAME_ENTRY_set_data(arg1,arg2,(unsigned char const *)arg3,arg4);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23369,7 +22790,7 @@ SWIGINTERN PyObject *_wrap_x509_req_print(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23440,7 +22861,7 @@ SWIGINTERN PyObject *_wrap_x509_req_set_pubkey(PyObject *self, PyObject *args) {
   }
   result = (int)X509_REQ_set_pubkey(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23484,7 +22905,7 @@ SWIGINTERN PyObject *_wrap_x509_req_set_subject_name(PyObject *self, PyObject *a
   }
   result = (int)X509_REQ_set_subject_name(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23528,7 +22949,7 @@ SWIGINTERN PyObject *_wrap_x509_req_verify(PyObject *self, PyObject *args) {
   }
   result = (int)X509_REQ_verify(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23586,7 +23007,7 @@ SWIGINTERN PyObject *_wrap_x509_req_sign(PyObject *self, PyObject *args) {
   }
   result = (int)X509_REQ_sign(arg1,arg2,(EVP_MD const *)arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23634,7 +23055,7 @@ SWIGINTERN PyObject *_wrap_i2d_x509_bio(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23682,7 +23103,7 @@ SWIGINTERN PyObject *_wrap_i2d_x509_req_bio(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23754,7 +23175,7 @@ SWIGINTERN PyObject *_wrap_x509_store_add_cert(PyObject *self, PyObject *args) {
   }
   result = (int)X509_STORE_add_cert(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23830,7 +23251,7 @@ SWIGINTERN PyObject *_wrap_x509_store_ctx_get_error(PyObject *self, PyObject *ar
   arg1 = (X509_STORE_CTX *)(argp1);
   result = (int)X509_STORE_CTX_get_error(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23855,7 +23276,7 @@ SWIGINTERN PyObject *_wrap_x509_store_ctx_get_error_depth(PyObject *self, PyObje
   arg1 = (X509_STORE_CTX *)(argp1);
   result = (int)X509_STORE_CTX_get_error_depth(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23923,7 +23344,7 @@ SWIGINTERN PyObject *_wrap_x509_extension_get_critical(PyObject *self, PyObject
   arg1 = (X509_EXTENSION *)(argp1);
   result = (int)X509_EXTENSION_get_critical(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23957,7 +23378,7 @@ SWIGINTERN PyObject *_wrap_x509_extension_set_critical(PyObject *self, PyObject
   arg2 = (int)(val2);
   result = (int)X509_EXTENSION_set_critical(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -23966,6 +23387,48 @@ fail:
 }
 
 
+SWIGINTERN int Swig_var__x509_err_set(PyObject *_val) {
+  {
+    void *argp = 0;
+    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_PyObject,  0 );  
+    if (!SWIG_IsOK(res)) {
+      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""_x509_err""' of type '""PyObject *""'");
+    }
+    _x509_err = (PyObject *)(argp);
+  }
+  return 0;
+fail:
+  return 1;
+}
+
+
+SWIGINTERN PyObject *Swig_var__x509_err_get(void) {
+  PyObject *pyobj = 0;
+  PyObject *self = 0;
+  
+  (void)self;
+  pyobj = SWIG_NewPointerObj(SWIG_as_voidptr(_x509_err), SWIGTYPE_p_PyObject,  0 );
+  return pyobj;
+}
+
+
+SWIGINTERN PyObject *_wrap_x509_init(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0;
+  PyObject *arg1 = (PyObject *) 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if(!PyArg_UnpackTuple(args,(char *)"x509_init",1,1,&obj0)) SWIG_fail;
+  {
+    arg1=obj0;
+  }
+  x509_init(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_x509_read_pem(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   BIO *arg1 = (BIO *) 0 ;
@@ -23990,16 +23453,7 @@ SWIGINTERN PyObject *_wrap_x509_read_pem(PyObject *self, PyObject *args) {
     result = (X509 *)x509_read_pem(arg1);
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_X509, 0);
-    else {
-      m2_PyErr_Msg(_x509_err);
-      resultobj = NULL;
-    }
-  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_X509, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
@@ -24030,58 +23484,7 @@ SWIGINTERN PyObject *_wrap_d2i_x509(PyObject *self, PyObject *args) {
     result = (X509 *)d2i_x509(arg1);
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_X509, 0);
-    else {
-      m2_PyErr_Msg(_x509_err);
-      resultobj = NULL;
-    }
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN int Swig_var__x509_err_set(PyObject *_val) {
-  {
-    void *argp = 0;
-    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_PyObject,  0 );  
-    if (!SWIG_IsOK(res)) {
-      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""_x509_err""' of type '""PyObject *""'");
-    }
-    _x509_err = (PyObject *)(argp);
-  }
-  return 0;
-fail:
-  return 1;
-}
-
-
-SWIGINTERN PyObject *Swig_var__x509_err_get(void) {
-  PyObject *pyobj = 0;
-  PyObject *self = 0;
-  
-  (void)self;
-  pyobj = SWIG_NewPointerObj(SWIG_as_voidptr(_x509_err), SWIGTYPE_p_PyObject,  0 );
-  return pyobj;
-}
-
-
-SWIGINTERN PyObject *_wrap_x509_init(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  PyObject *arg1 = (PyObject *) 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"x509_init",1,1,&obj0)) SWIG_fail;
-  {
-    arg1=obj0;
-  }
-  x509_init(arg1);
-  resultobj = SWIG_Py_Void();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_X509, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
@@ -24112,55 +23515,35 @@ SWIGINTERN PyObject *_wrap_d2i_x509_req(PyObject *self, PyObject *args) {
     result = (X509_REQ *)d2i_x509_req(arg1);
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_X509_REQ, 0);
-    else {
-      m2_PyErr_Msg(_x509_err);
-      resultobj = NULL;
-    }
-  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_X509_REQ, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_x509_req_read_pem(PyObject *self, PyObject *args) {
+SWIGINTERN PyObject *_wrap_i2d_x509(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
-  BIO *arg1 = (BIO *) 0 ;
+  X509 *arg1 = (X509 *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
-  X509_REQ *result = 0 ;
+  PyObject *result = 0 ;
   
-  if(!PyArg_UnpackTuple(args,(char *)"x509_req_read_pem",1,1,&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
+  if(!PyArg_UnpackTuple(args,(char *)"i2d_x509",1,1,&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_X509, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x509_req_read_pem" "', argument " "1"" of type '" "BIO *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "i2d_x509" "', argument " "1"" of type '" "X509 *""'"); 
   }
-  arg1 = (BIO *)(argp1);
+  arg1 = (X509 *)(argp1);
   {
     if (!arg1) {
       SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
     }
   }
+  result = (PyObject *)i2d_x509(arg1);
   {
-    SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-    result = (X509_REQ *)x509_req_read_pem(arg1);
-    SWIG_PYTHON_THREAD_END_ALLOW;
-  }
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_X509_REQ, 0);
-    else {
-      m2_PyErr_Msg(_x509_err);
-      resultobj = NULL;
-    }
+    resultobj=result;
   }
   return resultobj;
 fail:
@@ -24168,29 +23551,31 @@ fail:
 }
 
 
-SWIGINTERN PyObject *_wrap_i2d_x509(PyObject *self, PyObject *args) {
+SWIGINTERN PyObject *_wrap_x509_req_read_pem(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
-  X509 *arg1 = (X509 *) 0 ;
+  BIO *arg1 = (BIO *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
-  PyObject *result = 0 ;
+  X509_REQ *result = 0 ;
   
-  if(!PyArg_UnpackTuple(args,(char *)"i2d_x509",1,1,&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_X509, 0 |  0 );
+  if(!PyArg_UnpackTuple(args,(char *)"x509_req_read_pem",1,1,&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "i2d_x509" "', argument " "1"" of type '" "X509 *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x509_req_read_pem" "', argument " "1"" of type '" "BIO *""'"); 
   }
-  arg1 = (X509 *)(argp1);
+  arg1 = (BIO *)(argp1);
   {
     if (!arg1) {
       SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
     }
   }
-  result = (PyObject *)i2d_x509(arg1);
   {
-    resultobj=result;
+    SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+    result = (X509_REQ *)x509_req_read_pem(arg1);
+    SWIG_PYTHON_THREAD_END_ALLOW;
   }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_X509_REQ, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
@@ -24236,7 +23621,7 @@ SWIGINTERN PyObject *_wrap_x509_req_write_pem(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -24269,16 +23654,7 @@ SWIGINTERN PyObject *_wrap_x509_crl_read_pem(PyObject *self, PyObject *args) {
     result = (X509_CRL *)x509_crl_read_pem(arg1);
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_X509_CRL, 0);
-    else {
-      m2_PyErr_Msg(_x509_err);
-      resultobj = NULL;
-    }
-  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_X509_CRL, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
@@ -24315,7 +23691,7 @@ SWIGINTERN PyObject *_wrap_x509_set_version(PyObject *self, PyObject *args) {
   }
   result = (int)x509_set_version(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -24381,7 +23757,7 @@ SWIGINTERN PyObject *_wrap_x509_set_not_before(PyObject *self, PyObject *args) {
   }
   result = (int)x509_set_not_before(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -24447,7 +23823,7 @@ SWIGINTERN PyObject *_wrap_x509_set_not_after(PyObject *self, PyObject *args) {
   }
   result = (int)x509_set_not_after(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -24532,7 +23908,7 @@ SWIGINTERN PyObject *_wrap_x509_sign(PyObject *self, PyObject *args) {
   }
   result = (int)x509_sign(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -24645,7 +24021,7 @@ SWIGINTERN PyObject *_wrap_x509_name_set_by_nid(PyObject *self, PyObject *args)
   }
   result = (int)x509_name_set_by_nid(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -24731,7 +24107,7 @@ SWIGINTERN PyObject *_wrap_x509_name_add_entry_by_txt(PyObject *self, PyObject *
   }
   result = (int)x509_name_add_entry_by_txt(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
@@ -24773,6 +24149,18 @@ fail:
 }
 
 
+SWIGINTERN PyObject *_wrap_sk_x509_new_null(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0;
+  struct stack_st_X509 *result = 0 ;
+  
+  result = (struct stack_st_X509 *)sk_x509_new_null();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_stack_st_X509, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
 SWIGINTERN PyObject *_wrap_sk_x509_free(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   struct stack_st_X509 *arg1 = (struct stack_st_X509 *) 0 ;
@@ -24834,7 +24222,7 @@ SWIGINTERN PyObject *_wrap_sk_x509_push(PyObject *self, PyObject *args) {
   }
   result = (int)sk_x509_push(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -24896,7 +24284,7 @@ SWIGINTERN PyObject *_wrap_x509_store_load_locations(PyObject *self, PyObject *a
   arg2 = (char *)(buf2);
   result = (int)x509_store_load_locations(arg1,(char const *)arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
@@ -24928,7 +24316,7 @@ SWIGINTERN PyObject *_wrap_x509_type_check(PyObject *self, PyObject *args) {
   }
   result = (int)x509_type_check(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -24958,7 +24346,7 @@ SWIGINTERN PyObject *_wrap_x509_name_type_check(PyObject *self, PyObject *args)
   }
   result = (int)x509_name_type_check(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -25051,7 +24439,7 @@ SWIGINTERN PyObject *_wrap_x509_req_set_version(PyObject *self, PyObject *args)
   }
   result = (int)x509_req_set_version(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -25090,7 +24478,7 @@ SWIGINTERN PyObject *_wrap_x509_req_add_extensions(PyObject *self, PyObject *arg
   }
   result = (int)x509_req_add_extensions(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -25168,15 +24556,7 @@ SWIGINTERN PyObject *_wrap_x509v3_set_nconf(PyObject *self, PyObject *args) {
   X509V3_CTX *result = 0 ;
   
   result = (X509V3_CTX *)x509v3_set_nconf();
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_X509V3_CTX, 0);
-    else {
-      resultobj = NULL;
-    }
-  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_X509V3_CTX, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
@@ -25225,16 +24605,7 @@ SWIGINTERN PyObject *_wrap_x509v3_ext_conf(PyObject *self, PyObject *args) {
   }
   arg4 = (char *)(buf4);
   result = (X509_EXTENSION *)x509v3_ext_conf(arg1,arg2,arg3,arg4);
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_X509_EXTENSION, 0);
-    else {
-      m2_PyErr_Msg(_x509_err);
-      resultobj = NULL;
-    }
-  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_X509_EXTENSION, 0 |  0 );
   if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
   if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
   return resultobj;
@@ -25348,7 +24719,7 @@ SWIGINTERN PyObject *_wrap_sk_x509_extension_push(PyObject *self, PyObject *args
   arg2 = (X509_EXTENSION *)(argp2);
   result = (int)sk_x509_extension_push(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -25395,7 +24766,7 @@ SWIGINTERN PyObject *_wrap_sk_x509_extension_num(PyObject *self, PyObject *args)
   arg1 = (struct stack_st_X509_EXTENSION *)(argp1);
   result = (int)sk_x509_extension_num(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -25580,35 +24951,7 @@ SWIGINTERN PyObject *_wrap_make_stack_from_der_sequence(PyObject *self, PyObject
     arg1=obj0;
   }
   result = (struct stack_st_X509 *)make_stack_from_der_sequence(arg1);
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_stack_st_X509, 0);
-    else {
-      resultobj = NULL;
-    }
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_sk_x509_new_null(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  struct stack_st_X509 *result = 0 ;
-  
-  result = (struct stack_st_X509 *)sk_x509_new_null();
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_stack_st_X509, 0);
-    else {
-      resultobj = NULL;
-    }
-  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_stack_st_X509, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
@@ -25667,7 +25010,7 @@ SWIGINTERN PyObject *_wrap_x509_name_oneline(PyObject *self, PyObject *args) {
   resultobj = SWIG_FromCharPtr((const char *)result);
   {
     if (result != NULL)
-    OPENSSL_free(result);
+    OPENSSL_free(result); 
   }
   return resultobj;
 fail:
@@ -25807,7 +25150,7 @@ SWIGINTERN PyObject *_wrap_i2d_asn1_object(PyObject *self, PyObject *args) {
   }
   result = (int)i2d_ASN1_OBJECT(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -25924,11 +25267,13 @@ SWIGINTERN PyObject *_wrap_asn1_string_set(PyObject *self, PyObject *args) {
   }
   arg1 = (ASN1_STRING *)(argp1);
   {
-    if (PyBytes_Check(obj1)) {
+    if (PyString_Check(obj1)) {
       Py_ssize_t len;
       
-      arg2 = PyBytes_AsString(obj1);
-      len = PyBytes_Size(obj1);
+      arg2 = PyString_AsString(obj1);
+      len = PyString_Size(obj1);
+      
+      
       
       if (len > INT_MAX) {
         PyErr_SetString(PyExc_ValueError, "object too large");
@@ -25948,7 +25293,7 @@ SWIGINTERN PyObject *_wrap_asn1_string_set(PyObject *self, PyObject *args) {
   }
   result = (int)ASN1_STRING_set(arg1,(void const *)arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -25996,7 +25341,7 @@ SWIGINTERN PyObject *_wrap_asn1_string_print(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -26053,7 +25398,7 @@ SWIGINTERN PyObject *_wrap_asn1_string_print_ex(PyObject *self, PyObject *args)
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -26121,7 +25466,7 @@ SWIGINTERN PyObject *_wrap_asn1_time_check(PyObject *self, PyObject *args) {
   }
   result = (int)ASN1_TIME_check(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -26197,7 +25542,7 @@ SWIGINTERN PyObject *_wrap_asn1_time_set_string(PyObject *self, PyObject *args)
   }
   result = (int)ASN1_TIME_set_string(arg1,(char const *)arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
@@ -26247,7 +25592,7 @@ SWIGINTERN PyObject *_wrap_asn1_time_print(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -26329,7 +25674,7 @@ SWIGINTERN PyObject *_wrap_asn1_integer_cmp(PyObject *self, PyObject *args) {
   }
   result = (int)ASN1_INTEGER_cmp(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -26359,7 +25704,7 @@ SWIGINTERN PyObject *_wrap_asn1_time_type_check(PyObject *self, PyObject *args)
   }
   result = (int)asn1_time_type_check(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -26423,7 +25768,7 @@ SWIGINTERN PyObject *_wrap_asn1_integer_set(PyObject *self, PyObject *args) {
   }
   result = (int)asn1_integer_set(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -26594,11 +25939,11 @@ fail:
 }
 
 
-SWIGINTERN PyObject *_wrap_pkcs7_decrypt(PyObject *self, PyObject *args) {
+SWIGINTERN PyObject *_wrap_pkcs7_encrypt(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
-  PKCS7 *arg1 = (PKCS7 *) 0 ;
-  EVP_PKEY *arg2 = (EVP_PKEY *) 0 ;
-  X509 *arg3 = (X509 *) 0 ;
+  struct stack_st_X509 *arg1 = (struct stack_st_X509 *) 0 ;
+  BIO *arg2 = (BIO *) 0 ;
+  EVP_CIPHER *arg3 = (EVP_CIPHER *) 0 ;
   int arg4 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
@@ -26612,27 +25957,27 @@ SWIGINTERN PyObject *_wrap_pkcs7_decrypt(PyObject *self, PyObject *args) {
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
-  PyObject *result = 0 ;
+  PKCS7 *result = 0 ;
   
-  if(!PyArg_UnpackTuple(args,(char *)"pkcs7_decrypt",4,4,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_PKCS7, 0 |  0 );
+  if(!PyArg_UnpackTuple(args,(char *)"pkcs7_encrypt",4,4,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_stack_st_X509, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pkcs7_decrypt" "', argument " "1"" of type '" "PKCS7 *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pkcs7_encrypt" "', argument " "1"" of type '" "struct stack_st_X509 *""'"); 
   }
-  arg1 = (PKCS7 *)(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_EVP_PKEY, 0 |  0 );
+  arg1 = (struct stack_st_X509 *)(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_BIO, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "pkcs7_decrypt" "', argument " "2"" of type '" "EVP_PKEY *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "pkcs7_encrypt" "', argument " "2"" of type '" "BIO *""'"); 
   }
-  arg2 = (EVP_PKEY *)(argp2);
-  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_X509, 0 |  0 );
+  arg2 = (BIO *)(argp2);
+  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_EVP_CIPHER, 0 |  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "pkcs7_decrypt" "', argument " "3"" of type '" "X509 *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "pkcs7_encrypt" "', argument " "3"" of type '" "EVP_CIPHER *""'"); 
   }
-  arg3 = (X509 *)(argp3);
+  arg3 = (EVP_CIPHER *)(argp3);
   ecode4 = SWIG_AsVal_int(obj3, &val4);
   if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "pkcs7_decrypt" "', argument " "4"" of type '" "int""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "pkcs7_encrypt" "', argument " "4"" of type '" "int""'");
   } 
   arg4 = (int)(val4);
   {
@@ -26650,21 +25995,23 @@ SWIGINTERN PyObject *_wrap_pkcs7_decrypt(PyObject *self, PyObject *args) {
       SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
     }
   }
-  result = (PyObject *)pkcs7_decrypt(arg1,arg2,arg3,arg4);
   {
-    resultobj=result;
+    SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+    result = (PKCS7 *)pkcs7_encrypt(arg1,arg2,arg3,arg4);
+    SWIG_PYTHON_THREAD_END_ALLOW;
   }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PKCS7, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_pkcs7_encrypt(PyObject *self, PyObject *args) {
+SWIGINTERN PyObject *_wrap_pkcs7_decrypt(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
-  struct stack_st_X509 *arg1 = (struct stack_st_X509 *) 0 ;
-  BIO *arg2 = (BIO *) 0 ;
-  EVP_CIPHER *arg3 = (EVP_CIPHER *) 0 ;
+  PKCS7 *arg1 = (PKCS7 *) 0 ;
+  EVP_PKEY *arg2 = (EVP_PKEY *) 0 ;
+  X509 *arg3 = (X509 *) 0 ;
   int arg4 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
@@ -26678,27 +26025,27 @@ SWIGINTERN PyObject *_wrap_pkcs7_encrypt(PyObject *self, PyObject *args) {
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
-  PKCS7 *result = 0 ;
+  PyObject *result = 0 ;
   
-  if(!PyArg_UnpackTuple(args,(char *)"pkcs7_encrypt",4,4,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_stack_st_X509, 0 |  0 );
+  if(!PyArg_UnpackTuple(args,(char *)"pkcs7_decrypt",4,4,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_PKCS7, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pkcs7_encrypt" "', argument " "1"" of type '" "struct stack_st_X509 *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pkcs7_decrypt" "', argument " "1"" of type '" "PKCS7 *""'"); 
   }
-  arg1 = (struct stack_st_X509 *)(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_BIO, 0 |  0 );
+  arg1 = (PKCS7 *)(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_EVP_PKEY, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "pkcs7_encrypt" "', argument " "2"" of type '" "BIO *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "pkcs7_decrypt" "', argument " "2"" of type '" "EVP_PKEY *""'"); 
   }
-  arg2 = (BIO *)(argp2);
-  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_EVP_CIPHER, 0 |  0 );
+  arg2 = (EVP_PKEY *)(argp2);
+  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_X509, 0 |  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "pkcs7_encrypt" "', argument " "3"" of type '" "EVP_CIPHER *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "pkcs7_decrypt" "', argument " "3"" of type '" "X509 *""'"); 
   }
-  arg3 = (EVP_CIPHER *)(argp3);
+  arg3 = (X509 *)(argp3);
   ecode4 = SWIG_AsVal_int(obj3, &val4);
   if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "pkcs7_encrypt" "', argument " "4"" of type '" "int""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "pkcs7_decrypt" "', argument " "4"" of type '" "int""'");
   } 
   arg4 = (int)(val4);
   {
@@ -26716,20 +26063,9 @@ SWIGINTERN PyObject *_wrap_pkcs7_encrypt(PyObject *self, PyObject *args) {
       SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
     }
   }
+  result = (PyObject *)pkcs7_decrypt(arg1,arg2,arg3,arg4);
   {
-    SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-    result = (PKCS7 *)pkcs7_encrypt(arg1,arg2,arg3,arg4);
-    SWIG_PYTHON_THREAD_END_ALLOW;
-  }
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_PKCS7, 0);
-    else {
-      m2_PyErr_Msg(_smime_err);
-      resultobj = NULL;
-    }
+    resultobj=result;
   }
   return resultobj;
 fail:
@@ -26826,16 +26162,7 @@ SWIGINTERN PyObject *_wrap_pkcs7_sign1(PyObject *self, PyObject *args) {
     result = (PKCS7 *)pkcs7_sign1(arg1,arg2,arg3,arg4,arg5,arg6);
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_PKCS7, 0);
-    else {
-      m2_PyErr_Msg(_smime_err);
-      resultobj = NULL;
-    }
-  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PKCS7, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
@@ -26917,96 +26244,7 @@ SWIGINTERN PyObject *_wrap_pkcs7_sign0(PyObject *self, PyObject *args) {
     result = (PKCS7 *)pkcs7_sign0(arg1,arg2,arg3,arg4,arg5);
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_PKCS7, 0);
-    else {
-      m2_PyErr_Msg(_smime_err);
-      resultobj = NULL;
-    }
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_pkcs7_read_bio(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  BIO *arg1 = (BIO *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PKCS7 *result = 0 ;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"pkcs7_read_bio",1,1,&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pkcs7_read_bio" "', argument " "1"" of type '" "BIO *""'"); 
-  }
-  arg1 = (BIO *)(argp1);
-  {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  {
-    SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-    result = (PKCS7 *)pkcs7_read_bio(arg1);
-    SWIG_PYTHON_THREAD_END_ALLOW;
-  }
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_PKCS7, 0);
-    else {
-      m2_PyErr_Msg(_pkcs7_err);
-      resultobj = NULL;
-    }
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_pkcs7_read_bio_der(PyObject *self, PyObject *args) {
-  PyObject *resultobj = 0;
-  BIO *arg1 = (BIO *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PKCS7 *result = 0 ;
-  
-  if(!PyArg_UnpackTuple(args,(char *)"pkcs7_read_bio_der",1,1,&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pkcs7_read_bio_der" "', argument " "1"" of type '" "BIO *""'"); 
-  }
-  arg1 = (BIO *)(argp1);
-  {
-    if (!arg1) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
-  {
-    SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-    result = (PKCS7 *)pkcs7_read_bio_der(arg1);
-    SWIG_PYTHON_THREAD_END_ALLOW;
-  }
-  {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-    
-    if (result != NULL)
-    resultobj = SWIG_NewPointerObj(result, SWIGTYPE_p_PKCS7, 0);
-    else {
-      m2_PyErr_Msg(_pkcs7_err);
-      resultobj = NULL;
-    }
-  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PKCS7, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
@@ -27211,7 +26449,7 @@ SWIGINTERN PyObject *_wrap_smime_write_pkcs7_multi(PyObject *self, PyObject *arg
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -27242,53 +26480,113 @@ SWIGINTERN PyObject *_wrap_smime_write_pkcs7(PyObject *self, PyObject *args) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "smime_write_pkcs7" "', argument " "1"" of type '" "BIO *""'"); 
   }
   arg1 = (BIO *)(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_PKCS7, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "smime_write_pkcs7" "', argument " "2"" of type '" "PKCS7 *""'"); 
-  }
-  arg2 = (PKCS7 *)(argp2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "smime_write_pkcs7" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = (int)(val3);
+  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_PKCS7, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "smime_write_pkcs7" "', argument " "2"" of type '" "PKCS7 *""'"); 
+  }
+  arg2 = (PKCS7 *)(argp2);
+  ecode3 = SWIG_AsVal_int(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "smime_write_pkcs7" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = (int)(val3);
+  {
+    if (!arg1) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  {
+    if (!arg2) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  {
+    SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+    result = (int)smime_write_pkcs7(arg1,arg2,arg3);
+    SWIG_PYTHON_THREAD_END_ALLOW;
+  }
+  {
+    resultobj=PyInt_FromLong(result);
+    if (PyErr_Occurred()) SWIG_fail;
+  }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_smime_read_pkcs7(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0;
+  BIO *arg1 = (BIO *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject *result = 0 ;
+  
+  if(!PyArg_UnpackTuple(args,(char *)"smime_read_pkcs7",1,1,&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "smime_read_pkcs7" "', argument " "1"" of type '" "BIO *""'"); 
+  }
+  arg1 = (BIO *)(argp1);
+  {
+    if (!arg1) {
+      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
+    }
+  }
+  result = (PyObject *)smime_read_pkcs7(arg1);
+  {
+    resultobj=result;
+  }
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_pkcs7_read_bio(PyObject *self, PyObject *args) {
+  PyObject *resultobj = 0;
+  BIO *arg1 = (BIO *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PKCS7 *result = 0 ;
+  
+  if(!PyArg_UnpackTuple(args,(char *)"pkcs7_read_bio",1,1,&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pkcs7_read_bio" "', argument " "1"" of type '" "BIO *""'"); 
+  }
+  arg1 = (BIO *)(argp1);
   {
     if (!arg1) {
       SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
     }
   }
-  {
-    if (!arg2) {
-      SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
-    }
-  }
   {
     SWIG_PYTHON_THREAD_BEGIN_ALLOW;
-    result = (int)smime_write_pkcs7(arg1,arg2,arg3);
+    result = (PKCS7 *)pkcs7_read_bio(arg1);
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
-  {
-    resultobj=PyLong_FromLong(result);
-    if (PyErr_Occurred()) SWIG_fail;
-  }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PKCS7, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
 }
 
 
-SWIGINTERN PyObject *_wrap_smime_read_pkcs7(PyObject *self, PyObject *args) {
+SWIGINTERN PyObject *_wrap_pkcs7_read_bio_der(PyObject *self, PyObject *args) {
   PyObject *resultobj = 0;
   BIO *arg1 = (BIO *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   PyObject * obj0 = 0 ;
-  PyObject *result = 0 ;
+  PKCS7 *result = 0 ;
   
-  if(!PyArg_UnpackTuple(args,(char *)"smime_read_pkcs7",1,1,&obj0)) SWIG_fail;
+  if(!PyArg_UnpackTuple(args,(char *)"pkcs7_read_bio_der",1,1,&obj0)) SWIG_fail;
   res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_BIO, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "smime_read_pkcs7" "', argument " "1"" of type '" "BIO *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pkcs7_read_bio_der" "', argument " "1"" of type '" "BIO *""'"); 
   }
   arg1 = (BIO *)(argp1);
   {
@@ -27296,10 +26594,12 @@ SWIGINTERN PyObject *_wrap_smime_read_pkcs7(PyObject *self, PyObject *args) {
       SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
     }
   }
-  result = (PyObject *)smime_read_pkcs7(arg1);
   {
-    resultobj=result;
+    SWIG_PYTHON_THREAD_BEGIN_ALLOW;
+    result = (PKCS7 *)pkcs7_read_bio_der(arg1);
+    SWIG_PYTHON_THREAD_END_ALLOW;
   }
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PKCS7, 0 |  0 );
   return resultobj;
 fail:
   return NULL;
@@ -27345,7 +26645,7 @@ SWIGINTERN PyObject *_wrap_pkcs7_write_bio(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -27393,7 +26693,7 @@ SWIGINTERN PyObject *_wrap_pkcs7_write_bio_der(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -27423,7 +26723,7 @@ SWIGINTERN PyObject *_wrap_pkcs7_type_nid(PyObject *self, PyObject *args) {
   }
   result = (int)pkcs7_type_nid(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -27498,7 +26798,7 @@ SWIGINTERN PyObject *_wrap_smime_crlf_copy(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -27698,7 +26998,7 @@ SWIGINTERN PyObject *_wrap_ec_key_size(PyObject *self, PyObject *args) {
   }
   result = (int)ECDSA_size((EC_KEY const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -27728,7 +27028,7 @@ SWIGINTERN PyObject *_wrap_ec_key_gen_key(PyObject *self, PyObject *args) {
   }
   result = (int)EC_KEY_generate_key(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -27758,7 +27058,7 @@ SWIGINTERN PyObject *_wrap_ec_key_check_key(PyObject *self, PyObject *args) {
   }
   result = (int)EC_KEY_check_key((EC_KEY const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -27973,7 +27273,7 @@ SWIGINTERN PyObject *_wrap_ec_key_write_pubkey(PyObject *self, PyObject *args) {
     SWIG_PYTHON_THREAD_END_ALLOW;
   }
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -28086,7 +27386,7 @@ SWIGINTERN PyObject *_wrap_ec_key_write_bio(PyObject *self, PyObject *args) {
   }
   result = (int)ec_key_write_bio(arg1,arg2,arg3,arg4);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -28144,7 +27444,7 @@ SWIGINTERN PyObject *_wrap_ec_key_write_bio_no_cipher(PyObject *self, PyObject *
   }
   result = (int)ec_key_write_bio_no_cipher(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -28271,7 +27571,7 @@ SWIGINTERN PyObject *_wrap_ecdsa_verify(PyObject *self, PyObject *args) {
   }
   result = (int)ecdsa_verify(arg1,arg2,arg3,arg4);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -28345,7 +27645,7 @@ SWIGINTERN PyObject *_wrap_ecdsa_verify_asn1(PyObject *self, PyObject *args) {
   }
   result = (int)ecdsa_verify_asn1(arg1,arg2,arg3);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -28463,7 +27763,7 @@ SWIGINTERN PyObject *_wrap_ec_key_keylen(PyObject *self, PyObject *args) {
   }
   result = (int)ec_key_keylen(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -28493,7 +27793,7 @@ SWIGINTERN PyObject *_wrap_ec_key_type_check(PyObject *self, PyObject *args) {
   }
   result = (int)ec_key_type_check(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -28609,7 +27909,7 @@ SWIGINTERN PyObject *_wrap_engine_free(PyObject *self, PyObject *args) {
   }
   result = (int)ENGINE_free(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -28639,7 +27939,7 @@ SWIGINTERN PyObject *_wrap_engine_init(PyObject *self, PyObject *args) {
   }
   result = (int)ENGINE_init(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -28669,7 +27969,7 @@ SWIGINTERN PyObject *_wrap_engine_finish(PyObject *self, PyObject *args) {
   }
   result = (int)ENGINE_finish(arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -28782,7 +28082,7 @@ SWIGINTERN PyObject *_wrap_engine_ctrl_cmd_string(PyObject *self, PyObject *args
   }
   result = (int)ENGINE_ctrl_cmd_string(arg1,(char const *)arg2,(char const *)arg3,arg4);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
@@ -29234,7 +28534,7 @@ SWIGINTERN PyObject *_wrap_engine_set_default(PyObject *self, PyObject *args) {
   }
   result = (int)ENGINE_set_default(arg1,arg2);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -29330,7 +28630,7 @@ SWIGINTERN PyObject *_wrap_obj_obj2nid(PyObject *self, PyObject *args) {
   }
   result = (int)OBJ_obj2nid((ASN1_OBJECT const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   return resultobj;
@@ -29361,7 +28661,7 @@ SWIGINTERN PyObject *_wrap_obj_ln2nid(PyObject *self, PyObject *args) {
   }
   result = (int)OBJ_ln2nid((char const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
@@ -29394,7 +28694,7 @@ SWIGINTERN PyObject *_wrap_obj_sn2nid(PyObject *self, PyObject *args) {
   }
   result = (int)OBJ_sn2nid((char const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
@@ -29427,7 +28727,7 @@ SWIGINTERN PyObject *_wrap_obj_txt2nid(PyObject *self, PyObject *args) {
   }
   result = (int)OBJ_txt2nid((char const *)arg1);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
@@ -29526,7 +28826,7 @@ SWIGINTERN PyObject *_wrap__obj_obj2txt(PyObject *self, PyObject *args) {
   }
   result = (int)OBJ_obj2txt(arg1,arg2,(ASN1_OBJECT const *)arg3,arg4);
   {
-    resultobj=PyLong_FromLong(result);
+    resultobj=PyInt_FromLong(result);
     if (PyErr_Occurred()) SWIG_fail;
   }
   if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
@@ -29623,15 +28923,13 @@ static PyMethodDef SwigMethods[] = {
 	 { (char *)"bio_f_cipher", _wrap_bio_f_cipher, METH_VARARGS, NULL},
 	 { (char *)"bio_new", _wrap_bio_new, METH_VARARGS, NULL},
 	 { (char *)"bio_new_socket", _wrap_bio_new_socket, METH_VARARGS, NULL},
+	 { (char *)"bio_new_file", _wrap_bio_new_file, METH_VARARGS, NULL},
+	 { (char *)"bio_free", _wrap_bio_free, METH_VARARGS, NULL},
 	 { (char *)"bio_free_all", _wrap_bio_free_all, METH_VARARGS, NULL},
 	 { (char *)"bio_dup_chain", _wrap_bio_dup_chain, METH_VARARGS, NULL},
 	 { (char *)"bio_push", _wrap_bio_push, METH_VARARGS, NULL},
 	 { (char *)"bio_pop", _wrap_bio_pop, METH_VARARGS, NULL},
-	 { (char *)"bio_eof", _wrap_bio_eof, METH_VARARGS, NULL},
-	 { (char *)"pyfd_init", _wrap_pyfd_init, METH_VARARGS, NULL},
 	 { (char *)"bio_init", _wrap_bio_init, METH_VARARGS, NULL},
-	 { (char *)"bio_free", _wrap_bio_free, METH_VARARGS, NULL},
-	 { (char *)"bio_new_file", _wrap_bio_new_file, METH_VARARGS, NULL},
 	 { (char *)"bio_new_pyfile", _wrap_bio_new_pyfile, METH_VARARGS, NULL},
 	 { (char *)"bio_read", _wrap_bio_read, METH_VARARGS, NULL},
 	 { (char *)"bio_gets", _wrap_bio_gets, METH_VARARGS, NULL},
@@ -29654,16 +28952,6 @@ static PyMethodDef SwigMethods[] = {
 	 { (char *)"bio_should_retry", _wrap_bio_should_retry, METH_VARARGS, NULL},
 	 { (char *)"bio_should_read", _wrap_bio_should_read, METH_VARARGS, NULL},
 	 { (char *)"bio_should_write", _wrap_bio_should_write, METH_VARARGS, NULL},
-	 { (char *)"BIO_meth_new", _wrap_BIO_meth_new, METH_VARARGS, NULL},
-	 { (char *)"BIO_meth_free", _wrap_BIO_meth_free, METH_VARARGS, NULL},
-	 { (char *)"pyfd_write", _wrap_pyfd_write, METH_VARARGS, NULL},
-	 { (char *)"pyfd_read", _wrap_pyfd_read, METH_VARARGS, NULL},
-	 { (char *)"pyfd_puts", _wrap_pyfd_puts, METH_VARARGS, NULL},
-	 { (char *)"pyfd_gets", _wrap_pyfd_gets, METH_VARARGS, NULL},
-	 { (char *)"pyfd_new", _wrap_pyfd_new, METH_VARARGS, NULL},
-	 { (char *)"pyfd_free", _wrap_pyfd_free, METH_VARARGS, NULL},
-	 { (char *)"pyfd_ctrl", _wrap_pyfd_ctrl, METH_VARARGS, NULL},
-	 { (char *)"bio_new_pyfd", _wrap_bio_new_pyfd, METH_VARARGS, NULL},
 	 { (char *)"bn_rand", _wrap_bn_rand, METH_VARARGS, NULL},
 	 { (char *)"bn_rand_range", _wrap_bn_rand_range, METH_VARARGS, NULL},
 	 { (char *)"rand_load_file", _wrap_rand_load_file, METH_VARARGS, NULL},
@@ -29687,6 +28975,7 @@ static PyMethodDef SwigMethods[] = {
 	 { (char *)"sha384", _wrap_sha384, METH_VARARGS, NULL},
 	 { (char *)"sha512", _wrap_sha512, METH_VARARGS, NULL},
 	 { (char *)"digest_init", _wrap_digest_init, METH_VARARGS, NULL},
+	 { (char *)"get_digestbyname", _wrap_get_digestbyname, METH_VARARGS, NULL},
 	 { (char *)"des_ecb", _wrap_des_ecb, METH_VARARGS, NULL},
 	 { (char *)"des_ede_ecb", _wrap_des_ede_ecb, METH_VARARGS, NULL},
 	 { (char *)"des_ede3_ecb", _wrap_des_ede3_ecb, METH_VARARGS, NULL},
@@ -29725,15 +29014,16 @@ static PyMethodDef SwigMethods[] = {
 	 { (char *)"aes_256_ofb", _wrap_aes_256_ofb, METH_VARARGS, NULL},
 	 { (char *)"aes_256_ctr", _wrap_aes_256_ctr, METH_VARARGS, NULL},
 	 { (char *)"cipher_set_padding", _wrap_cipher_set_padding, METH_VARARGS, NULL},
+	 { (char *)"pkey_new", _wrap_pkey_new, METH_VARARGS, NULL},
 	 { (char *)"pkey_free", _wrap_pkey_free, METH_VARARGS, NULL},
 	 { (char *)"pkey_assign", _wrap_pkey_assign, METH_VARARGS, NULL},
 	 { (char *)"pkey_assign_ec", _wrap_pkey_assign_ec, METH_VARARGS, NULL},
 	 { (char *)"pkey_set1_rsa", _wrap_pkey_set1_rsa, METH_VARARGS, NULL},
+	 { (char *)"pkey_get1_rsa", _wrap_pkey_get1_rsa, METH_VARARGS, NULL},
 	 { (char *)"sign_init", _wrap_sign_init, METH_VARARGS, NULL},
 	 { (char *)"verify_init", _wrap_verify_init, METH_VARARGS, NULL},
 	 { (char *)"pkey_size", _wrap_pkey_size, METH_VARARGS, NULL},
 	 { (char *)"evp_init", _wrap_evp_init, METH_VARARGS, NULL},
-	 { (char *)"pkey_get1_rsa", _wrap_pkey_get1_rsa, METH_VARARGS, NULL},
 	 { (char *)"pkcs5_pbkdf2_hmac_sha1", _wrap_pkcs5_pbkdf2_hmac_sha1, METH_VARARGS, NULL},
 	 { (char *)"md_ctx_new", _wrap_md_ctx_new, METH_VARARGS, NULL},
 	 { (char *)"md_ctx_free", _wrap_md_ctx_free, METH_VARARGS, NULL},
@@ -29755,10 +29045,8 @@ static PyMethodDef SwigMethods[] = {
 	 { (char *)"sign_final", _wrap_sign_final, METH_VARARGS, NULL},
 	 { (char *)"verify_update", _wrap_verify_update, METH_VARARGS, NULL},
 	 { (char *)"verify_final", _wrap_verify_final, METH_VARARGS, NULL},
-	 { (char *)"get_digestbyname", _wrap_get_digestbyname, METH_VARARGS, NULL},
 	 { (char *)"pkey_write_pem_no_cipher", _wrap_pkey_write_pem_no_cipher, METH_VARARGS, NULL},
 	 { (char *)"pkey_write_pem", _wrap_pkey_write_pem, METH_VARARGS, NULL},
-	 { (char *)"pkey_new", _wrap_pkey_new, METH_VARARGS, NULL},
 	 { (char *)"pkey_read_pem", _wrap_pkey_read_pem, METH_VARARGS, NULL},
 	 { (char *)"pkey_read_pem_pubkey", _wrap_pkey_read_pem_pubkey, METH_VARARGS, NULL},
 	 { (char *)"pkey_assign_rsa", _wrap_pkey_assign_rsa, METH_VARARGS, NULL},
@@ -29825,9 +29113,6 @@ static PyMethodDef SwigMethods[] = {
 	 { (char *)"dsa_gen_key", _wrap_dsa_gen_key, METH_VARARGS, NULL},
 	 { (char *)"dsa_init", _wrap_dsa_init, METH_VARARGS, NULL},
 	 { (char *)"dsa_generate_parameters", _wrap_dsa_generate_parameters, METH_VARARGS, NULL},
-	 { (char *)"dsa_read_params", _wrap_dsa_read_params, METH_VARARGS, NULL},
-	 { (char *)"dsa_read_key", _wrap_dsa_read_key, METH_VARARGS, NULL},
-	 { (char *)"dsa_read_pub_key", _wrap_dsa_read_pub_key, METH_VARARGS, NULL},
 	 { (char *)"dsa_get_p", _wrap_dsa_get_p, METH_VARARGS, NULL},
 	 { (char *)"dsa_get_q", _wrap_dsa_get_q, METH_VARARGS, NULL},
 	 { (char *)"dsa_get_g", _wrap_dsa_get_g, METH_VARARGS, NULL},
@@ -29835,10 +29120,13 @@ static PyMethodDef SwigMethods[] = {
 	 { (char *)"dsa_get_priv", _wrap_dsa_get_priv, METH_VARARGS, NULL},
 	 { (char *)"dsa_set_pqg", _wrap_dsa_set_pqg, METH_VARARGS, NULL},
 	 { (char *)"dsa_set_pub", _wrap_dsa_set_pub, METH_VARARGS, NULL},
+	 { (char *)"dsa_read_params", _wrap_dsa_read_params, METH_VARARGS, NULL},
 	 { (char *)"dsa_write_params_bio", _wrap_dsa_write_params_bio, METH_VARARGS, NULL},
 	 { (char *)"dsa_write_key_bio", _wrap_dsa_write_key_bio, METH_VARARGS, NULL},
 	 { (char *)"dsa_write_key_bio_no_cipher", _wrap_dsa_write_key_bio_no_cipher, METH_VARARGS, NULL},
 	 { (char *)"dsa_write_pub_key_bio", _wrap_dsa_write_pub_key_bio, METH_VARARGS, NULL},
+	 { (char *)"dsa_read_key", _wrap_dsa_read_key, METH_VARARGS, NULL},
+	 { (char *)"dsa_read_pub_key", _wrap_dsa_read_pub_key, METH_VARARGS, NULL},
 	 { (char *)"dsa_sign", _wrap_dsa_sign, METH_VARARGS, NULL},
 	 { (char *)"dsa_verify", _wrap_dsa_verify, METH_VARARGS, NULL},
 	 { (char *)"dsa_sign_asn1", _wrap_dsa_sign_asn1, METH_VARARGS, NULL},
@@ -30018,12 +29306,12 @@ static PyMethodDef SwigMethods[] = {
 	 { (char *)"x509_store_ctx_get1_chain", _wrap_x509_store_ctx_get1_chain, METH_VARARGS, NULL},
 	 { (char *)"x509_extension_get_critical", _wrap_x509_extension_get_critical, METH_VARARGS, NULL},
 	 { (char *)"x509_extension_set_critical", _wrap_x509_extension_set_critical, METH_VARARGS, NULL},
+	 { (char *)"x509_init", _wrap_x509_init, METH_VARARGS, NULL},
 	 { (char *)"x509_read_pem", _wrap_x509_read_pem, METH_VARARGS, NULL},
 	 { (char *)"d2i_x509", _wrap_d2i_x509, METH_VARARGS, NULL},
-	 { (char *)"x509_init", _wrap_x509_init, METH_VARARGS, NULL},
 	 { (char *)"d2i_x509_req", _wrap_d2i_x509_req, METH_VARARGS, NULL},
-	 { (char *)"x509_req_read_pem", _wrap_x509_req_read_pem, METH_VARARGS, NULL},
 	 { (char *)"i2d_x509", _wrap_i2d_x509, METH_VARARGS, NULL},
+	 { (char *)"x509_req_read_pem", _wrap_x509_req_read_pem, METH_VARARGS, NULL},
 	 { (char *)"x509_req_write_pem", _wrap_x509_req_write_pem, METH_VARARGS, NULL},
 	 { (char *)"x509_crl_read_pem", _wrap_x509_crl_read_pem, METH_VARARGS, NULL},
 	 { (char *)"x509_set_version", _wrap_x509_set_version, METH_VARARGS, NULL},
@@ -30038,6 +29326,7 @@ static PyMethodDef SwigMethods[] = {
 	 { (char *)"x509_name_set_by_nid", _wrap_x509_name_set_by_nid, METH_VARARGS, NULL},
 	 { (char *)"x509_name_add_entry_by_txt", _wrap_x509_name_add_entry_by_txt, METH_VARARGS, NULL},
 	 { (char *)"x509_name_get_der", _wrap_x509_name_get_der, METH_VARARGS, NULL},
+	 { (char *)"sk_x509_new_null", _wrap_sk_x509_new_null, METH_VARARGS, NULL},
 	 { (char *)"sk_x509_free", _wrap_sk_x509_free, METH_VARARGS, NULL},
 	 { (char *)"sk_x509_push", _wrap_sk_x509_push, METH_VARARGS, NULL},
 	 { (char *)"sk_x509_pop", _wrap_sk_x509_pop, METH_VARARGS, NULL},
@@ -30063,7 +29352,6 @@ static PyMethodDef SwigMethods[] = {
 	 { (char *)"x509_store_ctx_get_ex_data", _wrap_x509_store_ctx_get_ex_data, METH_VARARGS, NULL},
 	 { (char *)"x509_store_set_verify_cb", _wrap_x509_store_set_verify_cb, METH_VARARGS, NULL},
 	 { (char *)"make_stack_from_der_sequence", _wrap_make_stack_from_der_sequence, METH_VARARGS, NULL},
-	 { (char *)"sk_x509_new_null", _wrap_sk_x509_new_null, METH_VARARGS, NULL},
 	 { (char *)"get_der_encoding_stack", _wrap_get_der_encoding_stack, METH_VARARGS, NULL},
 	 { (char *)"x509_name_oneline", _wrap_x509_name_oneline, METH_VARARGS, NULL},
 	 { (char *)"asn1_object_new", _wrap_asn1_object_new, METH_VARARGS, NULL},
@@ -30094,17 +29382,17 @@ static PyMethodDef SwigMethods[] = {
 	 { (char *)"pkcs7_add_certificate", _wrap_pkcs7_add_certificate, METH_VARARGS, NULL},
 	 { (char *)"pkcs7_init", _wrap_pkcs7_init, METH_VARARGS, NULL},
 	 { (char *)"smime_init", _wrap_smime_init, METH_VARARGS, NULL},
-	 { (char *)"pkcs7_decrypt", _wrap_pkcs7_decrypt, METH_VARARGS, NULL},
 	 { (char *)"pkcs7_encrypt", _wrap_pkcs7_encrypt, METH_VARARGS, NULL},
+	 { (char *)"pkcs7_decrypt", _wrap_pkcs7_decrypt, METH_VARARGS, NULL},
 	 { (char *)"pkcs7_sign1", _wrap_pkcs7_sign1, METH_VARARGS, NULL},
 	 { (char *)"pkcs7_sign0", _wrap_pkcs7_sign0, METH_VARARGS, NULL},
-	 { (char *)"pkcs7_read_bio", _wrap_pkcs7_read_bio, METH_VARARGS, NULL},
-	 { (char *)"pkcs7_read_bio_der", _wrap_pkcs7_read_bio_der, METH_VARARGS, NULL},
 	 { (char *)"pkcs7_verify1", _wrap_pkcs7_verify1, METH_VARARGS, NULL},
 	 { (char *)"pkcs7_verify0", _wrap_pkcs7_verify0, METH_VARARGS, NULL},
 	 { (char *)"smime_write_pkcs7_multi", _wrap_smime_write_pkcs7_multi, METH_VARARGS, NULL},
 	 { (char *)"smime_write_pkcs7", _wrap_smime_write_pkcs7, METH_VARARGS, NULL},
 	 { (char *)"smime_read_pkcs7", _wrap_smime_read_pkcs7, METH_VARARGS, NULL},
+	 { (char *)"pkcs7_read_bio", _wrap_pkcs7_read_bio, METH_VARARGS, NULL},
+	 { (char *)"pkcs7_read_bio_der", _wrap_pkcs7_read_bio_der, METH_VARARGS, NULL},
 	 { (char *)"pkcs7_write_bio", _wrap_pkcs7_write_bio, METH_VARARGS, NULL},
 	 { (char *)"pkcs7_write_bio_der", _wrap_pkcs7_write_bio_der, METH_VARARGS, NULL},
 	 { (char *)"pkcs7_type_nid", _wrap_pkcs7_type_nid, METH_VARARGS, NULL},
@@ -30767,200 +30055,6 @@ static PyHeapTypeObject SwigPyBuiltin__stack_st_OPENSSL_BLOCK_type = {
 
 SWIGINTERN SwigPyClientData SwigPyBuiltin__stack_st_OPENSSL_BLOCK_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__stack_st_OPENSSL_BLOCK_type};
 
-SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_BIO_PYFD_CTX)
-static SwigPyGetSet BIO_PYFD_CTX_fd_getset = { _wrap_BIO_PYFD_CTX_fd_get, _wrap_BIO_PYFD_CTX_fd_set };
-SWIGINTERN PyGetSetDef SwigPyBuiltin__pyfd_struct_getset[] = {
-    { (char*) "fd", (getter) SwigPyBuiltin_GetterClosure, (setter) SwigPyBuiltin_SetterClosure, (char*)"pyfd_struct.fd", (void*) &BIO_PYFD_CTX_fd_getset }
-,
-    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
-};
-
-SWIGINTERN PyObject *
-SwigPyBuiltin__pyfd_struct_richcompare(PyObject *self, PyObject *other, int op) {
-  PyObject *result = NULL;
-  PyObject *tuple = PyTuple_New(1);
-  assert(tuple);
-  PyTuple_SET_ITEM(tuple, 0, other);
-  Py_XINCREF(other);
-  if (!result) {
-    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
-      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
-    } else {
-      result = Py_NotImplemented;
-      Py_INCREF(result);
-    }
-  }
-  Py_DECREF(tuple);
-  return result;
-}
-
-SWIGINTERN PyMethodDef SwigPyBuiltin__pyfd_struct_methods[] = {
-  { NULL, NULL, 0, NULL } /* Sentinel */
-};
-
-static PyHeapTypeObject SwigPyBuiltin__pyfd_struct_type = {
-  {
-#if PY_VERSION_HEX >= 0x03000000
-    PyVarObject_HEAD_INIT(NULL, 0)
-#else
-    PyObject_HEAD_INIT(NULL)
-    0,                                        /* ob_size */
-#endif
-    "BIO_PYFD_CTX",                           /* tp_name */
-    sizeof(SwigPyObject),                     /* tp_basicsize */
-    0,                                        /* tp_itemsize */
-    (destructor) _wrap_delete_BIO_PYFD_CTX_closure, /* tp_dealloc */
-    (printfunc) 0,                            /* tp_print */
-    (getattrfunc) 0,                          /* tp_getattr */
-    (setattrfunc) 0,                          /* tp_setattr */
-#if PY_VERSION_HEX >= 0x03000000
-    0,                                        /* tp_compare */
-#else
-    (cmpfunc) 0,                              /* tp_compare */
-#endif
-    (reprfunc) 0,                             /* tp_repr */
-    &SwigPyBuiltin__pyfd_struct_type.as_number,      /* tp_as_number */
-    &SwigPyBuiltin__pyfd_struct_type.as_sequence,    /* tp_as_sequence */
-    &SwigPyBuiltin__pyfd_struct_type.as_mapping,     /* tp_as_mapping */
-    (hashfunc) 0,                             /* tp_hash */
-    (ternaryfunc) 0,                          /* tp_call */
-    (reprfunc) 0,                             /* tp_str */
-    (getattrofunc) 0,                         /* tp_getattro */
-    (setattrofunc) 0,                         /* tp_setattro */
-    &SwigPyBuiltin__pyfd_struct_type.as_buffer,      /* tp_as_buffer */
-#if PY_VERSION_HEX >= 0x03000000
-    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
-#else
-    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
-#endif
-    "::pyfd_struct",                          /* tp_doc */
-    (traverseproc) 0,                         /* tp_traverse */
-    (inquiry) 0,                              /* tp_clear */
-    (richcmpfunc) SwigPyBuiltin__pyfd_struct_richcompare, /* feature:python:tp_richcompare */
-    0,                                        /* tp_weaklistoffset */
-    (getiterfunc) 0,                          /* tp_iter */
-    (iternextfunc) 0,                         /* tp_iternext */
-    SwigPyBuiltin__pyfd_struct_methods,       /* tp_methods */
-    0,                                        /* tp_members */
-    SwigPyBuiltin__pyfd_struct_getset,        /* tp_getset */
-    0,                                        /* tp_base */
-    0,                                        /* tp_dict */
-    (descrgetfunc) 0,                         /* tp_descr_get */
-    (descrsetfunc) 0,                         /* tp_descr_set */
-    (size_t)(((char*)&((SwigPyObject *) 64L)->dict) - (char*) 64L), /* tp_dictoffset */
-    (initproc) _wrap_new_BIO_PYFD_CTX,        /* tp_init */
-    (allocfunc) 0,                            /* tp_alloc */
-    (newfunc) 0,                              /* tp_new */
-    (freefunc) 0,                             /* tp_free */
-    (inquiry) 0,                              /* tp_is_gc */
-    (PyObject*) 0,                            /* tp_bases */
-    (PyObject*) 0,                            /* tp_mro */
-    (PyObject*) 0,                            /* tp_cache */
-    (PyObject*) 0,                            /* tp_subclasses */
-    (PyObject*) 0,                            /* tp_weaklist */
-    (destructor) 0,                           /* tp_del */
-#if PY_VERSION_HEX >= 0x02060000
-    (int) 0,                                  /* tp_version_tag */
-#endif
-  },
-  {
-    (binaryfunc) 0,                           /* nb_add */
-    (binaryfunc) 0,                           /* nb_subtract */
-    (binaryfunc) 0,                           /* nb_multiply */
-#if PY_VERSION_HEX < 0x03000000
-    (binaryfunc) 0,                           /* nb_divide */
-#endif
-    (binaryfunc) 0,                           /* nb_remainder */
-    (binaryfunc) 0,                           /* nb_divmod */
-    (ternaryfunc) 0,                          /* nb_power */
-    (unaryfunc) 0,                            /* nb_negative */
-    (unaryfunc) 0,                            /* nb_positive */
-    (unaryfunc) 0,                            /* nb_absolute */
-    (inquiry) 0,                              /* nb_nonzero */
-    (unaryfunc) 0,                            /* nb_invert */
-    (binaryfunc) 0,                           /* nb_lshift */
-    (binaryfunc) 0,                           /* nb_rshift */
-    (binaryfunc) 0,                           /* nb_and */
-    (binaryfunc) 0,                           /* nb_xor */
-    (binaryfunc) 0,                           /* nb_or */
-#if PY_VERSION_HEX < 0x03000000
-    (coercion) 0,                             /* nb_coerce */
-#endif
-    (unaryfunc) 0,                            /* nb_int */
-#if PY_VERSION_HEX >= 0x03000000
-    (void*) 0,                                /* nb_reserved */
-#else
-    (unaryfunc) 0,                            /* nb_long */
-#endif
-    (unaryfunc) 0,                            /* nb_float */
-#if PY_VERSION_HEX < 0x03000000
-    (unaryfunc) 0,                            /* nb_oct */
-    (unaryfunc) 0,                            /* nb_hex */
-#endif
-    (binaryfunc) 0,                           /* nb_inplace_add */
-    (binaryfunc) 0,                           /* nb_inplace_subtract */
-    (binaryfunc) 0,                           /* nb_inplace_multiply */
-#if PY_VERSION_HEX < 0x03000000
-    (binaryfunc) 0,                           /* nb_inplace_divide */
-#endif
-    (binaryfunc) 0,                           /* nb_inplace_remainder */
-    (ternaryfunc) 0,                          /* nb_inplace_power */
-    (binaryfunc) 0,                           /* nb_inplace_lshift */
-    (binaryfunc) 0,                           /* nb_inplace_rshift */
-    (binaryfunc) 0,                           /* nb_inplace_and */
-    (binaryfunc) 0,                           /* nb_inplace_xor */
-    (binaryfunc) 0,                           /* nb_inplace_or */
-    (binaryfunc) 0,                           /* nb_floor_divide */
-    (binaryfunc) 0,                           /* nb_true_divide */
-    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
-    (binaryfunc) 0,                           /* nb_inplace_true_divide */
-#if PY_VERSION_HEX >= 0x02050000
-    (unaryfunc) 0,                            /* nb_index */
-#endif
-  },
-  {
-    (lenfunc) 0,                              /* mp_length */
-    (binaryfunc) 0,                           /* mp_subscript */
-    (objobjargproc) 0,                        /* mp_ass_subscript */
-  },
-  {
-    (lenfunc) 0,                              /* sq_length */
-    (binaryfunc) 0,                           /* sq_concat */
-    (ssizeargfunc) 0,                         /* sq_repeat */
-    (ssizeargfunc) 0,                         /* sq_item */
-#if PY_VERSION_HEX >= 0x03000000
-    (void*) 0,                                /* was_sq_slice */
-#else
-    (ssizessizeargfunc) 0,                    /* sq_slice */
-#endif
-    (ssizeobjargproc) 0,                      /* sq_ass_item */
-#if PY_VERSION_HEX >= 0x03000000
-    (void*) 0,                                /* was_sq_ass_slice */
-#else
-    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
-#endif
-    (objobjproc) 0,                           /* sq_contains */
-    (binaryfunc) 0,                           /* sq_inplace_concat */
-    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
-  },
-  {
-#if PY_VERSION_HEX < 0x03000000
-    (readbufferproc) 0,                       /* bf_getreadbuffer */
-    (writebufferproc) 0,                      /* bf_getwritebuffer */
-    (segcountproc) 0,                         /* bf_getsegcount */
-    (charbufferproc) 0,                       /* bf_getcharbuffer */
-#endif
-#if PY_VERSION_HEX >= 0x02060000
-    (getbufferproc) 0,                        /* bf_getbuffer */
-    (releasebufferproc) 0,                    /* bf_releasebuffer */
-#endif
-  },
-    (PyObject*) 0,                            /* ht_name */
-    (PyObject*) 0,                            /* ht_slots */
-};
-
-SWIGINTERN SwigPyClientData SwigPyBuiltin__pyfd_struct_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__pyfd_struct_type};
-
 SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete__cbd_t)
 static SwigPyGetSet _cbd_t_password_getset = { _wrap__cbd_t_password_get, _wrap__cbd_t_password_set };
 static SwigPyGetSet _cbd_t_prompt_getset = { _wrap__cbd_t_prompt_get, _wrap__cbd_t_prompt_set };
@@ -31212,7 +30306,6 @@ static swig_type_info _swigt__p_p_ASN1_OBJECT = {"_p_p_ASN1_OBJECT", "ASN1_OBJEC
 static swig_type_info _swigt__p_p_X509_NAME_ENTRY = {"_p_p_X509_NAME_ENTRY", "X509_NAME_ENTRY **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_p_unsigned_char = {"_p_p_unsigned_char", "unsigned char **", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_pyfd_struct = {"_p_pyfd_struct", "BIO_PYFD_CTX *|struct pyfd_struct *|pyfd_struct *", 0, 0, (void*)&SwigPyBuiltin__pyfd_struct_clientdata, 0};
 static swig_type_info _swigt__p_stack_st = {"_p_stack_st", "struct stack_st *|stack_st *|_STACK *", 0, 0, (void*)&SwigPyBuiltin__stack_st_clientdata, 0};
 static swig_type_info _swigt__p_stack_st_OPENSSL_BLOCK = {"_p_stack_st_OPENSSL_BLOCK", "struct stack_st_OPENSSL_BLOCK *|stack_st_OPENSSL_BLOCK *", 0, 0, (void*)&SwigPyBuiltin__stack_st_OPENSSL_BLOCK_clientdata, 0};
 static swig_type_info _swigt__p_stack_st_OPENSSL_STRING = {"_p_stack_st_OPENSSL_STRING", "struct stack_st_OPENSSL_STRING *|stack_st_OPENSSL_STRING *", 0, 0, (void*)&SwigPyBuiltin__stack_st_OPENSSL_STRING_clientdata, 0};
@@ -31274,7 +30367,6 @@ static swig_type_info *swig_type_initial[] = {
   &_swigt__p_p_X509_NAME_ENTRY,
   &_swigt__p_p_char,
   &_swigt__p_p_unsigned_char,
-  &_swigt__p_pyfd_struct,
   &_swigt__p_stack_st,
   &_swigt__p_stack_st_OPENSSL_BLOCK,
   &_swigt__p_stack_st_OPENSSL_STRING,
@@ -31336,7 +30428,6 @@ static swig_cast_info _swigc__p_p_ASN1_OBJECT[] = {  {&_swigt__p_p_ASN1_OBJECT,
 static swig_cast_info _swigc__p_p_X509_NAME_ENTRY[] = {  {&_swigt__p_p_X509_NAME_ENTRY, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_p_unsigned_char[] = {  {&_swigt__p_p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_pyfd_struct[] = {  {&_swigt__p_pyfd_struct, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_stack_st[] = {  {&_swigt__p_stack_st, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_stack_st_OPENSSL_BLOCK[] = {  {&_swigt__p_stack_st_OPENSSL_BLOCK, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_stack_st_OPENSSL_STRING[] = {  {&_swigt__p_stack_st_OPENSSL_STRING, 0, 0, 0},{0, 0, 0, 0}};
@@ -31398,7 +30489,6 @@ static swig_cast_info *swig_cast_initial[] = {
   _swigc__p_p_X509_NAME_ENTRY,
   _swigc__p_p_char,
   _swigc__p_p_unsigned_char,
-  _swigc__p_pyfd_struct,
   _swigc__p_stack_st,
   _swigc__p_stack_st_OPENSSL_BLOCK,
   _swigc__p_stack_st_OPENSSL_STRING,
@@ -32178,30 +31268,6 @@ SWIG_init(void) {
   PyDict_SetItemString(md,(char*)"cvar", SWIG_globals());
   SwigPyBuiltin_AddPublicSymbol(public_interface, "cvar");
   SWIG_addvarlink(SWIG_globals(),(char*)"_bio_err",Swig_var__bio_err_get, Swig_var__bio_err_set);
-  
-  /* type '::pyfd_struct' */
-  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__pyfd_struct_type;
-  builtin_pytype->tp_dict = d = PyDict_New();
-  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
-  builtin_pytype->tp_new = PyType_GenericNew;
-  builtin_base_count = 0;
-  builtin_bases[builtin_base_count] = NULL;
-  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
-  PyDict_SetItemString(d, "this", this_descr);
-  PyDict_SetItemString(d, "thisown", thisown_descr);
-  if (PyType_Ready(builtin_pytype) < 0) {
-    PyErr_SetString(PyExc_TypeError, "Could not create type 'BIO_PYFD_CTX'.");
-#if PY_VERSION_HEX >= 0x03000000
-    return NULL;
-#else
-    return;
-#endif
-  }
-  Py_INCREF(builtin_pytype);
-  PyModule_AddObject(m, "BIO_PYFD_CTX", (PyObject*) builtin_pytype);
-  SwigPyBuiltin_AddPublicSymbol(public_interface, "BIO_PYFD_CTX");
-  d = md;
-  SWIG_addvarlink(SWIG_globals(),(char*)"methods_fdp",Swig_var_methods_fdp_get, Swig_var_methods_fdp_set);
   SWIG_addvarlink(SWIG_globals(),(char*)"_rand_err",Swig_var__rand_err_get, Swig_var__rand_err_set);
   SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "PKCS5_SALT_LEN",SWIG_From_int((int)(8)));
   SWIG_addvarlink(SWIG_globals(),(char*)"_evp_err",Swig_var__evp_err_get, Swig_var__evp_err_set);
diff --git a/SWIG/_objects.i b/SWIG/_objects.i
index b389d7f..36ed302 100644
--- a/SWIG/_objects.i
+++ b/SWIG/_objects.i
@@ -88,7 +88,11 @@ PyObject *obj_obj2txt(const ASN1_OBJECT *obj, int no_name)
     buf = PyMem_Malloc(len + 1);
     len = OBJ_obj2txt(buf, len + 1, obj, no_name);
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(buf, len);
+#else
+    ret = PyString_FromStringAndSize(buf, len);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(buf);
 
diff --git a/SWIG/_pkcs7.i b/SWIG/_pkcs7.i
index d1fddfb..cdfd1d6 100644
--- a/SWIG/_pkcs7.i
+++ b/SWIG/_pkcs7.i
@@ -56,7 +56,12 @@ void smime_init(PyObject *smime_err) {
 }
 %}
 
+%threadallow pkcs7_encrypt;
 %inline %{
+PKCS7 *pkcs7_encrypt(STACK_OF(X509) *stack, BIO *bio, EVP_CIPHER *cipher, int flags) {
+    return PKCS7_encrypt(stack, bio, cipher, flags);
+}
+
 PyObject *pkcs7_decrypt(PKCS7 *pkcs7, EVP_PKEY *pkey, X509 *cert, int flags) {
     int outlen;
     char *outbuf;
@@ -80,7 +85,11 @@ PyObject *pkcs7_decrypt(PKCS7 *pkcs7, EVP_PKEY *pkey, X509 *cert, int flags) {
     }
     BIO_read(bio, outbuf, outlen);
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(outbuf, outlen);
+#else
+    ret = PyString_FromStringAndSize(outbuf, outlen);
+#endif // PY_MAJOR_VERSION >= 3
 
     BIO_free(bio);
     PyMem_Free(outbuf);
@@ -88,36 +97,21 @@ PyObject *pkcs7_decrypt(PKCS7 *pkcs7, EVP_PKEY *pkey, X509 *cert, int flags) {
 }
 %}
 
-%typemap(out) PKCS7 * {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-
-    if ($1 != NULL)
-        $result = SWIG_NewPointerObj($1, $1_descriptor, 0);
-    else {
-        m2_PyErr_Msg(_smime_err);
-        $result = NULL;
-    }
-}
-%threadallow pkcs7_encrypt;
-%inline %{
-PKCS7 *pkcs7_encrypt(STACK_OF(X509) *stack, BIO *bio, EVP_CIPHER *cipher, int flags) {
-    return PKCS7_encrypt(stack, bio, cipher, flags);
-}
-
-%}
-
 %threadallow pkcs7_sign1;
 %inline %{
 PKCS7 *pkcs7_sign1(X509 *x509, EVP_PKEY *pkey, STACK_OF(X509) *stack, BIO *bio, EVP_MD *hash, int flags) {
 
     PKCS7 *p7 = PKCS7_sign(NULL, NULL, stack, bio, flags | PKCS7_STREAM);
     if (p7 == NULL) {
+        m2_PyErr_Msg(_pkcs7_err);
         return NULL;
     }
     if (PKCS7_sign_add_signer(p7, x509, pkey, hash, flags) == NULL) {
+        m2_PyErr_Msg(_pkcs7_err);
         return NULL;
     }
     if (PKCS7_final(p7, bio, flags) != 1) {
+        m2_PyErr_Msg(_pkcs7_err);
         return NULL;
     }
     return p7;
@@ -131,32 +125,6 @@ PKCS7 *pkcs7_sign0(X509 *x509, EVP_PKEY *pkey, BIO *bio, EVP_MD *hash, int flags
 }
 %}
 
-%typemap(out) PKCS7 * {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-
-    if ($1 != NULL)
-        $result = SWIG_NewPointerObj($1, $1_descriptor, 0);
-    else {
-        m2_PyErr_Msg(_pkcs7_err);
-        $result = NULL;
-    }
-}
-%threadallow pkcs7_read_bio;
-%inline %{
-PKCS7 *pkcs7_read_bio(BIO *bio) {
-    return PEM_read_bio_PKCS7(bio, NULL, NULL, NULL);
-}
-%}
-
-%threadallow pkcs7_read_bio_der;
-%inline %{
-PKCS7 *pkcs7_read_bio_der(BIO *bio) {
-    return d2i_PKCS7_bio(bio, NULL);
-}
-%}
-
-%typemap(out) PKCS7 * ;
-
 %inline %{
 PyObject *pkcs7_verify1(PKCS7 *pkcs7, STACK_OF(X509) *stack, X509_STORE *store, BIO *data, int flags) {
     int res, outlen;
@@ -184,7 +152,11 @@ PyObject *pkcs7_verify1(PKCS7 *pkcs7, STACK_OF(X509) *stack, X509_STORE *store,
     }
     BIO_read(bio, outbuf, outlen);
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(outbuf, outlen);
+#else
+    ret = PyString_FromStringAndSize(outbuf, outlen);
+#endif // PY_MAJOR_VERSION >= 3
 
     BIO_free(bio);
     PyMem_Free(outbuf);
@@ -247,6 +219,20 @@ PyObject *smime_read_pkcs7(BIO *bio) {
 }
 %}
 
+%threadallow pkcs7_read_bio;
+%inline %{
+PKCS7 *pkcs7_read_bio(BIO *bio) {
+    return PEM_read_bio_PKCS7(bio, NULL, NULL, NULL);
+}
+%}
+
+%threadallow pkcs7_read_bio_der;
+%inline %{
+PKCS7 *pkcs7_read_bio_der(BIO *bio) {
+    return d2i_PKCS7_bio(bio, NULL);
+}
+%}
+
 %threadallow pkcs7_write_bio;
 %inline %{
 int pkcs7_write_bio(PKCS7 *pkcs7, BIO* bio) {
diff --git a/SWIG/_py3k_compat.i b/SWIG/_py3k_compat.i
deleted file mode 100644
index bb32577..0000000
--- a/SWIG/_py3k_compat.i
+++ /dev/null
@@ -1,41 +0,0 @@
-%{
-#if PY_MAJOR_VERSION >= 3
-
-FILE* PyFile_AsFile(PyObject *pyfile) {
-    FILE* fp;
-    int fd;
-    const char *mode_str = NULL;
-    PyObject *mode_obj;
-
-    if ((fd = PyObject_AsFileDescriptor(pyfile)) == -1) {
-        PyErr_SetString(PyExc_BlockingIOError,
-                        "Cannot find file handler for the Python file!");
-        return NULL;
-    }
-
-    if ((mode_obj = PyObject_GetAttrString(pyfile, "mode")) == NULL) {
-        mode_str = "rb";
-        PyErr_Clear();
-    }
-    else {
-        /* convert to plain string
-         * note that error checking is embedded in the function
-         */
-        mode_str = PyUnicode_AsUTF8AndSize(mode_obj, NULL);
-    }
-
-    if((fp = fdopen(fd, mode_str)) == NULL) {
-         PyErr_SetFromErrno(PyExc_IOError);
-    }
-
-    Py_XDECREF(mode_obj);
-    return fp;
-}
-
-#else /* PY2K */
-
-#define PyLong_FromLong(x) PyInt_FromLong(x)
-#define PyUnicode_AsUTF8(x) PyString_AsString(x)
-
-#endif /* PY_MAJOR_VERSION */
-%}
diff --git a/SWIG/_rand.i b/SWIG/_rand.i
index 01ab4ef..20e8d6e 100644
--- a/SWIG/_rand.i
+++ b/SWIG/_rand.i
@@ -30,9 +30,10 @@ void rand_init(PyObject *rand_err) {
 
 PyObject *rand_seed(PyObject *seed) {
     const void *buf;
-    int len = 0;
+    int len;
 
-    m2_PyObject_AsReadBufferInt(seed, &buf, &len);
+    if (m2_PyObject_AsReadBufferInt(seed, &buf, &len) == -1)
+        return NULL;
 
     RAND_seed(buf, len);
     Py_RETURN_NONE;
@@ -40,9 +41,10 @@ PyObject *rand_seed(PyObject *seed) {
 
 PyObject *rand_add(PyObject *blob, double entropy) {
     const void *buf;
-    int len = 0;
+    int len;
 
-    m2_PyObject_AsReadBufferInt(blob, &buf, &len);
+    if (m2_PyObject_AsReadBufferInt(blob, &buf, &len) == -1)
+        return NULL;
 
     RAND_add(buf, len, entropy);
     Py_RETURN_NONE;
@@ -50,31 +52,23 @@ PyObject *rand_add(PyObject *blob, double entropy) {
 
 PyObject *rand_bytes(int n) {
     void *blob;
-    int ret;
     PyObject *obj;
     
     if (!(blob = PyMem_Malloc(n))) {
-        PyErr_SetString(PyExc_MemoryError,
-        "Insufficient memory for rand_bytes.");
+        PyErr_SetString(PyExc_MemoryError, "rand_bytes");
         return NULL;
     }
-    if ((ret = RAND_bytes(blob, n)) == 1) {
+    if (RAND_bytes(blob, n)) {
+#if PY_MAJOR_VERSION >= 3
         obj = PyBytes_FromStringAndSize(blob, n);
+#else
+        obj = PyString_FromStringAndSize(blob, n);
+#endif // PY_MAJOR_VERSION >= 3
         PyMem_Free(blob);
         return obj;
-    } else if (ret == 0) {
-        PyErr_SetString(_rand_err, "Not enough randomness.");
-        PyMem_Free(blob);
-        return NULL;
-    } else if (ret == -1) {
-        PyErr_SetString(_rand_err,
-                        "Not supported by the current RAND method.");
-        PyMem_Free(blob);
-        return NULL;
     } else {
         PyMem_Free(blob);
-        m2_PyErr_Msg(_rand_err);
-        return NULL;
+        Py_RETURN_NONE;
     }
 }
 
@@ -84,7 +78,7 @@ PyObject *rand_pseudo_bytes(int n) {
     PyObject *tuple;
     
     if (!(blob=(unsigned char *)PyMem_Malloc(n))) {
-        PyErr_SetString(PyExc_MemoryError, "Insufficient memory for rand_pseudo_bytes.");
+        PyErr_SetString(PyExc_MemoryError, "rand_pseudo_bytes");
         return NULL;
     }
     if (!(tuple=PyTuple_New(2))) {
@@ -96,14 +90,16 @@ PyObject *rand_pseudo_bytes(int n) {
     if (ret == -1) {
         PyMem_Free(blob);
         Py_DECREF(tuple);
-        PyErr_SetString(_rand_err,
-            "Function RAND_pseudo_bytes not supported by the current RAND method.");
-        return NULL;
+        Py_RETURN_NONE;
     } else {
+#if PY_MAJOR_VERSION >= 3
         PyTuple_SET_ITEM(tuple, 0, PyBytes_FromStringAndSize((char*)blob, n));
+#else
+         PyTuple_SET_ITEM(tuple, 0, PyString_FromStringAndSize((char*)blob, n));
+#endif // PY_MAJOR_VERSION >= 3
 
         PyMem_Free(blob);
-        PyTuple_SET_ITEM(tuple, 1, PyLong_FromLong((long)ret));
+        PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong((long)ret));
         return tuple;
     }
 }
@@ -126,13 +122,13 @@ PyObject *rand_file_name(void) {
 }
 
 void rand_screen(void) {
-#ifdef _WIN32
+#ifdef __WINDOWS__
     RAND_screen();
 #endif
 }
 
 int rand_win32_event(unsigned int imsg, int wparam, long lparam) {
-#ifdef _WIN32
+#ifdef __WINDOWS__
     return RAND_event(imsg, wparam, lparam);
 #else
     return 0;
diff --git a/SWIG/_rc4.i b/SWIG/_rc4.i
index eb4747e..f17e6a6 100644
--- a/SWIG/_rc4.i
+++ b/SWIG/_rc4.i
@@ -31,7 +31,7 @@ void rc4_free(RC4_KEY *key) {
 
 PyObject *rc4_set_key(RC4_KEY *key, PyObject *value) {
     const void *vbuf;
-    int vlen = 0;
+    int vlen;
 
     if (m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         return NULL;
@@ -55,7 +55,11 @@ PyObject *rc4_update(RC4_KEY *key, PyObject *in) {
     }
     RC4(key, len, buf, out);
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize(out, len);
+#else
+    ret = PyString_FromStringAndSize(out, len);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(out);
     return ret;
diff --git a/SWIG/_rsa.i b/SWIG/_rsa.i
index 4ffae01..56873f0 100644
--- a/SWIG/_rsa.i
+++ b/SWIG/_rsa.i
@@ -191,7 +191,7 @@ PyObject *rsa_set_en(RSA *rsa, PyObject *eval, PyObject* nval) {
 static BIGNUM* PyObject_Bin_AsBIGNUM(PyObject* value) {
     BIGNUM* bn;
     const void* vbuf;
-    int vlen = 0;
+    int vlen;
 
     if (m2_PyObject_AsReadBufferInt(value, &vbuf, &vlen) == -1)
         return NULL;
@@ -224,7 +224,7 @@ PyObject *rsa_set_en_bin(RSA *rsa, PyObject *eval, PyObject* nval) {
 PyObject *rsa_private_encrypt(RSA *rsa, PyObject *from, int padding) {
     const void *fbuf;
     void *tbuf;
-    int flen = 0, tlen;
+    int flen, tlen;
     PyObject *ret;
 
     if (m2_PyObject_AsReadBufferInt(from, &fbuf, &flen) == -1)
@@ -242,7 +242,11 @@ PyObject *rsa_private_encrypt(RSA *rsa, PyObject *from, int padding) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((const char *)tbuf, tlen);
+#else
+    ret = PyString_FromStringAndSize((const char *)tbuf, tlen);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(tbuf);
     return ret;
@@ -251,7 +255,7 @@ PyObject *rsa_private_encrypt(RSA *rsa, PyObject *from, int padding) {
 PyObject *rsa_public_decrypt(RSA *rsa, PyObject *from, int padding) {
     const void *fbuf;
     void *tbuf;
-    int flen = 0, tlen = 0;
+    int flen, tlen;
     PyObject *ret;
 
     if (m2_PyObject_AsReadBufferInt(from, &fbuf, &flen) == -1)
@@ -272,7 +276,11 @@ PyObject *rsa_public_decrypt(RSA *rsa, PyObject *from, int padding) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((const char *)tbuf, tlen);
+#else
+    ret = PyString_FromStringAndSize((const char *)tbuf, tlen);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(tbuf);
     return ret;
@@ -281,7 +289,7 @@ PyObject *rsa_public_decrypt(RSA *rsa, PyObject *from, int padding) {
 PyObject *rsa_public_encrypt(RSA *rsa, PyObject *from, int padding) {
     const void *fbuf;
     void *tbuf;
-    int flen = 0, tlen;
+    int flen, tlen;
     PyObject *ret;
 
     if (m2_PyObject_AsReadBufferInt(from, &fbuf, &flen) == -1)
@@ -299,7 +307,11 @@ PyObject *rsa_public_encrypt(RSA *rsa, PyObject *from, int padding) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((const char *)tbuf, tlen);
+#else
+    ret = PyString_FromStringAndSize((const char *)tbuf, tlen);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(tbuf);
     return ret;
@@ -308,7 +320,7 @@ PyObject *rsa_public_encrypt(RSA *rsa, PyObject *from, int padding) {
 PyObject *rsa_private_decrypt(RSA *rsa, PyObject *from, int padding) {
     const void *fbuf;
     void *tbuf;
-    int flen = 0, tlen;
+    int flen, tlen;
     PyObject *ret;
 
     if (m2_PyObject_AsReadBufferInt(from, &fbuf, &flen) == -1)
@@ -325,7 +337,11 @@ PyObject *rsa_private_decrypt(RSA *rsa, PyObject *from, int padding) {
         PyMem_Free(tbuf);
         return NULL;
     }
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((const char *)tbuf, tlen);
+#else
+    ret = PyString_FromStringAndSize((const char *)tbuf, tlen);
+#endif // PY_MAJOR_VERSION >= 3
 
     PyMem_Free(tbuf);
     return ret;
@@ -360,7 +376,11 @@ PyObject *rsa_padding_add_pkcs1_pss(RSA *rsa, PyObject *digest, EVP_MD *hash, in
         OPENSSL_free(tbuf);
         return NULL;
     }
+#if PY_MAJOR_VERSION >= 3
     ret = PyBytes_FromStringAndSize((const char *)tbuf, tlen);
+#else
+    ret = PyString_FromStringAndSize((const char *)tbuf, tlen);
+#endif // PY_MAJOR_VERSION >= 3
     OPENSSL_cleanse(tbuf, tlen);
     OPENSSL_free(tbuf);
     return ret;
@@ -417,7 +437,11 @@ PyObject *rsa_sign(RSA *rsa, PyObject *py_digest_string, int method_type) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     signature =  PyBytes_FromStringAndSize((const char*) sign_buf, buf_len);
+#else
+    signature =  PyString_FromStringAndSize((const char*) sign_buf, buf_len);
+#endif
 
     PyMem_Free(sign_buf);
     return signature;
diff --git a/SWIG/_ssl.i b/SWIG/_ssl.i
index 3225ffd..c642f45 100644
--- a/SWIG/_ssl.i
+++ b/SWIG/_ssl.i
@@ -8,6 +8,13 @@
 **
 */
 /* $Id$ */
+%begin %{
+#ifdef _MSC_VER
+#include <Winsock2.h>
+#pragma comment(lib, "Ws2_32")
+typedef unsigned __int64 uint64_t;
+#endif
+%}
 %{
 #include <pythread.h>
 #include <limits.h>
@@ -16,18 +23,13 @@
 #include <openssl/ssl.h>
 #include <openssl/tls1.h>
 #include <openssl/x509.h>
-#ifdef _WIN32
-#include <WinSock2.h>
-#include <Windows.h>
-#pragma comment(lib, "Ws2_32")
-typedef unsigned __int64 uint64_t;
-#else
+#ifndef _MSC_VER
 #include <poll.h>
 #include <sys/time.h>
 #endif
 %}
 
-#if OPENSSL_VERSION_NUMBER >= 0x10100005L
+#if OPENSSL_VERSION_NUMBER >= 0x10100005L && !defined(LIBRESSL_VERSION_NUMBER)
 %include <openssl/safestack.h>
 #endif
 
@@ -266,7 +268,7 @@ void ssl_init(PyObject *ssl_err, PyObject *ssl_timeout_err) {
 
 #ifndef OPENSSL_NO_SSL3
 const SSL_METHOD *sslv3_method(void) {
-#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER)
     PyErr_WarnEx(PyExc_DeprecationWarning,
                  "Function SSLv3_method has been deprecated.", 1);
 #endif
@@ -275,7 +277,7 @@ const SSL_METHOD *sslv3_method(void) {
 #endif
 
 const SSL_METHOD *tlsv1_method(void) {
-#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER)
     PyErr_WarnEx(PyExc_DeprecationWarning,
                  "Function TLSv1_method has been deprecated.", 1);
 #endif
@@ -290,7 +292,7 @@ void ssl_ctx_passphrase_callback(SSL_CTX *ctx, PyObject *pyfunc) {
 
 int ssl_ctx_use_x509(SSL_CTX *ctx, X509 *x) {
     int i;
-
+    
     if (!(i = SSL_CTX_use_certificate(ctx, x))) {
         m2_PyErr_Msg(_ssl_err);
         return -1;
@@ -301,7 +303,7 @@ int ssl_ctx_use_x509(SSL_CTX *ctx, X509 *x) {
 
 int ssl_ctx_use_cert(SSL_CTX *ctx, char *file) {
     int i;
-
+    
     if (!(i = SSL_CTX_use_certificate_file(ctx, file, SSL_FILETYPE_PEM))) {
         m2_PyErr_Msg(_ssl_err);
         return -1;
@@ -322,7 +324,7 @@ int ssl_ctx_use_cert_chain(SSL_CTX *ctx, char *file) {
 
 int ssl_ctx_use_privkey(SSL_CTX *ctx, char *file) {
     int i;
-
+    
     if (!(i = SSL_CTX_use_PrivateKey_file(ctx, file, SSL_FILETYPE_PEM))) {
         m2_PyErr_Msg(_ssl_err);
         return -1;
@@ -353,7 +355,7 @@ int ssl_ctx_use_pkey_privkey(SSL_CTX *ctx, EVP_PKEY *pkey) {
 
 int ssl_ctx_check_privkey(SSL_CTX *ctx) {
     int ret;
-
+    
     if (!(ret = SSL_CTX_check_private_key(ctx))) {
         m2_PyErr_Msg(_ssl_err);
         return -1;
@@ -378,7 +380,7 @@ void ssl_ctx_set_verify(SSL_CTX *ctx, int mode, PyObject *pyfunc) {
 
 int ssl_ctx_set_session_id_context(SSL_CTX *ctx, PyObject *sid_ctx) {
     const void *buf;
-    int len = 0;
+    int len;
 
     if (m2_PyObject_AsReadBufferInt(sid_ctx, &buf, &len) == -1)
         return -1;
@@ -458,7 +460,7 @@ void ssl_set_client_CA_list_from_context(SSL *ssl, SSL_CTX *ctx) {
 
 int ssl_set_session_id_context(SSL *ssl, PyObject *sid_ctx) {
     const void *buf;
-    int len = 0;
+    int len;
 
     if (m2_PyObject_AsReadBufferInt(sid_ctx, &buf, &len) == -1)
         return -1;
@@ -468,7 +470,7 @@ int ssl_set_session_id_context(SSL *ssl, PyObject *sid_ctx) {
 
 int ssl_set_fd(SSL *ssl, int fd) {
     int ret;
-
+    
     if (!(ret = SSL_set_fd(ssl, fd))) {
         m2_PyErr_Msg(_ssl_err);
         return -1;
@@ -495,14 +497,14 @@ static void ssl_handle_error(int ssl_err, int ret) {
             else
                 assert(0);
             break;
-        default:
+		default:
             PyErr_SetString(_ssl_err, "unexpected SSL error");
      }
 }
 
-#ifdef _WIN32
+#ifdef _MSC_VER
 /* http://stackoverflow.com/questions/10905892/equivalent-of-gettimeday-for-windows */
-int gettimeofday(struct timeval *tp, void *tzp)
+int gettimeofday(struct timeval * tp, struct timezone * tzp)
 {
     // Note: some broken versions only have 8 trailing zero's, the correct epoch has 9 trailing zero's
     static const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);
@@ -524,11 +526,7 @@ int gettimeofday(struct timeval *tp, void *tzp)
 
 static int ssl_sleep_with_timeout(SSL *ssl, const struct timeval *start,
                                   double timeout, int ssl_err) {
-#ifdef _WIN32
-WSAPOLLFD fd;
-#else
-struct pollfd fd;
-#endif
+    struct pollfd fd;
     struct timeval tv;
     int ms, tmp;
 
@@ -574,7 +572,7 @@ struct pollfd fd;
         return -1;
     }
     Py_BEGIN_ALLOW_THREADS
-#ifdef _WIN32
+#ifdef _MSC_VER
     tmp = WSAPoll(&fd, 1, ms);
 #else
     tmp = poll(&fd, 1, ms);
@@ -586,7 +584,7 @@ struct pollfd fd;
     	case 0:
             goto timeout;
     	case -1:
-#ifdef _WIN32
+#ifdef _MSC_VER
             if (WSAGetLastError() == EINTR)
 #else
             if (errno == EINTR)
@@ -619,12 +617,12 @@ PyObject *ssl_accept(SSL *ssl, double timeout) {
     switch (ssl_err) {
         case SSL_ERROR_NONE:
         case SSL_ERROR_ZERO_RETURN:
-            obj = PyLong_FromLong((long)1);
+            obj = PyInt_FromLong((long)1);
             break;
         case SSL_ERROR_WANT_WRITE:
         case SSL_ERROR_WANT_READ:
             if (timeout <= 0) {
-                obj = PyLong_FromLong((long)0);
+                obj = PyInt_FromLong((long)0);
                 break;
             }
             if (ssl_sleep_with_timeout(ssl, &tv, timeout, ssl_err) == 0)
@@ -659,12 +657,12 @@ PyObject *ssl_connect(SSL *ssl, double timeout) {
     switch (ssl_err) {
         case SSL_ERROR_NONE:
         case SSL_ERROR_ZERO_RETURN:
-            obj = PyLong_FromLong((long)1);
+            obj = PyInt_FromLong((long)1);
             break;
         case SSL_ERROR_WANT_WRITE:
         case SSL_ERROR_WANT_READ:
             if (timeout <= 0) {
-                obj = PyLong_FromLong((long)0);
+                obj = PyInt_FromLong((long)0);
                 break;
             }
             if (ssl_sleep_with_timeout(ssl, &tv, timeout, ssl_err) == 0)
@@ -707,7 +705,11 @@ PyObject *ssl_read(SSL *ssl, int num, double timeout) {
 
     if (r >= 0) {
         buf = PyMem_Realloc(buf, r);
+#if PY_MAJOR_VERSION >= 3
         obj = PyBytes_FromStringAndSize(buf, r);
+#else
+        obj = PyString_FromStringAndSize(buf, r);
+#endif //PY_MAJOR_VERSION >= 3
     } else {
         int ssl_err;
 
@@ -752,19 +754,23 @@ PyObject *ssl_read_nbio(SSL *ssl, int num) {
         PyErr_SetString(PyExc_MemoryError, "ssl_read");
         return NULL;
     }
-
-
+    
+    
     Py_BEGIN_ALLOW_THREADS
     r = SSL_read(ssl, buf, num);
     Py_END_ALLOW_THREADS
-
-
+    
+    
     switch (SSL_get_error(ssl, r)) {
         case SSL_ERROR_NONE:
         case SSL_ERROR_ZERO_RETURN:
             buf = PyMem_Realloc(buf, r);
 
+#if PY_MAJOR_VERSION >= 3
             obj = PyBytes_FromStringAndSize(buf, r);
+#else
+            obj = PyString_FromStringAndSize(buf, r);
+#endif // PY_MAJOR_VERSION >= 3
 
             break;
         case SSL_ERROR_WANT_WRITE:
@@ -789,8 +795,8 @@ PyObject *ssl_read_nbio(SSL *ssl, int num) {
             break;
     }
     PyMem_Free(buf);
-
-
+    
+    
     return obj;
 }
 
@@ -835,7 +841,7 @@ int ssl_write(SSL *ssl, PyObject *blob, double timeout) {
         default:
             ret = -1;
     }
-
+    
     m2_PyBuffer_Release(blob, &buf);
     return ret;
 }
@@ -849,12 +855,12 @@ int ssl_write_nbio(SSL *ssl, PyObject *blob) {
         return -1;
     }
 
-
+    
     Py_BEGIN_ALLOW_THREADS
     r = SSL_write(ssl, buf.buf, buf.len);
     Py_END_ALLOW_THREADS
-
-
+    
+    
     switch (SSL_get_error(ssl, r)) {
         case SSL_ERROR_NONE:
         case SSL_ERROR_ZERO_RETURN:
@@ -879,7 +885,7 @@ int ssl_write_nbio(SSL *ssl, PyObject *blob) {
         default:
             ret = -1;
     }
-
+    
     m2_PyBuffer_Release(blob, &buf);
     return ret;
 }
@@ -916,23 +922,12 @@ void i2d_ssl_session(BIO *bio, SSL_SESSION *sess) {
 }
 %}
 
-%typemap(out) SSL_SESSION * {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-
-    if ($1 != NULL)
-        $result = SWIG_NewPointerObj($1, $1_descriptor, 0);
-    else {
-        m2_PyErr_Msg(_ssl_err);
-        $result = NULL;
-    }
-}
 %threadallow ssl_session_read_pem;
 %inline %{
 SSL_SESSION *ssl_session_read_pem(BIO *bio) {
     return PEM_read_bio_SSL_SESSION(bio, NULL, NULL, NULL);
 }
 %}
-%typemap(out) SSL_SESSION * ;
 
 %threadallow ssl_session_write_pem;
 %inline %{
diff --git a/SWIG/_threads.i b/SWIG/_threads.i
index 69adb9f..2a98dec 100644
--- a/SWIG/_threads.i
+++ b/SWIG/_threads.i
@@ -5,7 +5,7 @@
 #include <pythread.h>
 #include <openssl/crypto.h>
 
-#if defined(THREADING) && OPENSSL_VERSION_NUMBER < 0x10100000L
+#if defined(THREADING) && (OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER))
 #define CRYPTO_num_locks()      (CRYPTO_NUM_LOCKS)
 static PyThread_type_lock lock_cs[CRYPTO_num_locks()];
 static long lock_count[CRYPTO_num_locks()];
@@ -13,7 +13,7 @@ static int thread_mode = 0;
 #endif
 
 void threading_locking_callback(int mode, int type, const char *file, int line) {
-#if defined(THREADING) && OPENSSL_VERSION_NUMBER < 0x10100000L
+#if defined(THREADING) && (OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER))
         if (mode & CRYPTO_LOCK) {
                 PyThread_acquire_lock(lock_cs[type], WAIT_LOCK);
                 lock_count[type]++;
@@ -25,7 +25,7 @@ void threading_locking_callback(int mode, int type, const char *file, int line)
 }
 
 unsigned long threading_id_callback(void) {
-#if defined(THREADING) && OPENSSL_VERSION_NUMBER < 0x10100000L
+#if defined(THREADING) && (OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER))
     return (unsigned long)PyThread_get_thread_ident();
 #else
     return (unsigned long)0;
@@ -35,7 +35,7 @@ unsigned long threading_id_callback(void) {
 
 %inline %{
 void threading_init(void) {
-#if defined(THREADING) && OPENSSL_VERSION_NUMBER < 0x10100000L
+#if defined(THREADING) && (OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER))
     int i;
     if (!thread_mode) {
         for (i=0; i<CRYPTO_num_locks(); i++) {
@@ -50,7 +50,7 @@ void threading_init(void) {
 }
 
 void threading_cleanup(void) {
-#if defined(THREADING) && OPENSSL_VERSION_NUMBER < 0x10100000L
+#if defined(THREADING) && (OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER))
     int i;
     if (thread_mode) {
         CRYPTO_set_locking_callback(NULL);
diff --git a/SWIG/_util.i b/SWIG/_util.i
index bc2ee61..34d7dd2 100644
--- a/SWIG/_util.i
+++ b/SWIG/_util.i
@@ -31,7 +31,11 @@ PyObject *util_hex_to_string(PyObject *blob) {
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3
     obj = PyBytes_FromString(ret);
+#else
+    obj = PyString_FromString(ret);
+#endif // PY_MAJOR_VERSION >= 3
 
     OPENSSL_free(ret);
     return obj;
@@ -53,7 +57,11 @@ PyObject *util_string_to_hex(PyObject *blob) {
         m2_PyErr_Msg(_util_err);
         return NULL;
     }
+#if PY_MAJOR_VERSION >= 3
     obj = PyBytes_FromStringAndSize((char*)ret, len);
+#else
+    obj = PyString_FromStringAndSize((char*)ret, len);
+#endif // PY_MAJOR_VERSION >= 3
     OPENSSL_free(ret);
     return obj;
 }
diff --git a/SWIG/_x509.i b/SWIG/_x509.i
index 3c3e83e..70b3339 100644
--- a/SWIG/_x509.i
+++ b/SWIG/_x509.i
@@ -75,7 +75,7 @@ extern int X509_set_subject_name(X509 *, X509_NAME *);
 %rename(x509_cmp_current_time) X509_cmp_current_time;
 extern int X509_cmp_current_time(ASN1_TIME *);
 
-
+                            
 /* From x509.h */
 /* standard trust ids */
 %constant int X509_TRUST_DEFAULT      = -1;
@@ -187,22 +187,22 @@ extern ASN1_OBJECT *X509_NAME_ENTRY_get_object(X509_NAME_ENTRY *);
 extern ASN1_STRING *X509_NAME_ENTRY_get_data(X509_NAME_ENTRY *);
 
 %typemap(in) (const unsigned char *, int) {
-#if PY_MAJOR_VERSION >= 3
+#if PY_MAJOR_VERSION >= 3 
     if (PyBytes_Check($input)) {
         Py_ssize_t len;
 
-        $1 = PyBytes_AsString($input);
+        $1 = PyBytes_AsString($input); 
         len = PyBytes_Size($input);
 #else
     if (PyString_Check($input)) {
         Py_ssize_t len;
 
-        $1 = (unsigned char *)PyString_AsString($input);
+        $1 = (unsigned char *)PyString_AsString($input); 
         len = PyString_Size($input);
 #endif // PY_MAJOR_VERSION >= 3
 
         if (len > INT_MAX) {
-            PyErr_SetString(_x509_err, "object too large");
+            PyErr_SetString(PyExc_ValueError, "object too large");
             return NULL;
         }
         $2 = len;
@@ -268,35 +268,6 @@ extern int X509_EXTENSION_get_critical(X509_EXTENSION *);
 %rename(x509_extension_set_critical) X509_EXTENSION_set_critical;
 extern int X509_EXTENSION_set_critical(X509_EXTENSION *, int);
 
-%typemap(out) X509 * {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-
-    if ($1 != NULL)
-        $result = SWIG_NewPointerObj($1, $1_descriptor, 0);
-    else {
-        m2_PyErr_Msg(_x509_err);
-        $result = NULL;
-    }
-}
-
-
-/* Functions using m2_PyErr_Msg and thus using internal Python C API are
- * not thread safe, so if we want to have %threadallow here, error
- * handling must be done outside of these internal functions. */
-%threadallow x509_read_pem;
-%inline %{
-X509 *x509_read_pem(BIO *bio) {
-    return PEM_read_bio_X509(bio, NULL, NULL, NULL);
-}
-%}
-
-%threadallow d2i_x509;
-%inline %{
-X509 *d2i_x509(BIO *bio) {
-    return d2i_X509_bio(bio, NULL);
-}
-%}
-%typemap(out) X509 *;
 
 %constant int NID_commonName                  = 13;
 %constant int NID_countryName                 = 14;
@@ -379,34 +350,28 @@ void x509_init(PyObject *x509_err) {
 }
 %}
 
-%typemap(out) X509_REQ * {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-
-    if ($1 != NULL)
-        $result = SWIG_NewPointerObj($1, $1_descriptor, 0);
-    else {
-        m2_PyErr_Msg(_x509_err);
-        $result = NULL;
-    }
-}
-%threadallow d2i_x509_req;
+%threadallow x509_read_pem;
 %inline %{
-X509_REQ *d2i_x509_req(BIO *bio) {
-    return d2i_X509_REQ_bio(bio, NULL);
+X509 *x509_read_pem(BIO *bio) {
+    return PEM_read_bio_X509(bio, NULL, NULL, NULL);
 }
 %}
 
-%threadallow x509_req_read_pem;
+%threadallow d2i_x509;
 %inline %{
-X509_REQ *x509_req_read_pem(BIO *bio) {
-    return PEM_read_bio_X509_REQ(bio, NULL, NULL, NULL);
+X509 *d2i_x509(BIO *bio) {
+    return d2i_X509_bio(bio, NULL);
 }
 %}
 
-%typemap(out) X509_REQ *;
-
+%threadallow d2i_x509_req;
 %inline %{
-PyObject *i2d_x509(X509 *x) {
+X509_REQ *d2i_x509_req(BIO *bio) {
+    return d2i_X509_REQ_bio(bio, NULL);
+}
+
+PyObject *i2d_x509(X509 *x)
+{
     int len;
     PyObject *ret = NULL;
     unsigned char *buf = NULL;
@@ -414,9 +379,13 @@ PyObject *i2d_x509(X509 *x) {
     if (len < 0) {
         m2_PyErr_Msg(_x509_err);
     }
-    else {
+    else {     
 
+#if PY_MAJOR_VERSION >= 3 
         ret = PyBytes_FromStringAndSize((char*)buf, len);
+#else
+        ret = PyString_FromStringAndSize((char*)buf, len);
+#endif // PY_MAJOR_VERSION >= 3 
 
         OPENSSL_free(buf);
     }
@@ -424,6 +393,13 @@ PyObject *i2d_x509(X509 *x) {
 }
 %}
 
+%threadallow x509_req_read_pem;
+%inline %{
+X509_REQ *x509_req_read_pem(BIO *bio) {
+    return PEM_read_bio_X509_REQ(bio, NULL, NULL, NULL);
+}
+%}
+
 %threadallow x509_req_write_pem;
 %inline %{
 int x509_req_write_pem(BIO *bio, X509_REQ *x) {
@@ -431,25 +407,12 @@ int x509_req_write_pem(BIO *bio, X509_REQ *x) {
 }
 %}
 
-%typemap(out) X509_CRL * {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-
-    if ($1 != NULL)
-        $result = SWIG_NewPointerObj($1, $1_descriptor, 0);
-    else {
-        m2_PyErr_Msg(_x509_err);
-        $result = NULL;
-    }
-}
 %threadallow x509_crl_read_pem;
 %inline %{
 X509_CRL *x509_crl_read_pem(BIO *bio) {
     return PEM_read_bio_X509_CRL(bio, NULL, NULL, NULL);
 }
-%}
-%typemap(out) X509_CRL * ;
 
-%inline %{
 /* X509_set_version() is a macro. */
 int x509_set_version(X509 *x, long version) {
     return X509_set_version(x, version);
@@ -504,14 +467,23 @@ PyObject *x509_name_by_nid(X509_NAME *name, int nid) {
     }
     xlen = X509_NAME_get_text_by_NID(name, nid, buf, len);
 
+/* FIXME Shouldn’t we have here casting to (char *) as well? */
+#if PY_MAJOR_VERSION >= 3 
     ret = PyBytes_FromStringAndSize(buf, xlen);
+#else
+    ret = PyString_FromStringAndSize(buf, xlen);
+#endif // PY_MAJOR_VERSION >= 3 
 
     PyMem_Free(buf);
     return ret;
 }
 
 int x509_name_set_by_nid(X509_NAME *name, int nid, PyObject *obj) {
+#if PY_MAJOR_VERSION >= 3 
     return X509_NAME_add_entry_by_NID(name, nid, MBSTRING_ASC, (unsigned char *)PyBytes_AsString(obj), -1, -1, 0);
+#else
+    return X509_NAME_add_entry_by_NID(name, nid, MBSTRING_ASC, (unsigned char *)PyString_AsString(obj), -1, -1, 0);
+#endif // PY_MAJOR_VERSION >= 3 
 }
 
 /* x509_name_add_entry_by_txt */
@@ -519,7 +491,8 @@ int x509_name_add_entry_by_txt(X509_NAME *name, char *field, int type, char *byt
     return X509_NAME_add_entry_by_txt(name, field, type, (unsigned char *)bytes, len, loc, set);
 }
 
-PyObject *x509_name_get_der(X509_NAME *name) {
+PyObject *x509_name_get_der(X509_NAME *name)
+{
     const char* pder="";
     size_t pderlen;
     i2d_X509_NAME(name, 0);
@@ -527,7 +500,16 @@ PyObject *x509_name_get_der(X509_NAME *name) {
         m2_PyErr_Msg(_x509_err);
         return NULL;
     }
+#if PY_MAJOR_VERSION >= 3 
     return PyBytes_FromStringAndSize(pder, pderlen);
+#else
+    return PyString_FromStringAndSize(pder, pderlen);
+#endif // PY_MAJOR_VERSION >= 3 
+}
+
+/* sk_X509_new_null() is a macro returning "STACK_OF(X509) *". */
+STACK_OF(X509) *sk_x509_new_null(void) {
+    return sk_X509_new_null();
 }
 
 /* sk_X509_free() is a macro. */
@@ -544,16 +526,9 @@ int sk_x509_push(STACK_OF(X509) *stack, X509 *x509) {
 X509 *sk_x509_pop(STACK_OF(X509) *stack) {
     return sk_X509_pop(stack);
 }
-%}
 
-%inline %{
 int x509_store_load_locations(X509_STORE *store, const char *file) {
-    int locations = 0;
-
-    if ((locations = X509_STORE_load_locations(store, file, NULL)) < 1) {
-        m2_PyErr_Msg(_x509_err);
-    }
-    return locations;
+    return X509_STORE_load_locations(store, file, NULL);
 }
 
 int x509_type_check(X509 *x509) {
@@ -583,18 +558,7 @@ int x509_req_add_extensions(X509_REQ *req, STACK_OF(X509_EXTENSION) *exts) {
 X509_NAME_ENTRY *x509_name_entry_create_by_txt(X509_NAME_ENTRY **ne, char *field, int type, char *bytes, int len) {
     return X509_NAME_ENTRY_create_by_txt( ne, field, type, (unsigned char *)bytes, len);
 }
-%}
-
-%typemap(out) X509V3_CTX * {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
 
-    if ($1 != NULL)
-        $result = SWIG_NewPointerObj($1, $1_descriptor, 0);
-    else {
-        $result = NULL;
-    }
-}
-%inline %{
 X509V3_CTX *
 x509v3_set_nconf(void) {
       X509V3_CTX * ctx;
@@ -604,35 +568,18 @@ x509v3_set_nconf(void) {
           PyErr_SetString(PyExc_MemoryError, "x509v3_set_nconf");
           return NULL;
       }
-      /* X509V3_set_nconf does not generate any error signs at all. */
       X509V3_set_nconf(ctx, conf);
       return ctx;
 }
-%}
-%typemap(out) X509V3_CTX * ;
 
-%typemap(out) X509_EXTENSION * {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-
-    if ($1 != NULL)
-        $result = SWIG_NewPointerObj($1, $1_descriptor, 0);
-    else {
-        m2_PyErr_Msg(_x509_err);
-        $result = NULL;
-    }
-}
-%inline %{
 X509_EXTENSION *
 x509v3_ext_conf(void *conf, X509V3_CTX *ctx, char *name, char *value) {
       X509_EXTENSION * ext = NULL;
-      ext = X509V3_EXT_conf(conf, ctx, name, value);
-      PyMem_Free(ctx);
+      ext = X509V3_EXT_conf(conf, ctx, name, value); 
+      PyMem_Free(ctx); 
       return ext;
 }
-%}
-%typemap(out) X509_EXTENSION * ;
 
-%inline %{
 /* X509_EXTENSION_free() might be a macro, didn't find definition. */
 void x509_extension_free(X509_EXTENSION *ext) {
     X509_EXTENSION_free(ext);
@@ -640,13 +587,17 @@ void x509_extension_free(X509_EXTENSION *ext) {
 
 PyObject *x509_extension_get_name(X509_EXTENSION *ext) {
     PyObject * ext_name;
-    const char * ext_name_str;
+    const char * ext_name_str; 
     ext_name_str = OBJ_nid2sn(OBJ_obj2nid(X509_EXTENSION_get_object(ext)));
     if (!ext_name_str) {
         m2_PyErr_Msg(_x509_err);
         return NULL;
     }
+#if PY_MAJOR_VERSION >= 3 
     ext_name = PyBytes_FromStringAndSize(ext_name_str, strlen(ext_name_str));
+#else
+    ext_name = PyString_FromStringAndSize(ext_name_str, strlen(ext_name_str));
+#endif // PY_MAJOR_VERSION >= 3 
     return ext_name;
 }
 
@@ -696,78 +647,67 @@ void x509_store_set_verify_cb(X509_STORE *store, PyObject *pyfunc) {
     x509_store_verify_cb_func = pyfunc;
     X509_STORE_set_verify_cb(store, x509_store_verify_callback);
 }
-%}
-
-%typemap(out) STACK_OF(X509) * {
-    PyObject *self = NULL; /* bug in SWIG_NewPointerObj as of 3.0.5 */
-
-    if ($1 != NULL)
-        $result = SWIG_NewPointerObj($1, $1_descriptor, 0);
-    else {
-        $result = NULL;
-    }
-}
 
-%inline %{
 STACK_OF(X509) *
 make_stack_from_der_sequence(PyObject * pyEncodedString){
     STACK_OF(X509) *certs;
     Py_ssize_t encoded_string_len;
     char *encoded_string;
-    const unsigned char *tmp_str;
 
+#if PY_MAJOR_VERSION >= 3 
     encoded_string_len = PyBytes_Size(pyEncodedString);
+#else
+    encoded_string_len = PyString_Size(pyEncodedString);
+#endif
 
     if (encoded_string_len > INT_MAX) {
-        PyErr_Format(_x509_err, "object too large");
+        PyErr_SetString(PyExc_ValueError, "object too large");
         return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3 
     encoded_string = PyBytes_AsString(pyEncodedString);
+#else
+    encoded_string = PyString_AsString(pyEncodedString);
+#endif 
 
     if (!encoded_string) {
-        PyErr_SetString(_x509_err,
-                        "Cannot convert Python Bytes to (char *).");
         return NULL;
     }
 
-    tmp_str = (unsigned char *)encoded_string;
+    const unsigned char *tmp_str = (unsigned char *)encoded_string;
     certs = d2i_SEQ_CERT(NULL, &tmp_str, encoded_string_len);
-    if (certs == NULL) {
-        PyErr_SetString(_x509_err, "Generating STACK_OF(X509) failed.");
+    if (!certs) {
+        m2_PyErr_Msg(_x509_err);
         return NULL;
     }
-    return certs;
-}
 
-/* sk_X509_new_null() is a macro returning "STACK_OF(X509) *". */
-STACK_OF(X509) *sk_x509_new_null(void) {
-    return sk_X509_new_null();
+    return certs;
 }
-%}
-
-%typemap(out) STACK_OF(X509) *;
 
-%inline %{
 PyObject *
 get_der_encoding_stack(STACK_OF(X509) *stack){
     PyObject * encodedString;
-
+    
     unsigned char * encoding = NULL;
-    int len;
-
+    int len; 
+    
     len = i2d_SEQ_CERT(stack, &encoding);
     if (!encoding) {
        m2_PyErr_Msg(_x509_err);
        return NULL;
     }
 
+#if PY_MAJOR_VERSION >= 3 
     encodedString = PyBytes_FromStringAndSize((const char *)encoding, len);
+#else
+    encodedString = PyString_FromStringAndSize((const char *)encoding, len);
+#endif // PY_MAJOR_VERSION >= 3 
 
     if (encoding)
         OPENSSL_free(encoding);
 
-    return encodedString;
+    return encodedString; 
 }
 
 %}
@@ -775,7 +715,7 @@ get_der_encoding_stack(STACK_OF(X509) *stack){
 /* Free malloc'ed return value for x509_name_oneline */
 %typemap(ret) char * {
     if ($1 != NULL)
-        OPENSSL_free($1);
+        OPENSSL_free($1); 
 }
 %inline %{
 char *x509_name_oneline(X509_NAME *x) {
diff --git a/SWIG/libcrypto-compat.h b/SWIG/libcrypto-compat.h
index 7c4c913..f7df0bc 100644
--- a/SWIG/libcrypto-compat.h
+++ b/SWIG/libcrypto-compat.h
@@ -1,14 +1,13 @@
 #ifndef LIBCRYPTO_COMPAT_H
 #define LIBCRYPTO_COMPAT_H
 
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#if OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER)
 
 #include <openssl/rsa.h>
 #include <openssl/dsa.h>
 #include <openssl/ecdsa.h>
 #include <openssl/dh.h>
 #include <openssl/evp.h>
-#include <openssl/x509.h>
 
 int RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d);
 int RSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q);
diff --git a/SWIG/py3k_compat.h b/SWIG/py3k_compat.h
deleted file mode 100644
index 2e914a5..0000000
--- a/SWIG/py3k_compat.h
+++ /dev/null
@@ -1,32 +0,0 @@
-#ifndef PY3K_COMPAT_H
-#define PY3K_COMPAT_H
-
-#if PY_MAJOR_VERSION >= 3
-
-FILE* PyFile_AsFile(PyObject *p);
-PyObject* PyFile_Name(PyObject *p);
-
-#else /* PY2K */
-
-/* Concerning PyBytes* functions:
- *
- * Python 3’s str() type is equivalent to Python 2’s unicode(); the
- * C functions are called PyUnicode_* for both. The old 8-bit string
- * type has become bytes(), with C functions called PyBytes_*. Python
- * 2.6 and later provide a compatibility header, bytesobject.h, mapping
- * PyBytes names to PyString ones. For best compatibility with Python 3,
- * PyUnicode should be used for textual data and PyBytes for binary
- * data. It’s also important to remember that PyBytes and PyUnicode in
- * Python 3 are not interchangeable like PyString and PyUnicode are in
- * Python 2. The following example shows best practices with regards to
- * PyUnicode, PyString, and PyBytes.
- *
- * From https://docs.python.org/2.7/howto/cporting.html
- */
-
-PyObject* PyLong_FromLong(long x);
-const char* PyUnicode_AsUTF8(PyObject *unicode);
-
-#endif /* PY_MAJOR_VERSION */
-
-#endif /* PY3K_COMPAT_H */
